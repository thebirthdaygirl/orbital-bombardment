{"ast":null,"code":"/*!\n * @pixi/graphics - v5.3.3\n * Compiled Tue, 04 Aug 2020 16:23:09 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture, BaseTexture, BatchDrawCall, BatchTextureArray, BatchGeometry, State, UniformGroup, Shader } from '@pixi/core';\nimport { SHAPES, Point, Polygon, PI_2, Matrix, Rectangle, RoundedRectangle, Circle, Ellipse } from '@pixi/math';\nimport { earcut, premultiplyTint, deprecation, hex2rgb } from '@pixi/utils';\nimport { WRAP_MODES, DRAW_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Bounds, Container } from '@pixi/display';\n\n/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n *\n * @name LINE_JOIN\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n * @property {string} ROUND - 'round': add an arc at the joint\n */\nvar LINE_JOIN;\n(function (LINE_JOIN) {\n  LINE_JOIN[\"MITER\"] = \"miter\";\n  LINE_JOIN[\"BEVEL\"] = \"bevel\";\n  LINE_JOIN[\"ROUND\"] = \"round\";\n})(LINE_JOIN || (LINE_JOIN = {}));\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n *\n * @name LINE_CAP\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\n * @property {string} ROUND - 'round': add semicircle at ends\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\n */\nvar LINE_CAP;\n(function (LINE_CAP) {\n  LINE_CAP[\"BUTT\"] = \"butt\";\n  LINE_CAP[\"ROUND\"] = \"round\";\n  LINE_CAP[\"SQUARE\"] = \"square\";\n})(LINE_CAP || (LINE_CAP = {}));\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nvar GRAPHICS_CURVES = {\n  adaptive: true,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 0.0001,\n  _segmentsCount: function (length, defaultSegments) {\n    if (defaultSegments === void 0) {\n      defaultSegments = 20;\n    }\n    if (!this.adaptive || !length || isNaN(length)) {\n      return defaultSegments;\n    }\n    var result = Math.ceil(length / this.maxLength);\n    if (result < this.minSegments) {\n      result = this.minSegments;\n    } else if (result > this.maxSegments) {\n      result = this.maxSegments;\n    }\n    return result;\n  }\n};\n\n/**\n * Fill style object for Graphics.\n *\n * @class\n * @memberof PIXI\n */\nvar FillStyle = /** @class */function () {\n  function FillStyle() {\n    /**\n     * The hex color value used when coloring the Graphics object.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    this.color = 0xFFFFFF;\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.alpha = 1.0;\n    /**\n     * The texture to be used for the fill.\n     *\n     * @member {PIXI.Texture}\n     * @default 0\n     */\n    this.texture = Texture.WHITE;\n    /**\n     * The transform aplpied to the texture.\n     *\n     * @member {PIXI.Matrix}\n     * @default null\n     */\n    this.matrix = null;\n    /**\n     * If the current fill is visible.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.visible = false;\n    this.reset();\n  }\n  /**\n   * Clones the object\n   *\n   * @return {PIXI.FillStyle}\n   */\n  FillStyle.prototype.clone = function () {\n    var obj = new FillStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    return obj;\n  };\n  /**\n   * Reset\n   */\n  FillStyle.prototype.reset = function () {\n    this.color = 0xFFFFFF;\n    this.alpha = 1;\n    this.texture = Texture.WHITE;\n    this.matrix = null;\n    this.visible = false;\n  };\n  /**\n   * Destroy and don't use after this\n   */\n  FillStyle.prototype.destroy = function () {\n    this.texture = null;\n    this.matrix = null;\n  };\n  return FillStyle;\n}();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildPoly = {\n  build: function (graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var holes = graphicsData.holes;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    if (points.length >= 6) {\n      var holeArray = [];\n      // Process holes..\n      for (var i = 0; i < holes.length; i++) {\n        var hole = holes[i];\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      }\n      // sort color\n      var triangles = earcut(points, holeArray, 2);\n      if (!triangles) {\n        return;\n      }\n      var vertPos = verts.length / 2;\n      for (var i = 0; i < triangles.length; i += 3) {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i + 1] + vertPos);\n        indices.push(triangles[i + 2] + vertPos);\n      }\n      for (var i = 0; i < points.length; i++) {\n        verts.push(points[i]);\n      }\n    }\n  }\n};\n\n// for type only\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildCircle = {\n  build: function (graphicsData) {\n    // need to convert points to a nice regular data\n    var circleData = graphicsData.shape;\n    var points = graphicsData.points;\n    var x = circleData.x;\n    var y = circleData.y;\n    var width;\n    var height;\n    points.length = 0;\n    // TODO - bit hacky??\n    if (graphicsData.type === SHAPES.CIRC) {\n      width = circleData.radius;\n      height = circleData.radius;\n    } else {\n      var ellipseData = graphicsData.shape;\n      width = ellipseData.width;\n      height = ellipseData.height;\n    }\n    if (width === 0 || height === 0) {\n      return;\n    }\n    var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(width + height));\n    totalSegs /= 2.3;\n    var seg = Math.PI * 2 / totalSegs;\n    for (var i = 0; i < totalSegs - 0.5; i++) {\n      points.push(x + Math.sin(-seg * i) * width, y + Math.cos(-seg * i) * height);\n    }\n    points.push(points[0], points[1]);\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vertPos = verts.length / 2;\n    var center = vertPos;\n    var circle = graphicsData.shape;\n    var matrix = graphicsData.matrix;\n    var x = circle.x;\n    var y = circle.y;\n    // Push center (special point)\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    for (var i = 0; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      // add some uvs\n      indices.push(vertPos++, center, vertPos);\n    }\n  }\n};\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildRectangle = {\n  build: function (graphicsData) {\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n    var points = graphicsData.points;\n    points.length = 0;\n    points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1, n2, perc) {\n  var diff = n2 - n1;\n  return n1 + diff * perc;\n}\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {\n  if (out === void 0) {\n    out = [];\n  }\n  var n = 20;\n  var points = out;\n  var xa = 0;\n  var ya = 0;\n  var xb = 0;\n  var yb = 0;\n  var x = 0;\n  var y = 0;\n  for (var i = 0, j = 0; i <= n; ++i) {\n    j = i / n;\n    // The Green Line\n    xa = getPt(fromX, cpX, j);\n    ya = getPt(fromY, cpY, j);\n    xb = getPt(cpX, toX, j);\n    yb = getPt(cpY, toY, j);\n    // The Black Dot\n    x = getPt(xa, xb, j);\n    y = getPt(ya, yb, j);\n    points.push(x, y);\n  }\n  return points;\n}\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nvar buildRoundedRectangle = {\n  build: function (graphicsData) {\n    var rrectData = graphicsData.shape;\n    var points = graphicsData.points;\n    var x = rrectData.x;\n    var y = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height;\n    // Don't allow negative radius or greater than half the smallest width\n    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n    points.length = 0;\n    // No radius, do a simple rectangle\n    if (!radius) {\n      points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n    } else {\n      quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);\n      quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);\n      quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);\n      quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);\n    }\n    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n    // TODO - fix this properly, this is not very elegant.. but it works for now.\n  },\n  triangulate: function (graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vecPos = verts.length / 2;\n    var triangles = earcut(points, null, 2);\n    for (var i = 0, j = triangles.length; i < j; i += 3) {\n      indices.push(triangles[i] + vecPos);\n      //     indices.push(triangles[i] + vecPos);\n      indices.push(triangles[i + 1] + vecPos);\n      //   indices.push(triangles[i + 2] + vecPos);\n      indices.push(triangles[i + 2] + vecPos);\n    }\n    for (var i = 0, j = points.length; i < j; i++) {\n      verts.push(points[i], points[++i]);\n    }\n  }\n};\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {Array<number>} verts - vertex buffer\n * @returns {}\n */\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, /* rotation for square (true at left end, false at right end) */verts) {\n  var ix = x - nx * innerWeight;\n  var iy = y - ny * innerWeight;\n  var ox = x + nx * outerWeight;\n  var oy = y + ny * outerWeight;\n  /* Rotate nx,ny for extension vector */\n  var exx;\n  var eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  /* [i|0]x,y extended at cap */\n  var eix = ix + exx;\n  var eiy = iy + eyy;\n  var eox = ox + exx;\n  var eoy = oy + eyy;\n  /* Square itself must be inserted clockwise*/\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  var cx2p0x = sx - cx;\n  var cy2p0y = sy - cy;\n  var angle0 = Math.atan2(cx2p0x, cy2p0y);\n  var angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  var startAngle = angle0;\n  var angleDiff = angle1 - angle0;\n  var absAngleDiff = Math.abs(angleDiff);\n  /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n  {\n      const r1x = cx - nxtPx;\n      const r1y = cy - nxtPy;\n       if (r1x === 0)\n      {\n          if (r1y > 0)\n          {\n              angleDiff = -angleDiff;\n          }\n      }\n      else if (r1x >= -GRAPHICS_CURVES.epsilon)\n      {\n          angleDiff = -angleDiff;\n      }\n  }*/\n  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  var angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points.slice();\n  var eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  // if the line width is an odd number add 0.5 to align to a whole pixel\n  // commenting this out fixes #711 and #1620\n  // if (graphicsData.lineWidth%2)\n  // {\n  //     for (i = 0; i < points.length; i++)\n  //     {\n  //         points[i] += 0.5;\n  //     }\n  // }\n  var style = graphicsData.lineStyle;\n  // get first and last point.. figure out the middle!\n  var firstPoint = new Point(points[0], points[1]);\n  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  // if the first point is the last point - gonna have issues :)\n  if (closedShape) {\n    // need to clone as we are going to slightly modify the shape..\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  var verts = graphicsGeometry.points;\n  var length = points.length / 2;\n  var indexCount = points.length;\n  var indexStart = verts.length / 2;\n  // Max. inner and outer width\n  var width = style.width / 2;\n  var widthSquared = width * width;\n  var miterLimitSquared = style.miterLimit * style.miterLimit;\n  /* Line segments of interest where (x1,y1) forms the corner. */\n  var x0 = points[0];\n  var y0 = points[1];\n  var x1 = points[2];\n  var y1 = points[3];\n  var x2 = 0;\n  var y2 = 0;\n  /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n  var perpx = -(y0 - y1);\n  var perpy = x0 - x1;\n  var perp1x = 0;\n  var perp1y = 0;\n  var dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  var ratio = style.alignment; // 0.5;\n  var innerWeight = (1 - ratio) * 2;\n  var outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  // Push first point (below & above vertices)\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);\n  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (var i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    /* d[x|y](0|1) = the component displacment between points p(0,1|1,2) */\n    var dx0 = x1 - x0;\n    var dy0 = y0 - y1;\n    var dx1 = x1 - x2;\n    var dy1 = y2 - y1;\n    /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n    var cross = dy0 * dx1 - dy1 * dx0;\n    var clockwise = cross < 0;\n    /* Going nearly straight? */\n    if (Math.abs(cross) < 0.1) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      continue;\n    }\n    /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    var px = (dx0 * c2 - dx1 * c1) / cross;\n    var py = (dy1 * c1 - dy0 * c2) / cross;\n    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    /* Inner miter point */\n    var imx = x1 + (px - x1) * innerWeight;\n    var imy = y1 + (py - y1) * innerWeight;\n    /* Outer miter point */\n    var omx = x1 - (px - x1) * outerWeight;\n    var omy = y1 - (py - y1) * outerWeight;\n    if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {\n      if (clockwise) /* rotating at inner angle */{\n          verts.push(imx, imy); // inner miter point\n          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight); // first segment's outer vertex\n          verts.push(imx, imy); // inner miter point\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight); // second segment's outer vertex\n        } else /* rotating at outer angle */{\n          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight); // first segment's inner vertex\n          verts.push(omx, omy); // outer miter point\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight); // second segment's outer vertex\n          verts.push(omx, omy); // outer miter point\n        }\n      indexCount += 2;\n    } else if (style.join === LINE_JOIN.ROUND) {\n      if (clockwise) /* arc is outside */{\n          verts.push(imx, imy);\n          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else /* arc is inside */{\n          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n    } else {\n      verts.push(imx, imy);\n      verts.push(omx, omy);\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  var indices = graphicsGeometry.indices;\n  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n  // indices.push(indexStart);\n  for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    /* Skip zero area triangles */\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  var i = 0;\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points;\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0) {\n    return;\n  }\n  var verts = graphicsGeometry.points;\n  var indices = graphicsGeometry.indices;\n  var length = points.length / 2;\n  var startIndex = verts.length / 2;\n  var currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\n\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * @class\n * @extends PIXI.Polygon\n * @memberof PIXI.graphicsUtils\n * @param {number} x - Center X position of the star\n * @param {number} y - Center Y position of the star\n * @param {number} points - The number of points of the star, must be > 1\n * @param {number} radius - The outer radius of the star\n * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nvar Star = /** @class */function (_super) {\n  __extends(Star, _super);\n  function Star(x, y, points, radius, innerRadius, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n    var _this = this;\n    innerRadius = innerRadius || radius / 2;\n    var startAngle = -1 * Math.PI / 2 + rotation;\n    var len = points * 2;\n    var delta = PI_2 / len;\n    var polygon = [];\n    for (var i = 0; i < len; i++) {\n      var r = i % 2 ? innerRadius : radius;\n      var angle = i * delta + startAngle;\n      polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n    }\n    _this = _super.call(this, polygon) || this;\n    return _this;\n  }\n  return Star;\n}(Polygon);\n\n/**\n * Utilities for arc curves\n * @class\n * @private\n */\nvar ArcUtils = /** @class */function () {\n  function ArcUtils() {}\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @private\n   * @param {number} x1 - The x-coordinate of the beginning of the arc\n   * @param {number} y1 - The y-coordinate of the beginning of the arc\n   * @param {number} x2 - The x-coordinate of the end of the arc\n   * @param {number} y2 - The y-coordinate of the end of the arc\n   * @param {number} radius - The radius of the arc\n   * @return {object} If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n   */\n  ArcUtils.curveTo = function (x1, y1, x2, y2, radius, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var a1 = fromY - y1;\n    var b1 = fromX - x1;\n    var a2 = y2 - y1;\n    var b2 = x2 - x1;\n    var mm = Math.abs(a1 * b2 - b1 * a2);\n    if (mm < 1.0e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n      return null;\n    }\n    var dd = a1 * a1 + b1 * b1;\n    var cc = a2 * a2 + b2 * b2;\n    var tt = a1 * a2 + b1 * b2;\n    var k1 = radius * Math.sqrt(dd) / mm;\n    var k2 = radius * Math.sqrt(cc) / mm;\n    var j1 = k1 * tt / dd;\n    var j2 = k2 * tt / cc;\n    var cx = k1 * b2 + k2 * b1;\n    var cy = k1 * a2 + k2 * a1;\n    var px = b1 * (k2 + j1);\n    var py = a1 * (k2 + j1);\n    var qx = b2 * (k1 + j2);\n    var qy = a2 * (k1 + j2);\n    var startAngle = Math.atan2(py - cy, px - cx);\n    var endAngle = Math.atan2(qy - cy, qx - cx);\n    return {\n      cx: cx + x1,\n      cy: cy + y1,\n      radius: radius,\n      startAngle: startAngle,\n      endAngle: endAngle,\n      anticlockwise: b1 * a2 > b2 * a1\n    };\n  };\n  /* eslint-disable max-len */\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @private\n   * @param {number} startX - Start x location of arc\n   * @param {number} startY - Start y location of arc\n   * @param {number} cx - The x-coordinate of the center of the circle\n   * @param {number} cy - The y-coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param {number} endAngle - The ending angle, in radians\n   * @param {boolean} anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @param {number[]} points - Collection of points to add to\n   */\n  ArcUtils.arc = function (_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {\n    var sweep = endAngle - startAngle;\n    var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);\n    var theta = sweep / (n * 2);\n    var theta2 = theta * 2;\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    var segMinus = n - 1;\n    var remainder = segMinus % 1 / segMinus;\n    for (var i = 0; i <= segMinus; ++i) {\n      var real = i + remainder * i;\n      var angle = theta + startAngle + theta2 * real;\n      var c = Math.cos(angle);\n      var s = -Math.sin(angle);\n      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n    }\n  };\n  return ArcUtils;\n}();\n\n/**\n * Utilities for bezier curves\n * @class\n * @private\n */\nvar BezierUtils = /** @class */function () {\n  function BezierUtils() {}\n  /**\n   * Calculate length of bezier curve.\n   * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n   * Therefore numerical solution is used.\n   *\n   * @private\n   * @param {number} fromX - Starting point x\n   * @param {number} fromY - Starting point y\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} cpX2 - Second Control point x\n   * @param {number} cpY2 - Second Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {number} Length of bezier curve\n   */\n  BezierUtils.curveLength = function (fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    var n = 10;\n    var result = 0.0;\n    var t = 0.0;\n    var t2 = 0.0;\n    var t3 = 0.0;\n    var nt = 0.0;\n    var nt2 = 0.0;\n    var nt3 = 0.0;\n    var x = 0.0;\n    var y = 0.0;\n    var dx = 0.0;\n    var dy = 0.0;\n    var prevX = fromX;\n    var prevY = fromY;\n    for (var i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1.0 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n    return result;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * Ignored from docs since it is not directly exposed.\n   *\n   * @ignore\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} cpX2 - Second Control point x\n   * @param {number} cpY2 - Second Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @param {number[]} points - Path array to push points into\n   */\n  BezierUtils.curveTo = function (cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    points.length -= 2;\n    var n = GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n    var dt = 0;\n    var dt2 = 0;\n    var dt3 = 0;\n    var t2 = 0;\n    var t3 = 0;\n    points.push(fromX, fromY);\n    for (var i = 1, j = 0; i <= n; ++i) {\n      j = i / n;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  };\n  return BezierUtils;\n}();\n\n/**\n * Utilities for quadratic curves\n * @class\n * @private\n */\nvar QuadraticUtils = /** @class */function () {\n  function QuadraticUtils() {}\n  /**\n   * Calculate length of quadratic curve\n   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n   * for the detailed explanation of math behind this.\n   *\n   * @private\n   * @param {number} fromX - x-coordinate of curve start point\n   * @param {number} fromY - y-coordinate of curve start point\n   * @param {number} cpX - x-coordinate of curve control point\n   * @param {number} cpY - y-coordinate of curve control point\n   * @param {number} toX - x-coordinate of curve end point\n   * @param {number} toY - y-coordinate of curve end point\n   * @return {number} Length of quadratic curve\n   */\n  QuadraticUtils.curveLength = function (fromX, fromY, cpX, cpY, toX, toY) {\n    var ax = fromX - 2.0 * cpX + toX;\n    var ay = fromY - 2.0 * cpY + toY;\n    var bx = 2.0 * cpX - 2.0 * fromX;\n    var by = 2.0 * cpY - 2.0 * fromY;\n    var a = 4.0 * (ax * ax + ay * ay);\n    var b = 4.0 * (ax * bx + ay * by);\n    var c = bx * bx + by * by;\n    var s = 2.0 * Math.sqrt(a + b + c);\n    var a2 = Math.sqrt(a);\n    var a32 = 2.0 * a * a2;\n    var c2 = 2.0 * Math.sqrt(c);\n    var ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @private\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @param {number[]} points - Points to add segments to.\n   */\n  QuadraticUtils.curveTo = function (cpX, cpY, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));\n    var xa = 0;\n    var ya = 0;\n    for (var i = 1; i <= n; ++i) {\n      var j = i / n;\n      xa = fromX + (cpX - fromX) * j;\n      ya = fromY + (cpY - fromY) * j;\n      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n    }\n  };\n  return QuadraticUtils;\n}();\n\n/**\n * A structure to hold interim batch objects for Graphics.\n * @class\n * @memberof PIXI.graphicsUtils\n */\nvar BatchPart = /** @class */function () {\n  function BatchPart() {\n    this.reset();\n  }\n  /**\n   * Begin batch part\n   *\n   * @param {PIXI.FillStyle | PIXI.LineStyle} style\n   * @param {number} startIndex\n   * @param {number} attribStart\n   */\n  BatchPart.prototype.begin = function (style, startIndex, attribStart) {\n    this.reset();\n    this.style = style;\n    this.start = startIndex;\n    this.attribStart = attribStart;\n  };\n  /**\n   * End batch part\n   *\n   * @param {number} endIndex\n   * @param {number} endAttrib\n   */\n  BatchPart.prototype.end = function (endIndex, endAttrib) {\n    this.attribSize = endAttrib - this.attribStart;\n    this.size = endIndex - this.start;\n  };\n  BatchPart.prototype.reset = function () {\n    this.style = null;\n    this.size = 0;\n    this.start = 0;\n    this.attribStart = 0;\n    this.attribSize = 0;\n  };\n  return BatchPart;\n}();\n\n/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace graphicsUtils\n * @memberof PIXI\n */\nvar _a;\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object} FILL_COMMANDS\n */\nvar FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nvar BATCH_POOL = [];\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nvar DRAW_CALL_POOL = [];\nvar index = {\n  buildPoly: buildPoly,\n  buildCircle: buildCircle,\n  buildRectangle: buildRectangle,\n  buildRoundedRectangle: buildRoundedRectangle,\n  FILL_COMMANDS: FILL_COMMANDS,\n  BATCH_POOL: BATCH_POOL,\n  DRAW_CALL_POOL: DRAW_CALL_POOL,\n  buildLine: buildLine,\n  Star: Star,\n  ArcUtils: ArcUtils,\n  BezierUtils: BezierUtils,\n  QuadraticUtils: QuadraticUtils,\n  BatchPart: BatchPart\n};\n\n/**\n * A class to contain data useful for Graphics objects\n *\n * @class\n * @memberof PIXI\n */\nvar GraphicsData = /** @class */function () {\n  /**\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param {PIXI.FillStyle} [fillStyle] - the width of the line to draw\n   * @param {PIXI.LineStyle} [lineStyle] - the color of the line to draw\n   * @param {PIXI.Matrix} [matrix] - Transform matrix\n   */\n  function GraphicsData(shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    /**\n     * The shape object to draw.\n     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n     */\n    this.shape = shape;\n    /**\n     * The style of the line.\n     * @member {PIXI.LineStyle}\n     */\n    this.lineStyle = lineStyle;\n    /**\n     * The style of the fill.\n     * @member {PIXI.FillStyle}\n     */\n    this.fillStyle = fillStyle;\n    /**\n     * The transform matrix.\n     * @member {PIXI.Matrix}\n     */\n    this.matrix = matrix;\n    /**\n     * The type of the shape, see the Const.Shapes file for all the existing types,\n     * @member {number}\n     */\n    this.type = shape.type;\n    /**\n     * The collection of points.\n     * @member {number[]}\n     */\n    this.points = [];\n    /**\n     * The collection of holes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    this.holes = [];\n  }\n  /**\n   * Creates a new GraphicsData object with the same values as this one.\n   *\n   * @return {PIXI.GraphicsData} Cloned GraphicsData object\n   */\n  GraphicsData.prototype.clone = function () {\n    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  };\n  /**\n   * Destroys the Graphics data.\n   *\n   */\n  GraphicsData.prototype.destroy = function () {\n    this.shape = null;\n    this.holes.length = 0;\n    this.holes = null;\n    this.points.length = 0;\n    this.points = null;\n    this.lineStyle = null;\n    this.fillStyle = null;\n  };\n  return GraphicsData;\n}();\nvar tmpPoint = new Point();\nvar tmpBounds = new Bounds();\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @class\n * @extends PIXI.BatchGeometry\n * @memberof PIXI\n */\nvar GraphicsGeometry = /** @class */function (_super) {\n  __extends(GraphicsGeometry, _super);\n  function GraphicsGeometry() {\n    var _this = _super.call(this) || this;\n    _this.uvsFloat32 = null;\n    _this.indicesUint16 = null;\n    /**\n     * An array of points to draw, 2 numbers per point\n     *\n     * @member {number[]}\n     * @protected\n     */\n    _this.points = [];\n    /**\n     * The collection of colors\n     *\n     * @member {number[]}\n     * @protected\n     */\n    _this.colors = [];\n    /**\n     * The UVs collection\n     *\n     * @member {number[]}\n     * @protected\n     */\n    _this.uvs = [];\n    /**\n     * The indices of the vertices\n     *\n     * @member {number[]}\n     * @protected\n     */\n    _this.indices = [];\n    /**\n     * Reference to the texture IDs.\n     *\n     * @member {number[]}\n     * @protected\n     */\n    _this.textureIds = [];\n    /**\n     * The collection of drawn shapes.\n     *\n     * @member {PIXI.GraphicsData[]}\n     * @protected\n     */\n    _this.graphicsData = [];\n    /**\n     * Used to detect if the graphics object has changed.\n     *\n     * @member {number}\n     * @protected\n     */\n    _this.dirty = 0;\n    /**\n     * Batches need to regenerated if the geometry is updated.\n     *\n     * @member {number}\n     * @protected\n     */\n    _this.batchDirty = -1;\n    /**\n     * Used to check if the cache is dirty.\n     *\n     * @member {number}\n     * @protected\n     */\n    _this.cacheDirty = -1;\n    /**\n     * Used to detect if we cleared the graphicsData.\n     *\n     * @member {number}\n     * @default 0\n     * @protected\n     */\n    _this.clearDirty = 0;\n    /**\n     * List of current draw calls drived from the batches.\n     *\n     * @member {object[]}\n     * @protected\n     */\n    _this.drawCalls = [];\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     *\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     * @protected\n     */\n    _this.batches = [];\n    /**\n     * Index of the last batched shape in the stack of calls.\n     *\n     * @member {number}\n     * @protected\n     */\n    _this.shapeIndex = 0;\n    /**\n     * Cached bounds.\n     *\n     * @member {PIXI.Bounds}\n     * @protected\n     */\n    _this._bounds = new Bounds();\n    /**\n     * The bounds dirty flag.\n     *\n     * @member {number}\n     * @protected\n     */\n    _this.boundsDirty = -1;\n    /**\n     * Padding to add to the bounds.\n     *\n     * @member {number}\n     * @default 0\n     */\n    _this.boundsPadding = 0;\n    _this.batchable = false;\n    _this.indicesUint16 = null;\n    _this.uvsFloat32 = null;\n    /**\n     * Minimal distance between points that are considered different.\n     * Affects line tesselation.\n     *\n     * @member {number}\n     */\n    _this.closePointEps = 1e-4;\n    return _this;\n  }\n  Object.defineProperty(GraphicsGeometry.prototype, \"bounds\", {\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    get: function () {\n      if (this.boundsDirty !== this.dirty) {\n        this.boundsDirty = this.dirty;\n        this.calculateBounds();\n      }\n      return this._bounds;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Call if you changed graphicsData manually.\n   * Empties all batch buffers.\n   */\n  GraphicsGeometry.prototype.invalidate = function () {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    for (var i = 0; i < this.batches.length; i++) {\n      var batchPart = this.batches[i];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n    this.batches.length = 0;\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls\n   */\n  GraphicsGeometry.prototype.clear = function () {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.\n   * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.\n   * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n   * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n   */\n  GraphicsGeometry.prototype.drawShape = function (shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n   * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n   */\n  GraphicsGeometry.prototype.drawHole = function (shape, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    if (!this.graphicsData.length) {\n      return null;\n    }\n    var data = new GraphicsData(shape, null, null, matrix);\n    var lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Destroys the GraphicsGeometry object.\n   *\n   */\n  GraphicsGeometry.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    // destroy each of the GraphicsData objects\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  };\n  /**\n   * Check to see if a point is contained within this geometry.\n   *\n   * @param {PIXI.IPointData} point - Point to check if it's contained.\n   * @return {Boolean} `true` if the point is contained within geometry.\n   */\n  GraphicsGeometry.prototype.containsPoint = function (point) {\n    var graphicsData = this.graphicsData;\n    for (var i = 0; i < graphicsData.length; ++i) {\n      var data = graphicsData[i];\n      if (!data.fillStyle.visible) {\n        continue;\n      }\n      // only deal with fills..\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          var hitHole = false;\n          if (data.holes) {\n            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {\n              var hole = data.holes[i_1];\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * Generates intermediate batch data. Either gets converted to drawCalls\n   * or used to convert to batch objects directly by the Graphics object.\n   *\n   * @param {boolean} [aloow32Indices] - Allow using 32-bit indices for preventings artefacts when more that 65535 vertices\n   */\n  GraphicsGeometry.prototype.updateBatches = function (allow32Indices) {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n    if (!this.validateBatching()) {\n      return;\n    }\n    this.cacheDirty = this.dirty;\n    var uvs = this.uvs;\n    var graphicsData = this.graphicsData;\n    var batchPart = null;\n    var currentStyle = null;\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n    for (var i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      var data = graphicsData[i];\n      var fillStyle = data.fillStyle;\n      var lineStyle = data.lineStyle;\n      var command = FILL_COMMANDS[data.type];\n      // build out the shapes points..\n      command.build(data);\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n      for (var j = 0; j < 2; j++) {\n        var style = j === 0 ? fillStyle : lineStyle;\n        if (!style.visible) {\n          continue;\n        }\n        var nextTexture = style.texture.baseTexture;\n        var index_1 = this.indices.length;\n        var attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = WRAP_MODES.REPEAT;\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n        var size = this.points.length / 2 - attribIndex;\n        if (size === 0) {\n          continue;\n        }\n        // close batch if style is different\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index_1, attribIndex);\n          batchPart = null;\n        }\n        // spawn new batch if its first batch or previous was closed\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index_1, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n    var index = this.indices.length;\n    var attrib = this.points.length / 2;\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n    if (this.batches.length === 0) {\n      // there are no visible styles in GraphicsData\n      // its possible that someone wants Graphics just for the bounds\n      this.batchable = true;\n      return;\n    }\n    // prevent allocation when length is same as buffer\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      var need32 = attrib > 0xffff && allow32Indices;\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    }\n    // TODO make this a const..\n    this.batchable = this.isBatchable();\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  };\n  /**\n   * Affinity check\n   *\n   * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n   * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n   */\n  GraphicsGeometry.prototype._compareStyles = function (styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n    return true;\n  };\n  /**\n   * Test geometry for batching process.\n   *\n   * @protected\n   */\n  GraphicsGeometry.prototype.validateBatching = function () {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n    for (var i = 0, l = this.graphicsData.length; i < l; i++) {\n      var data = this.graphicsData[i];\n      var fill = data.fillStyle;\n      var line = data.lineStyle;\n      if (fill && !fill.texture.baseTexture.valid) {\n        return false;\n      }\n      if (line && !line.texture.baseTexture.valid) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Offset the indices so that it works with the batcher.\n   *\n   * @protected\n   */\n  GraphicsGeometry.prototype.packBatches = function () {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    var batches = this.batches;\n    for (var i = 0, l = batches.length; i < l; i++) {\n      var batch = batches[i];\n      for (var j = 0; j < batch.size; j++) {\n        var index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  };\n  /**\n   * Checks to see if this graphics geometry can be batched.\n   * Currently it needs to be small enough and not contain any native lines.\n   *\n   * @protected\n   */\n  GraphicsGeometry.prototype.isBatchable = function () {\n    // prevent heavy mesh batching\n    if (this.points.length > 0xffff * 2) {\n      return false;\n    }\n    var batches = this.batches;\n    for (var i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n    return this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2;\n  };\n  /**\n   * Converts intermediate batches data to drawCalls.\n   *\n   * @protected\n   */\n  GraphicsGeometry.prototype.buildDrawCalls = function () {\n    var TICK = ++BaseTexture._globalBatch;\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n    this.drawCalls.length = 0;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    var currentGroup = DRAW_CALL_POOL.pop();\n    if (!currentGroup) {\n      currentGroup = new BatchDrawCall();\n      currentGroup.texArray = new BatchTextureArray();\n    }\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = DRAW_MODES.TRIANGLES;\n    var textureCount = 0;\n    var currentTexture = null;\n    var textureId = 0;\n    var native = false;\n    var drawMode = DRAW_MODES.TRIANGLES;\n    var index = 0;\n    this.drawCalls.push(currentGroup);\n    // TODO - this can be simplified\n    for (var i = 0; i < this.batches.length; i++) {\n      var data = this.batches[i];\n      // TODO add some full on MAX_TEXTURE CODE..\n      var MAX_TEXTURES = 8;\n      // Forced cast for checking `native` without errors\n      var style = data.style;\n      var nextTexture = style.texture.baseTexture;\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n        // force the batch to break!\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            textureCount = 0;\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n              if (!currentGroup) {\n                currentGroup = new BatchDrawCall();\n                currentGroup.texArray = new BatchTextureArray();\n              }\n              this.drawCalls.push(currentGroup);\n            }\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          }\n          // TODO add this to the render part..\n          // Hack! Because texture has protected `touched`\n          nextTexture.touched = 1; // touch;\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = 10497;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize);\n      this.addTextureIds(textureIds, textureId, data.attribSize);\n    }\n    BaseTexture._globalBatch = TICK;\n    // upload..\n    // merge for now!\n    this.packAttributes();\n  };\n  /**\n   * Packs attributes to single buffer.\n   *\n   * @protected\n   */\n  GraphicsGeometry.prototype.packAttributes = function () {\n    var verts = this.points;\n    var uvs = this.uvs;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n    var glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    var f32 = new Float32Array(glPoints);\n    var u32 = new Uint32Array(glPoints);\n    var p = 0;\n    for (var i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n    this._buffer.update(glPoints);\n    this._indexBuffer.update(this.indicesUint16);\n  };\n  /**\n   * Process fill part of Graphics.\n   *\n   * @param {PIXI.GraphicsData} data\n   * @protected\n   */\n  GraphicsGeometry.prototype.processFill = function (data) {\n    if (data.holes.length) {\n      this.processHoles(data.holes);\n      buildPoly.triangulate(data, this);\n    } else {\n      var command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  };\n  /**\n   * Process line part of Graphics.\n   *\n   * @param {PIXI.GraphicsData} data\n   * @protected\n   */\n  GraphicsGeometry.prototype.processLine = function (data) {\n    buildLine(data, this);\n    for (var i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  };\n  /**\n   * Process the holes data.\n   *\n   * @param {PIXI.GraphicsData[]} holes - Holes to render\n   * @protected\n   */\n  GraphicsGeometry.prototype.processHoles = function (holes) {\n    for (var i = 0; i < holes.length; i++) {\n      var hole = holes[i];\n      var command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  };\n  /**\n   * Update the local bounds of the object. Expensive to use performance-wise.\n   *\n   * @protected\n   */\n  GraphicsGeometry.prototype.calculateBounds = function () {\n    var bounds = this._bounds;\n    var sequenceBounds = tmpBounds;\n    var curMatrix = Matrix.IDENTITY;\n    this._bounds.clear();\n    sequenceBounds.clear();\n    for (var i = 0; i < this.graphicsData.length; i++) {\n      var data = this.graphicsData[i];\n      var shape = data.shape;\n      var type = data.type;\n      var lineStyle = data.lineStyle;\n      var nextMatrix = data.matrix || Matrix.IDENTITY;\n      var lineWidth = 0.0;\n      if (lineStyle && lineStyle.visible) {\n        var alignment = lineStyle.alignment;\n        lineWidth = lineStyle.width;\n        if (type === SHAPES.POLY) {\n          lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\n        } else {\n          lineWidth = lineWidth * Math.max(0, alignment);\n        }\n      }\n      if (curMatrix !== nextMatrix) {\n        if (!sequenceBounds.isEmpty()) {\n          bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n          sequenceBounds.clear();\n        }\n        curMatrix = nextMatrix;\n      }\n      if (type === SHAPES.RECT || type === SHAPES.RREC) {\n        var rect = shape;\n        sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);\n      } else if (type === SHAPES.CIRC) {\n        var circle = shape;\n        sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);\n      } else if (type === SHAPES.ELIP) {\n        var ellipse = shape;\n        sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);\n      } else {\n        var poly = shape;\n        // adding directly to the bounds\n        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);\n      }\n    }\n    if (!sequenceBounds.isEmpty()) {\n      bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n    }\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  };\n  /**\n   * Transform points using matrix.\n   *\n   * @protected\n   * @param {number[]} points - Points to transform\n   * @param {PIXI.Matrix} matrix - Transform matrix\n   */\n  GraphicsGeometry.prototype.transformPoints = function (points, matrix) {\n    for (var i = 0; i < points.length / 2; i++) {\n      var x = points[i * 2];\n      var y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  };\n  /**\n   * Add colors.\n   *\n   * @protected\n   * @param {number[]} colors - List of colors to add to\n   * @param {number} color - Color to add\n   * @param {number} alpha - Alpha to use\n   * @param {number} size - Number of colors to add\n   */\n  GraphicsGeometry.prototype.addColors = function (colors, color, alpha, size) {\n    // TODO use the premultiply bits Ivan added\n    var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n    var rgba = premultiplyTint(rgb, alpha);\n    while (size-- > 0) {\n      colors.push(rgba);\n    }\n  };\n  /**\n   * Add texture id that the shader/fragment wants to use.\n   *\n   * @protected\n   * @param {number[]} textureIds\n   * @param {number} id\n   * @param {number} size\n   */\n  GraphicsGeometry.prototype.addTextureIds = function (textureIds, id, size) {\n    while (size-- > 0) {\n      textureIds.push(id);\n    }\n  };\n  /**\n   * Generates the UVs for a shape.\n   *\n   * @protected\n   * @param {number[]} verts - Vertices\n   * @param {number[]} uvs - UVs\n   * @param {PIXI.Texture} texture - Reference to Texture\n   * @param {number} start - Index buffer start index.\n   * @param {number} size - The size/length for index buffer.\n   * @param {PIXI.Matrix} [matrix] - Optional transform for all points.\n   */\n  GraphicsGeometry.prototype.addUvs = function (verts, uvs, texture, start, size, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    var index = 0;\n    var uvsStart = uvs.length;\n    var frame = texture.frame;\n    while (index < size) {\n      var x = verts[(start + index) * 2];\n      var y = verts[(start + index) * 2 + 1];\n      if (matrix) {\n        var nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n    var baseTexture = texture.baseTexture;\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  };\n  /**\n   * Modify uvs array according to position of texture region\n   * Does not work with rotated or trimmed textures\n   *\n   * @param {number[]} uvs - array\n   * @param {PIXI.Texture} texture - region\n   * @param {number} start - starting index for uvs\n   * @param {number} size - how many points to adjust\n   */\n  GraphicsGeometry.prototype.adjustUvs = function (uvs, texture, start, size) {\n    var baseTexture = texture.baseTexture;\n    var eps = 1e-6;\n    var finish = start + size * 2;\n    var frame = texture.frame;\n    var scaleX = frame.width / baseTexture.width;\n    var scaleY = frame.height / baseTexture.height;\n    var offsetX = frame.x / frame.width;\n    var offsetY = frame.y / frame.height;\n    var minX = Math.floor(uvs[start] + eps);\n    var minY = Math.floor(uvs[start + 1] + eps);\n    for (var i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n    offsetX -= minX;\n    offsetY -= minY;\n    for (var i = start; i < finish; i += 2) {\n      uvs[i] = (uvs[i] + offsetX) * scaleX;\n      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n    }\n  };\n  /**\n   * The maximum number of points to consider an object \"batchable\",\n   * able to be batched by the renderer's batch system.\n   *\n   * @memberof PIXI.GraphicsGeometry\n   * @static\n   * @member {number} BATCHABLE_SIZE\n   * @default 100\n   */\n  GraphicsGeometry.BATCHABLE_SIZE = 100;\n  return GraphicsGeometry;\n}(BatchGeometry);\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n * @class\n * @extends PIXI.FillStyle\n */\nvar LineStyle = /** @class */function (_super) {\n  __extends(LineStyle, _super);\n  function LineStyle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @member {number}\n     * @default 0\n     */\n    _this.width = 0;\n    /**\n     * The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner).\n     *\n     * @member {number}\n     * @default 0.5\n     */\n    _this.alignment = 0.5;\n    /**\n     * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     *\n     * @member {boolean}\n     * @default false\n     */\n    _this.native = false;\n    /**\n     * Line cap style.\n     *\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    _this.cap = LINE_CAP.BUTT;\n    /**\n     * Line join style.\n     *\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    _this.join = LINE_JOIN.MITER;\n    /**\n     * Miter limit.\n     *\n     * @member {number}\n     * @default 10\n     */\n    _this.miterLimit = 10;\n    return _this;\n  }\n  /**\n   * Clones the object\n   *\n   * @return {PIXI.LineStyle}\n   */\n  LineStyle.prototype.clone = function () {\n    var obj = new LineStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    obj.width = this.width;\n    obj.alignment = this.alignment;\n    obj.native = this.native;\n    obj.cap = this.cap;\n    obj.join = this.join;\n    obj.miterLimit = this.miterLimit;\n    return obj;\n  };\n  /**\n   * Reset the line style to default.\n   */\n  LineStyle.prototype.reset = function () {\n    _super.prototype.reset.call(this);\n    // Override default line style color\n    this.color = 0x0;\n    this.alignment = 0.5;\n    this.width = 0;\n    this.native = false;\n  };\n  return LineStyle;\n}(FillStyle);\nvar temp = new Float32Array(3);\n// a default shaders map used by graphics..\nvar DEFAULT_SHADERS = {};\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * Note that because Graphics can share a GraphicsGeometry with other instances,\n * it is necessary to call `destroy()` to properly dereference the underlying\n * GraphicsGeometry and avoid a memory leak. Alternatively, keep using the same\n * Graphics instance and call `clear()` between redraws.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nvar Graphics = /** @class */function (_super) {\n  __extends(Graphics, _super);\n  /**\n   * @param {PIXI.GraphicsGeometry} [geometry=null] - Geometry to use, if omitted\n   *        will create a new GraphicsGeometry instance.\n   */\n  function Graphics(geometry) {\n    if (geometry === void 0) {\n      geometry = null;\n    }\n    var _this = _super.call(this) || this;\n    _this._geometry = geometry || new GraphicsGeometry();\n    _this._geometry.refCount++;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     *\n     * @member {PIXI.Shader}\n     */\n    _this.shader = null;\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     *\n     * @member {PIXI.State}\n     */\n    _this.state = State.for2d();\n    /**\n     * Current fill style\n     *\n     * @member {PIXI.FillStyle}\n     * @protected\n     */\n    _this._fillStyle = new FillStyle();\n    /**\n     * Current line style\n     *\n     * @member {PIXI.LineStyle}\n     * @protected\n     */\n    _this._lineStyle = new LineStyle();\n    /**\n     * Current shape transform matrix.\n     *\n     * @member {PIXI.Matrix}\n     * @protected\n     */\n    _this._matrix = null;\n    /**\n     * Current hole mode is enabled.\n     *\n     * @member {boolean}\n     * @default false\n     * @protected\n     */\n    _this._holeMode = false;\n    /**\n     * Current path\n     *\n     * @member {PIXI.Polygon}\n     * @protected\n     */\n    _this.currentPath = null;\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @name cacheAsBitmap\n     * @member {boolean}\n     * @memberof PIXI.Graphics#\n     * @default false\n     */\n    /**\n     * A collections of batches! These can be drawn by the renderer batch system.\n     *\n     * @protected\n     * @member {object[]}\n     */\n    _this.batches = [];\n    /**\n     * Update dirty for limiting calculating tints for batches.\n     *\n     * @protected\n     * @member {number}\n     * @default -1\n     */\n    _this.batchTint = -1;\n    /**\n     * Update dirty for limiting calculating batches.\n     *\n     * @protected\n     * @member {number}\n     * @default -1\n     */\n    _this.batchDirty = -1;\n    /**\n     * Copy of the object vertex data.\n     *\n     * @protected\n     * @member {Float32Array}\n     */\n    _this.vertexData = null;\n    /**\n     * Renderer plugin for batching\n     *\n     * @member {string}\n     * @default 'batch'\n     */\n    _this.pluginName = 'batch';\n    _this._transformID = -1;\n    // Set default\n    _this.tint = 0xFFFFFF;\n    _this.blendMode = BLEND_MODES.NORMAL;\n    return _this;\n  }\n  Object.defineProperty(Graphics.prototype, \"geometry\", {\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     *\n     * @member {PIXI.GraphicsGeometry}\n     * @readonly\n     */\n    get: function () {\n      return this._geometry;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n   *\n   * @return {PIXI.Graphics} A clone of the graphics object\n   */\n  Graphics.prototype.clone = function () {\n    this.finishPoly();\n    return new Graphics(this._geometry);\n  };\n  Object.defineProperty(Graphics.prototype, \"blendMode\", {\n    get: function () {\n      return this.state.blendMode;\n    },\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n    set: function (value) {\n      this.state.blendMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"tint\", {\n    /**\n     * The tint applied to the graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get: function () {\n      return this._tint;\n    },\n    set: function (value) {\n      this._tint = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"fill\", {\n    /**\n     * The current fill style.\n     *\n     * @member {PIXI.FillStyle}\n     * @readonly\n     */\n    get: function () {\n      return this._fillStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"line\", {\n    /**\n     * The current line style.\n     *\n     * @member {PIXI.LineStyle}\n     * @readonly\n     */\n    get: function () {\n      return this._lineStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n   * method or the drawCircle() method.\n   *\n   * @method PIXI.Graphics#lineStyle\n   * @param {number} [width=0] - width of the line to draw, will update the objects stored style\n   * @param {number} [color=0x0] - color of the line to draw, will update the objects stored style\n   * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n   * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  /**\n   * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n   * method or the drawCircle() method.\n   *\n   * @param {object} [options] - Line style options\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n   * @param {number}[options.miterLimit=10] - miter limit ratio\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.lineStyle = function (options) {\n    if (options === void 0) {\n      options = null;\n    }\n    // Support non-object params: (width, color, alpha, alignment, native)\n    if (typeof options === 'number') {\n      // eslint-disable-next-line\n      var args = arguments;\n      options = {\n        width: args[0] || 0,\n        color: args[1] || 0x0,\n        alpha: args[2] !== undefined ? args[2] : 1,\n        alignment: args[3] !== undefined ? args[3] : 0.5,\n        native: !!args[4]\n      };\n    }\n    return this.lineTextureStyle(options);\n  };\n  /**\n   * Like line style but support texture for line fill.\n   *\n   * @param {object} [options] - Collection of options for setting line style.\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n   * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n   *  Default 0xFFFFFF if texture present.\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n   * @param {number}[options.miterLimit=10] - miter limit ratio\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.lineTextureStyle = function (options) {\n    // backward compatibility with params: (width, texture,\n    // color, alpha, matrix, alignment, native)\n    if (typeof options === 'number') {\n      deprecation('v5.2.0', 'Please use object-based options for Graphics#lineTextureStyle');\n      // eslint-disable-next-line\n      var _a = arguments,\n        width = _a[0],\n        texture = _a[1],\n        color = _a[2],\n        alpha = _a[3],\n        matrix = _a[4],\n        alignment = _a[5],\n        native = _a[6];\n      options = {\n        width: width,\n        texture: texture,\n        color: color,\n        alpha: alpha,\n        matrix: matrix,\n        alignment: alignment,\n        native: native\n      };\n      // Remove undefined keys\n      Object.keys(options).forEach(function (key) {\n        return options[key] === undefined && delete options[key];\n      });\n    }\n    // Apply defaults\n    options = Object.assign({\n      width: 0,\n      texture: Texture.WHITE,\n      color: options && options.texture ? 0xFFFFFF : 0x0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: false,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    }, options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    var visible = options.width > 0 && options.alpha > 0;\n    if (!visible) {\n      this._lineStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._lineStyle, {\n        visible: visible\n      }, options);\n    }\n    return this;\n  };\n  /**\n   * Start a polygon object internally\n   * @protected\n   */\n  Graphics.prototype.startPoly = function () {\n    if (this.currentPath) {\n      var points = this.currentPath.points;\n      var len = this.currentPath.points.length;\n      if (len > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = new Polygon();\n        this.currentPath.closeStroke = false;\n        this.currentPath.points.push(points[len - 2], points[len - 1]);\n      }\n    } else {\n      this.currentPath = new Polygon();\n      this.currentPath.closeStroke = false;\n    }\n  };\n  /**\n   * Finish the polygon object.\n   * @protected\n   */\n  Graphics.prototype.finishPoly = function () {\n    if (this.currentPath) {\n      if (this.currentPath.points.length > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = null;\n      } else {\n        this.currentPath.points.length = 0;\n      }\n    }\n  };\n  /**\n   * Moves the current drawing position to x, y.\n   *\n   * @param {number} x - the X coordinate to move to\n   * @param {number} y - the Y coordinate to move to\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.moveTo = function (x, y) {\n    this.startPoly();\n    this.currentPath.points[0] = x;\n    this.currentPath.points[1] = y;\n    return this;\n  };\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   *\n   * @param {number} x - the X coordinate to draw to\n   * @param {number} y - the Y coordinate to draw to\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.lineTo = function (x, y) {\n    if (!this.currentPath) {\n      this.moveTo(0, 0);\n    }\n    // remove duplicates..\n    var points = this.currentPath.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  };\n  /**\n   * Initialize the curve\n   *\n   * @protected\n   * @param {number} [x=0]\n   * @param {number} [y=0]\n   */\n  Graphics.prototype._initCurve = function (x, y) {\n    if (x === void 0) {\n      x = 0;\n    }\n    if (y === void 0) {\n      y = 0;\n    }\n    if (this.currentPath) {\n      if (this.currentPath.points.length === 0) {\n        this.currentPath.points = [x, y];\n      }\n    } else {\n      this.moveTo(x, y);\n    }\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) {\n    this._initCurve();\n    var points = this.currentPath.points;\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n    return this;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} cpX2 - Second Control point x\n   * @param {number} cpY2 - Second Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._initCurve();\n    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n    return this;\n  };\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @param {number} x1 - The x-coordinate of the first tangent point of the arc\n   * @param {number} y1 - The y-coordinate of the first tangent point of the arc\n   * @param {number} x2 - The x-coordinate of the end of the arc\n   * @param {number} y2 - The y-coordinate of the end of the arc\n   * @param {number} radius - The radius of the arc\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n    var points = this.currentPath.points;\n    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n    if (result) {\n      var cx = result.cx,\n        cy = result.cy,\n        radius_1 = result.radius,\n        startAngle = result.startAngle,\n        endAngle = result.endAngle,\n        anticlockwise = result.anticlockwise;\n      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);\n    }\n    return this;\n  };\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @param {number} cx - The x-coordinate of the center of the circle\n   * @param {number} cy - The y-coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param {number} endAngle - The ending angle, in radians\n   * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise === void 0) {\n      anticlockwise = false;\n    }\n    if (startAngle === endAngle) {\n      return this;\n    }\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += PI_2;\n    }\n    var sweep = endAngle - startAngle;\n    if (sweep === 0) {\n      return this;\n    }\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n    var eps = this._geometry.closePointEps;\n    // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n    var points = this.currentPath ? this.currentPath.points : null;\n    if (points) {\n      // TODO: make a better fix.\n      // We check how far our start is from the last existing point\n      var xDiff = Math.abs(points[points.length - 2] - startX);\n      var yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < eps && yDiff < eps) ;else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.points;\n    }\n    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n    return this;\n  };\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   *\n   * @param {number} [color=0] - the color of the fill\n   * @param {number} [alpha=1] - the alpha of the fill\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.beginFill = function (color, alpha) {\n    if (color === void 0) {\n      color = 0;\n    }\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n    return this.beginTextureFill({\n      texture: Texture.WHITE,\n      color: color,\n      alpha: alpha\n    });\n  };\n  /**\n   * Begin the texture fill\n   *\n   * @param {object} [options] - Object object.\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n   * @param {number} [options.color=0xffffff] - Background to fill behind texture\n   * @param {number} [options.alpha=1] - Alpha of fill\n   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.beginTextureFill = function (options) {\n    // backward compatibility with params: (texture, color, alpha, matrix)\n    if (options instanceof Texture) {\n      deprecation('v5.2.0', 'Please use object-based options for Graphics#beginTextureFill');\n      // eslint-disable-next-line\n      var _a = arguments,\n        texture = _a[0],\n        color = _a[1],\n        alpha = _a[2],\n        matrix = _a[3];\n      options = {\n        texture: texture,\n        color: color,\n        alpha: alpha,\n        matrix: matrix\n      };\n      // Remove undefined keys\n      Object.keys(options).forEach(function (key) {\n        return options[key] === undefined && delete options[key];\n      });\n    }\n    // Apply defaults\n    options = Object.assign({\n      texture: Texture.WHITE,\n      color: 0xFFFFFF,\n      alpha: 1,\n      matrix: null\n    }, options);\n    if (this.currentPath) {\n      this.startPoly();\n    }\n    var visible = options.alpha > 0;\n    if (!visible) {\n      this._fillStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n      Object.assign(this._fillStyle, {\n        visible: visible\n      }, options);\n    }\n    return this;\n  };\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   *\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.endFill = function () {\n    this.finishPoly();\n    this._fillStyle.reset();\n    return this;\n  };\n  /**\n   * Draws a rectangle shape.\n   *\n   * @param {number} x - The X coord of the top-left of the rectangle\n   * @param {number} y - The Y coord of the top-left of the rectangle\n   * @param {number} width - The width of the rectangle\n   * @param {number} height - The height of the rectangle\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawRect = function (x, y, width, height) {\n    return this.drawShape(new Rectangle(x, y, width, height));\n  };\n  /**\n   * Draw a rectangle shape with rounded/beveled corners.\n   *\n   * @param {number} x - The X coord of the top-left of the rectangle\n   * @param {number} y - The Y coord of the top-left of the rectangle\n   * @param {number} width - The width of the rectangle\n   * @param {number} height - The height of the rectangle\n   * @param {number} radius - Radius of the rectangle corners\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawRoundedRect = function (x, y, width, height, radius) {\n    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n  };\n  /**\n   * Draws a circle.\n   *\n   * @param {number} x - The X coordinate of the center of the circle\n   * @param {number} y - The Y coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawCircle = function (x, y, radius) {\n    return this.drawShape(new Circle(x, y, radius));\n  };\n  /**\n   * Draws an ellipse.\n   *\n   * @param {number} x - The X coordinate of the center of the ellipse\n   * @param {number} y - The Y coordinate of the center of the ellipse\n   * @param {number} width - The half width of the ellipse\n   * @param {number} height - The half height of the ellipse\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawEllipse = function (x, y, width, height) {\n    return this.drawShape(new Ellipse(x, y, width, height));\n  };\n  /**\n   * Draws a polygon using the given path.\n   *\n   * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawPolygon = function () {\n    var arguments$1 = arguments;\n    var path = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      path[_i] = arguments$1[_i];\n    }\n    var points;\n    var closeStroke = true; // !!this._fillStyle;\n    var poly = path[0];\n    // check if data has points..\n    if (poly.points) {\n      closeStroke = poly.closeStroke;\n      points = poly.points;\n    } else if (Array.isArray(path[0])) {\n      points = path[0];\n    } else {\n      points = path;\n    }\n    var shape = new Polygon(points);\n    shape.closeStroke = closeStroke;\n    this.drawShape(shape);\n    return this;\n  };\n  /**\n   * Draw any shape.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawShape = function (shape) {\n    if (!this._holeMode) {\n      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n    } else {\n      this._geometry.drawHole(shape, this._matrix);\n    }\n    return this;\n  };\n  /**\n   * Draw a star shape with an arbitrary number of points.\n   *\n   * @param {number} x - Center X position of the star\n   * @param {number} y - Center Y position of the star\n   * @param {number} points - The number of points of the star, must be > 1\n   * @param {number} radius - The outer radius of the star\n   * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n   * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.drawStar = function (x, y, points, radius, innerRadius, rotation) {\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n    return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation));\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n  Graphics.prototype.clear = function () {\n    this._geometry.clear();\n    this._lineStyle.reset();\n    this._fillStyle.reset();\n    this._boundsID++;\n    this._matrix = null;\n    this._holeMode = false;\n    this.currentPath = null;\n    return this;\n  };\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   *\n   * @returns {boolean} True if only 1 rect.\n   */\n  Graphics.prototype.isFastRect = function () {\n    var data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  Graphics.prototype._render = function (renderer) {\n    this.finishPoly();\n    var geometry = this._geometry;\n    var hasuit32 = renderer.context.supports.uint32Indices;\n    // batch part..\n    // batch it!\n    geometry.updateBatches(hasuit32);\n    if (geometry.batchable) {\n      if (this.batchDirty !== geometry.batchDirty) {\n        this._populateBatches();\n      }\n      this._renderBatched(renderer);\n    } else {\n      // no batching...\n      renderer.batch.flush();\n      this._renderDirect(renderer);\n    }\n  };\n  /**\n   * Populating batches for rendering\n   *\n   * @protected\n   */\n  Graphics.prototype._populateBatches = function () {\n    var geometry = this._geometry;\n    var blendMode = this.blendMode;\n    var len = geometry.batches.length;\n    this.batchTint = -1;\n    this._transformID = -1;\n    this.batchDirty = geometry.batchDirty;\n    this.batches.length = len;\n    this.vertexData = new Float32Array(geometry.points);\n    for (var i = 0; i < len; i++) {\n      var gI = geometry.batches[i];\n      var color = gI.style.color;\n      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n      var batch = {\n        vertexData: vertexData,\n        blendMode: blendMode,\n        indices: indices,\n        uvs: uvs,\n        _batchRGB: hex2rgb(color),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  };\n  /**\n   * Renders the batches using the BathedRenderer plugin\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  Graphics.prototype._renderBatched = function (renderer) {\n    if (!this.batches.length) {\n      return;\n    }\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    this.calculateVertices();\n    this.calculateTints();\n    for (var i = 0, l = this.batches.length; i < l; i++) {\n      var batch = this.batches[i];\n      batch.worldAlpha = this.worldAlpha * batch.alpha;\n      renderer.plugins[this.pluginName].render(batch);\n    }\n  };\n  /**\n   * Renders the graphics direct\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  Graphics.prototype._renderDirect = function (renderer) {\n    var shader = this._resolveDirectShader(renderer);\n    var geometry = this._geometry;\n    var tint = this.tint;\n    var worldAlpha = this.worldAlpha;\n    var uniforms = shader.uniforms;\n    var drawCalls = geometry.drawCalls;\n    // lets set the transfomr\n    uniforms.translationMatrix = this.transform.worldTransform;\n    // and then lets set the tint..\n    uniforms.tint[0] = (tint >> 16 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[1] = (tint >> 8 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[2] = (tint & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[3] = worldAlpha;\n    // the first draw call, we can set the uniforms of the shader directly here.\n    // this means that we can tack advantage of the sync function of pixi!\n    // bind and sync uniforms..\n    // there is a way to optimise this..\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader);\n    // set state..\n    renderer.state.set(this.state);\n    // then render the rest of them...\n    for (var i = 0, l = drawCalls.length; i < l; i++) {\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n    }\n  };\n  /**\n   * Renders specific DrawCall\n   *\n   * @param {PIXI.Renderer} renderer\n   * @param {PIXI.BatchDrawCall} drawCall\n   */\n  Graphics.prototype._renderDrawCallDirect = function (renderer, drawCall) {\n    var texArray = drawCall.texArray,\n      type = drawCall.type,\n      size = drawCall.size,\n      start = drawCall.start;\n    var groupTextureCount = texArray.count;\n    for (var j = 0; j < groupTextureCount; j++) {\n      renderer.texture.bind(texArray.elements[j], j);\n    }\n    renderer.geometry.draw(type, size, start);\n  };\n  /**\n   * Resolves shader for direct rendering\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  Graphics.prototype._resolveDirectShader = function (renderer) {\n    var shader = this.shader;\n    var pluginName = this.pluginName;\n    if (!shader) {\n      // if there is no shader here, we can use the default shader.\n      // and that only gets created if we actually need it..\n      // but may be more than one plugins for graphics\n      if (!DEFAULT_SHADERS[pluginName]) {\n        var sampleValues = new Int32Array(16);\n        for (var i = 0; i < 16; i++) {\n          sampleValues[i] = i;\n        }\n        var uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({\n            uSamplers: sampleValues\n          }, true)\n        };\n        var program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n      }\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n    return shader;\n  };\n  /**\n   * Retrieves the bounds of the graphic shape as a rectangle object\n   *\n   * @protected\n   */\n  Graphics.prototype._calculateBounds = function () {\n    this.finishPoly();\n    var geometry = this._geometry;\n    // skipping when graphics is empty, like a container\n    if (!geometry.graphicsData.length) {\n      return;\n    }\n    var _a = geometry.bounds,\n      minX = _a.minX,\n      minY = _a.minY,\n      maxX = _a.maxX,\n      maxY = _a.maxY;\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Tests if a point is inside this graphics object\n   *\n   * @param {PIXI.IPointData} point - the point to test\n   * @return {boolean} the result of the test\n   */\n  Graphics.prototype.containsPoint = function (point) {\n    this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n    return this._geometry.containsPoint(Graphics._TEMP_POINT);\n  };\n  /**\n   * Recalcuate the tint by applying tin to batches using Graphics tint.\n   * @protected\n   */\n  Graphics.prototype.calculateTints = function () {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      var tintRGB = hex2rgb(this.tint, temp);\n      for (var i = 0; i < this.batches.length; i++) {\n        var batch = this.batches[i];\n        var batchTint = batch._batchRGB;\n        var r = tintRGB[0] * batchTint[0] * 255;\n        var g = tintRGB[1] * batchTint[1] * 255;\n        var b = tintRGB[2] * batchTint[2] * 255;\n        // TODO Ivan, can this be done in one go?\n        var color = (r << 16) + (g << 8) + (b | 0);\n        batch._tintRGB = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n      }\n    }\n  };\n  /**\n   * If there's a transform update or a change to the shape of the\n   * geometry, recaculate the vertices.\n   * @protected\n   */\n  Graphics.prototype.calculateVertices = function () {\n    var wtID = this.transform._worldID;\n    if (this._transformID === wtID) {\n      return;\n    }\n    this._transformID = wtID;\n    var wt = this.transform.worldTransform;\n    var a = wt.a;\n    var b = wt.b;\n    var c = wt.c;\n    var d = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var data = this._geometry.points; // batch.vertexDataOriginal;\n    var vertexData = this.vertexData;\n    var count = 0;\n    for (var i = 0; i < data.length; i += 2) {\n      var x = data[i];\n      var y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx;\n      vertexData[count++] = d * y + b * x + ty;\n    }\n  };\n  /**\n   * Closes the current path.\n   *\n   * @return {PIXI.Graphics} Returns itself.\n   */\n  Graphics.prototype.closePath = function () {\n    var currentPath = this.currentPath;\n    if (currentPath) {\n      // we don't need to add extra point in the end because buildLine will take care of that\n      currentPath.closeStroke = true;\n    }\n    return this;\n  };\n  /**\n   * Apply a matrix to the positional data.\n   *\n   * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.\n   * @return {PIXI.Graphics} Returns itself.\n   */\n  Graphics.prototype.setMatrix = function (matrix) {\n    this._matrix = matrix;\n    return this;\n  };\n  /**\n   * Begin adding holes to the last draw shape\n   * IMPORTANT: holes must be fully inside a shape to work\n   * Also weirdness ensues if holes overlap!\n   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n   * @return {PIXI.Graphics} Returns itself.\n   */\n  Graphics.prototype.beginHole = function () {\n    this.finishPoly();\n    this._holeMode = true;\n    return this;\n  };\n  /**\n   * End adding holes to the last draw shape\n   * @return {PIXI.Graphics} Returns itself.\n   */\n  Graphics.prototype.endHole = function () {\n    this.finishPoly();\n    this._holeMode = false;\n    return this;\n  };\n  /**\n   * Destroys the Graphics object.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  Graphics.prototype.destroy = function (options) {\n    _super.prototype.destroy.call(this, options);\n    this._geometry.refCount--;\n    if (this._geometry.refCount === 0) {\n      this._geometry.dispose();\n    }\n    this._matrix = null;\n    this.currentPath = null;\n    this._lineStyle.destroy();\n    this._lineStyle = null;\n    this._fillStyle.destroy();\n    this._fillStyle = null;\n    this._geometry = null;\n    this.shader = null;\n    this.vertexData = null;\n    this.batches.length = 0;\n    this.batches = null;\n    _super.prototype.destroy.call(this, options);\n  };\n  /**\n   * Temporary point to use for containsPoint\n   *\n   * @static\n   * @private\n   * @member {PIXI.Point}\n   */\n  Graphics._TEMP_POINT = new Point();\n  return Graphics;\n}(Container);\nexport { FillStyle, GRAPHICS_CURVES, Graphics, GraphicsData, GraphicsGeometry, LINE_CAP, LINE_JOIN, LineStyle, index as graphicsUtils };","map":{"version":3,"names":["LINE_JOIN","LINE_CAP","GRAPHICS_CURVES","adaptive","maxLength","minSegments","maxSegments","epsilon","_segmentsCount","length","defaultSegments","isNaN","result","Math","ceil","FillStyle","color","alpha","texture","Texture","WHITE","matrix","visible","reset","prototype","clone","obj","destroy","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","create","buildPoly","build","graphicsData","points","shape","slice","triangulate","graphicsGeometry","holes","verts","indices","holeArray","i","hole","push","concat","triangles","earcut","vertPos","buildCircle","circleData","x","y","width","height","type","SHAPES","CIRC","radius","ellipseData","totalSegs","floor","sqrt","seg","PI","sin","cos","center","circle","a","c","tx","ty","buildRectangle","rectData","getPt","n1","n2","perc","diff","quadraticBezierCurve","fromX","fromY","cpX","cpY","toX","toY","out","n","xa","ya","xb","yb","j","buildRoundedRectangle","rrectData","max","min","vecPos","square","nx","ny","innerWeight","outerWeight","clockwise","ix","iy","ox","oy","exx","eyy","eix","eiy","eox","eoy","round","cx","cy","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","atan2","angle1","startAngle","angleDiff","absAngleDiff","abs","segCount","angleInc","angle","buildNonNativeLine","eps","closePointEps","style","lineStyle","firstPoint","Point","lastPoint","closedShape","POLY","closeStroke","closedPath","pop","set","midPointX","midPointY","unshift","indexCount","indexStart","widthSquared","miterLimitSquared","miterLimit","x0","y0","x1","y1","x2","y2","perpx","perpy","perp1x","perp1y","dist","ratio","alignment","cap","ROUND","SQUARE","dx0","dy0","dx1","dy1","cross","c1","c2","px","py","pdist","imx","imy","omx","omy","join","BEVEL","eps2","buildNativeLine","startIndex","currentIndex","buildLine","native","Star","_super","innerRadius","rotation","_this","len","delta","PI_2","polygon","r","call","Polygon","ArcUtils","curveTo","a1","b1","a2","b2","mm","dd","cc","tt","k1","k2","j1","j2","qx","qy","endAngle","anticlockwise","arc","_startX","_startY","_anticlockwise","sweep","theta","theta2","cTheta","sTheta","segMinus","remainder","real","s","BezierUtils","curveLength","cpX2","cpY2","t","t2","t3","nt","nt2","nt3","dx","dy","prevX","prevY","dt","dt2","dt3","QuadraticUtils","ax","ay","bx","by","a32","ba","log","BatchPart","begin","attribStart","start","end","endIndex","endAttrib","attribSize","size","FILL_COMMANDS","_a","ELIP","RECT","RREC","BATCH_POOL","DRAW_CALL_POOL","GraphicsData","fillStyle","tmpPoint","tmpBounds","Bounds","GraphicsGeometry","uvsFloat32","indicesUint16","colors","uvs","textureIds","dirty","batchDirty","cacheDirty","clearDirty","drawCalls","batches","shapeIndex","_bounds","boundsDirty","boundsPadding","batchable","defineProperty","get","calculateBounds","invalidate","texArray","clear","batchPart","drawShape","data","drawHole","lastShape","indexBuffer","containsPoint","point","applyInverse","copyFrom","contains","hitHole","i_1","updateBatches","allow32Indices","validateBatching","currentStyle","command","transformPoints","nextTexture","baseTexture","index_1","attribIndex","wrapMode","WRAP_MODES","REPEAT","processFill","processLine","_compareStyles","addUvs","index","attrib","need32","Uint32Array","Uint16Array","isBatchable","packBatches","buildDrawCalls","styleA","styleB","l","fill","line","valid","Float32Array","batch","BATCHABLE_SIZE","TICK","BaseTexture","_globalBatch","currentGroup","BatchDrawCall","BatchTextureArray","count","DRAW_MODES","TRIANGLES","textureCount","currentTexture","textureId","drawMode","MAX_TEXTURES","LINES","_batchEnabled","touched","_batchLocation","elements","addColors","addTextureIds","packAttributes","glPoints","ArrayBuffer","f32","u32","_buffer","update","_indexBuffer","processHoles","bounds","sequenceBounds","curMatrix","Matrix","IDENTITY","nextMatrix","lineWidth","isEmpty","addBoundsMatrix","rect","addFramePad","ellipse","poly","addVerticesMatrix","pad","rgb","rgba","premultiplyTint","id","uvsStart","frame","adjustUvs","finish","scaleX","scaleY","offsetX","offsetY","minX","minY","BatchGeometry","LineStyle","apply","arguments","BUTT","MITER","temp","DEFAULT_SHADERS","Graphics","geometry","_geometry","refCount","shader","state","State","for2d","_fillStyle","_lineStyle","_matrix","_holeMode","currentPath","batchTint","vertexData","pluginName","_transformID","tint","blendMode","BLEND_MODES","NORMAL","finishPoly","value","_tint","options","args","undefined","lineTextureStyle","deprecation","keys","forEach","key","assign","startPoly","invert","moveTo","lineTo","_initCurve","quadraticCurveTo","bezierCurveTo","arcTo","radius_1","startX","startY","xDiff","yDiff","beginFill","beginTextureFill","endFill","drawRect","Rectangle","drawRoundedRect","RoundedRectangle","drawCircle","Circle","drawEllipse","Ellipse","drawPolygon","path","_i","arguments$1","isArray","drawStar","_boundsID","isFastRect","_render","renderer","hasuit32","context","supports","uint32Indices","_populateBatches","_renderBatched","flush","_renderDirect","gI","buffer","_batchRGB","hex2rgb","_tintRGB","_texture","worldAlpha","setObjectRenderer","plugins","calculateVertices","calculateTints","render","_resolveDirectShader","uniforms","translationMatrix","transform","worldTransform","bind","_renderDrawCallDirect","drawCall","groupTextureCount","draw","sampleValues","Int32Array","default","UniformGroup","from","uSamplers","program","_shader","Shader","_calculateBounds","maxX","maxY","addFrame","_TEMP_POINT","tintRGB","g","wtID","_worldID","wt","closePath","setMatrix","beginHole","endHole","dispose","Container"],"sources":["/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/const.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/styles/FillStyle.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/node_modules/tslib/tslib.es6.js","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/buildPoly.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/buildCircle.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/buildRectangle.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/buildRoundedRectangle.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/buildLine.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/Star.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/ArcUtils.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/BezierUtils.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/QuadraticUtils.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/BatchPart.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/utils/index.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/GraphicsData.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/GraphicsGeometry.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/styles/LineStyle.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/graphics/src/Graphics.ts"],"sourcesContent":["/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n *\n * @name LINE_JOIN\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n * @property {string} ROUND - 'round': add an arc at the joint\n */\nexport enum LINE_JOIN {\n    MITER = 'miter',\n    BEVEL = 'bevel',\n    ROUND = 'round'\n}\n\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n *\n * @name LINE_CAP\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\n * @property {string} ROUND - 'round': add semicircle at ends\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\n */\nexport enum LINE_CAP {\n    BUTT = 'butt',\n    ROUND = 'round',\n    SQUARE = 'square'\n}\n\nexport interface IGraphicsCurvesSettings {\n    adaptive: boolean;\n    maxLength: number;\n    minSegments: number;\n    maxSegments: number;\n\n    epsilon: number;\n\n    _segmentsCount(length: number, defaultSegments?: number): number;\n}\n\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nexport const GRAPHICS_CURVES: IGraphicsCurvesSettings = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments:  2048,\n\n    epsilon: 0.0001,\n\n    _segmentsCount(length: number, defaultSegments = 20)\n    {\n        if (!this.adaptive || !length || isNaN(length))\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n","import { Texture } from '@pixi/core';\nimport type { Matrix } from '@pixi/math';\n\n/**\n * Fill style object for Graphics.\n *\n * @class\n * @memberof PIXI\n */\nexport class FillStyle\n{\n    /**\n     * The hex color value used when coloring the Graphics object.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    public color = 0xFFFFFF;\n\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @member {number}\n     * @default 1\n     */\n    public alpha = 1.0;\n\n    /**\n     * The texture to be used for the fill.\n     *\n     * @member {PIXI.Texture}\n     * @default 0\n     */\n    public texture: Texture = Texture.WHITE;\n\n    /**\n     * The transform aplpied to the texture.\n     *\n     * @member {PIXI.Matrix}\n     * @default null\n     */\n    public matrix: Matrix = null;\n\n    /**\n     * If the current fill is visible.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    public visible = false;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.FillStyle}\n     */\n    public clone(): FillStyle\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /**\n     * Reset\n     */\n    public reset(): void\n    {\n        this.color = 0xFFFFFF;\n        this.alpha = 1;\n        this.texture = Texture.WHITE;\n        this.matrix = null;\n        this.visible = false;\n    }\n\n    /**\n     * Destroy and don't use after this\n     */\n    public destroy(): void\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { earcut } from '@pixi/utils';\n\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Polygon } from '@pixi/math';\n\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = (graphicsData.shape as Polygon).points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n","// for type only\nimport { SHAPES } from '@pixi/math';\n\nimport type { Circle, Ellipse } from '@pixi/math';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const circleData = graphicsData.shape as Circle;\n        const points = graphicsData.points;\n        const x = circleData.x;\n        const y = circleData.y;\n        let width;\n        let height;\n\n        points.length = 0;\n\n        // TODO - bit hacky??\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            width = circleData.radius;\n            height = circleData.radius;\n        }\n        else\n        {\n            const ellipseData = graphicsData.shape as Ellipse;\n\n            width = ellipseData.width;\n            height = ellipseData.height;\n        }\n\n        if (width === 0 || height === 0)\n        {\n            return;\n        }\n\n        let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\n            || Math.floor(15 * Math.sqrt(width + height));\n\n        totalSegs /= 2.3;\n\n        const seg = (Math.PI * 2) / totalSegs;\n\n        for (let i = 0; i < totalSegs - 0.5; i++)\n        {\n            points.push(\n                x + (Math.sin(-seg * i) * width),\n                y + (Math.cos(-seg * i) * height)\n            );\n        }\n\n        points.push(points[0], points[1]);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        const circle = (graphicsData.shape) as Circle;\n        const matrix = graphicsData.matrix;\n        const x = circle.x;\n        const y = circle.y;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n    },\n};\n","import type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Rectangle } from '@pixi/math';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape as Rectangle;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n","import { earcut } from '@pixi/utils';\n\n// for type only\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { RoundedRectangle } from '@pixi/math';\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1: number, n2: number, perc: number): number\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(\n    fromX: number, fromY: number,\n    cpX: number, cpY: number,\n    toX: number, toY: number,\n    out: Array<number> = []): Array<number>\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRoundedRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        const rrectData = graphicsData.shape as RoundedRectangle;\n        const points = graphicsData.points;\n        const x = rrectData.x;\n        const y = rrectData.y;\n        const width = rrectData.width;\n        const height = rrectData.height;\n\n        // Don't allow negative radius or greater than half the smallest width\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n\n        points.length = 0;\n\n        // No radius, do a simple rectangle\n        if (!radius)\n        {\n            points.push(x, y,\n                x + width, y,\n                x + width, y + height,\n                x, y + height);\n        }\n        else\n        {\n            quadraticBezierCurve(x, y + radius,\n                x, y,\n                x + radius, y,\n                points);\n            quadraticBezierCurve(x + width - radius,\n                y, x + width, y,\n                x + width, y + radius,\n                points);\n            quadraticBezierCurve(x + width, y + height - radius,\n                x + width, y + height,\n                x + width - radius, y + height,\n                points);\n            quadraticBezierCurve(x + radius, y + height,\n                x, y + height,\n                x, y + height - radius,\n                points);\n        }\n\n        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n        // TODO - fix this properly, this is not very elegant.. but it works for now.\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        const vecPos = verts.length / 2;\n\n        const triangles = earcut(points, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            //     indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            //   indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = points.length; i < j; i++)\n        {\n            verts.push(points[i], points[++i]);\n        }\n    },\n};\n","import { Point, SHAPES } from '@pixi/math';\n\nimport type { Polygon } from '@pixi/math';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\nimport { LINE_JOIN, LINE_CAP } from '../const';\nimport { GRAPHICS_CURVES } from '../const';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {Array<number>} verts - vertex buffer\n * @returns {}\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -GRAPHICS_CURVES.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight),\n        y0 - (perpy * innerWeight));\n    verts.push(\n        x0 + (perpx * outerWeight),\n        y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacment between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly straight? */\n        if (Math.abs(cross) < 0.1)\n        {\n            verts.push(\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight));\n            verts.push(\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight));\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n        {\n            if (clockwise) /* rotating at inner angle */\n            {\n                verts.push(imx, imy);// inner miter point\n                verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));// first segment's outer vertex\n                verts.push(imx, imy);// inner miter point\n                verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));// second segment's outer vertex\n            }\n            else /* rotating at outer angle */\n            {\n                verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));// first segment's inner vertex\n                verts.push(omx, omy);// outer miter point\n                verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));// second segment's outer vertex\n                verts.push(omx, omy);// outer miter point\n            }\n\n            indexCount += 2;\n        }\n        else if (style.join === LINE_JOIN.ROUND)\n        {\n            if (clockwise) /* arc is outside */\n            {\n                verts.push(imx, imy);\n                verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                indexCount += round(\n                    x1, y1,\n                    x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                    x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                    verts, true\n                ) + 4;\n\n                verts.push(imx, imy);\n                verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n            }\n            else /* arc is inside */\n            {\n                verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n                verts.push(omx, omy);\n\n                indexCount += round(\n                    x1, y1,\n                    x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                    x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                    verts, false\n                ) + 4;\n\n                verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                verts.push(omx, omy);\n            }\n        }\n        else\n        {\n            verts.push(imx, imy);\n            verts.push(omx, omy);\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n","import { Polygon, PI_2 } from '@pixi/math';\n\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * @class\n * @extends PIXI.Polygon\n * @memberof PIXI.graphicsUtils\n * @param {number} x - Center X position of the star\n * @param {number} y - Center Y position of the star\n * @param {number} points - The number of points of the star, must be > 1\n * @param {number} radius - The outer radius of the star\n * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport class Star extends Polygon\n{\n    constructor(x: number, y: number, points: number, radius: number, innerRadius: number, rotation = 0)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\nimport { PI_2 } from '@pixi/math';\n\ninterface IArcLikeShape {\n    cx: number;\n    cy: number;\n    radius: number;\n    startAngle: number;\n    endAngle: number;\n    anticlockwise: boolean;\n}\n\n/**\n * Utilities for arc curves\n * @class\n * @private\n */\nexport class ArcUtils\n{\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @private\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {object} If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1: number, y1: number, x2: number, y2: number, radius: number, points: Array<number>): IArcLikeShape\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /* eslint-disable max-len */\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @private\n     * @param {number} startX - Start x location of arc\n     * @param {number} startY - Start y location of arc\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param {number[]} points - Collection of points to add to\n     */\n    static arc(_startX: number, _startY: number, cx: number, cy: number, radius: number,\n        startAngle: number, endAngle: number, _anticlockwise: boolean, points: Array<number>): void\n    {\n        const sweep = endAngle - startAngle;\n        const n = GRAPHICS_CURVES._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n    /* eslint-enable max-len */\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for bezier curves\n * @class\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     *\n     * @private\n     * @param {number} fromX - Starting point x\n     * @param {number} fromY - Starting point y\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {number} Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     *\n     * @ignore\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for quadratic curves\n * @class\n * @private\n */\nexport class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     *\n     * @private\n     * @param {number} fromX - x-coordinate of curve start point\n     * @param {number} fromY - y-coordinate of curve start point\n     * @param {number} cpX - x-coordinate of curve control point\n     * @param {number} cpY - y-coordinate of curve control point\n     * @param {number} toX - x-coordinate of curve end point\n     * @param {number} toY - y-coordinate of curve end point\n     * @return {number} Length of quadratic curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        toX: number, toY: number): number\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @private\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @param {number[]} points - Points to add segments to.\n     */\n    static curveTo(cpX: number, cpY: number, toX: number, toY: number, points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n","import type { LineStyle } from '../styles/LineStyle';\nimport type { FillStyle } from '../styles/FillStyle';\n\n/**\n * A structure to hold interim batch objects for Graphics.\n * @class\n * @memberof PIXI.graphicsUtils\n */\nexport class BatchPart\n{\n    public style: LineStyle | FillStyle;\n    public start: number;\n    public size: number;\n    public attribStart: number;\n    public attribSize: number;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /**\n     * Begin batch part\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} style\n     * @param {number} startIndex\n     * @param {number} attribStart\n     */\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n    }\n\n    /**\n     * End batch part\n     *\n     * @param {number} endIndex\n     * @param {number} endAttrib\n     */\n    public end(endIndex: number, endAttrib: number): void\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    public reset(): void\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n","/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace graphicsUtils\n * @memberof PIXI\n */\n\nimport { buildPoly } from './buildPoly';\nexport { buildPoly };\n\nimport { buildCircle } from './buildCircle';\nexport { buildCircle };\n\nimport { buildRectangle } from './buildRectangle';\nexport { buildRectangle };\n\nimport { buildRoundedRectangle } from './buildRoundedRectangle';\nexport { buildRoundedRectangle };\n\nexport * from './buildLine';\nexport * from './Star';\nexport * from './ArcUtils';\nexport * from './BezierUtils';\nexport * from './QuadraticUtils';\nexport * from './BatchPart';\n\n// for type only\nimport { BatchPart } from './BatchPart';\nimport { SHAPES } from '@pixi/math';\nimport { BatchDrawCall } from '@pixi/core';\nimport { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object} FILL_COMMANDS\n */\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuildCommand> = {\n    [SHAPES.POLY]: buildPoly,\n    [SHAPES.CIRC]: buildCircle,\n    [SHAPES.ELIP]: buildCircle,\n    [SHAPES.RECT]: buildRectangle,\n    [SHAPES.RREC]: buildRoundedRectangle,\n};\n\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nexport const BATCH_POOL: Array<BatchPart> = [];\n\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n","import type { Matrix, SHAPES, IShape } from '@pixi/math';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/**\n * A class to contain data useful for Graphics objects\n *\n * @class\n * @memberof PIXI\n */\nexport class GraphicsData\n{\n    shape: IShape;\n    lineStyle: LineStyle;\n    fillStyle: FillStyle;\n    matrix: Matrix;\n    type: SHAPES;\n    points: number[];\n    holes: Array<GraphicsData>;\n    /**\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} [fillStyle] - the width of the line to draw\n     * @param {PIXI.LineStyle} [lineStyle] - the color of the line to draw\n     * @param {PIXI.Matrix} [matrix] - Transform matrix\n     */\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\n    {\n        /**\n         * The shape object to draw.\n         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n         */\n        this.shape = shape;\n\n        /**\n         * The style of the line.\n         * @member {PIXI.LineStyle}\n         */\n        this.lineStyle = lineStyle;\n\n        /**\n         * The style of the fill.\n         * @member {PIXI.FillStyle}\n         */\n        this.fillStyle = fillStyle;\n\n        /**\n         * The transform matrix.\n         * @member {PIXI.Matrix}\n         */\n        this.matrix = matrix;\n\n        /**\n         * The type of the shape, see the Const.Shapes file for all the existing types,\n         * @member {number}\n         */\n        this.type = shape.type;\n\n        /**\n         * The collection of points.\n         * @member {number[]}\n         */\n        this.points = [];\n\n        /**\n         * The collection of holes.\n         * @member {PIXI.GraphicsData[]}\n         */\n        this.holes = [];\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     *\n     * @return {PIXI.GraphicsData} Cloned GraphicsData object\n     */\n    public clone(): GraphicsData\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /**\n     * Destroys the Graphics data.\n     *\n     */\n    public destroy(): void\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n","import {\n    buildLine,\n    buildPoly,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL,\n} from './utils';\n\nimport {\n    BatchGeometry,\n    BatchDrawCall,\n    BatchTextureArray,\n    BaseTexture,\n    Texture,\n} from '@pixi/core';\n\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\nimport { SHAPES, Point, Matrix } from '@pixi/math';\nimport { GraphicsData } from './GraphicsData';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Bounds } from '@pixi/display';\n\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData } from '@pixi/math';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/**\n * @description Complex shape type\n * @todo Move to Math shapes\n */\ntype IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @class\n * @extends PIXI.BatchGeometry\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /**\n     * The maximum number of points to consider an object \"batchable\",\n     * able to be batched by the renderer's batch system.\n     *\n     * @memberof PIXI.GraphicsGeometry\n     * @static\n     * @member {number} BATCHABLE_SIZE\n     * @default 100\n     */\n    public static BATCHABLE_SIZE = 100;\n\n    public closePointEps: number;\n    public boundsPadding: number;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable: boolean;\n    points: Array<number>;\n    colors: Array<number>;\n    uvs: Array<number>;\n    indices: Array<number>;\n    textureIds: Array<number>;\n    graphicsData: Array<GraphicsData>;\n    drawCalls: Array<BatchDrawCall>;\n    batchDirty: number;\n    batches: Array<BatchPart>;\n\n    protected dirty: number;\n    protected cacheDirty: number;\n    protected clearDirty: number;\n    protected shapeIndex: number;\n    protected _bounds: Bounds;\n    protected boundsDirty: number;\n\n    constructor()\n    {\n        super();\n\n        /**\n         * An array of points to draw, 2 numbers per point\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.points = [];\n\n        /**\n         * The collection of colors\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.colors = [];\n\n        /**\n         * The UVs collection\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.uvs = [];\n\n        /**\n         * The indices of the vertices\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.indices = [];\n\n        /**\n         * Reference to the texture IDs.\n         *\n         * @member {number[]}\n         * @protected\n         */\n        this.textureIds = [];\n\n        /**\n         * The collection of drawn shapes.\n         *\n         * @member {PIXI.GraphicsData[]}\n         * @protected\n         */\n        this.graphicsData = [];\n\n        /**\n         * Used to detect if the graphics object has changed.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.dirty = 0;\n\n        /**\n         * Batches need to regenerated if the geometry is updated.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.batchDirty = -1;\n\n        /**\n         * Used to check if the cache is dirty.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.cacheDirty = -1;\n\n        /**\n         * Used to detect if we cleared the graphicsData.\n         *\n         * @member {number}\n         * @default 0\n         * @protected\n         */\n        this.clearDirty = 0;\n\n        /**\n         * List of current draw calls drived from the batches.\n         *\n         * @member {object[]}\n         * @protected\n         */\n        this.drawCalls = [];\n\n        /**\n         * Intermediate abstract format sent to batch system.\n         * Can be converted to drawCalls or to batchable objects.\n         *\n         * @member {PIXI.graphicsUtils.BatchPart[]}\n         * @protected\n         */\n        this.batches = [];\n\n        /**\n         * Index of the last batched shape in the stack of calls.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.shapeIndex = 0;\n\n        /**\n         * Cached bounds.\n         *\n         * @member {PIXI.Bounds}\n         * @protected\n         */\n        this._bounds = new Bounds();\n\n        /**\n         * The bounds dirty flag.\n         *\n         * @member {number}\n         * @protected\n         */\n        this.boundsDirty = -1;\n\n        /**\n         * Padding to add to the bounds.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.boundsPadding = 0;\n\n        this.batchable = false;\n\n        this.indicesUint16 = null;\n\n        this.uvsFloat32 = null;\n\n        /**\n         * Minimal distance between points that are considered different.\n         * Affects line tesselation.\n         *\n         * @member {number}\n         */\n        this.closePointEps = 1e-4;\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.\n     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.\n     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Destroys the GraphicsGeometry object.\n     *\n     */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.IPointData} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     *\n     * @param {boolean} [aloow32Indices] - Allow using 32-bit indices for preventings artefacts when more that 65535 vertices\n     */\n    updateBatches(allow32Indices?: boolean): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length)\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            const need32\n                = attrib > 0xffff && allow32Indices;\n\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Test geometry for batching process.\n     *\n     * @protected\n     */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Offset the indices so that it works with the batcher.\n     *\n     * @protected\n     */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     *\n     * @protected\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     *\n     * @protected\n     */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall =  DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = 10497;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize);\n            this.addTextureIds(textureIds, textureId, data.attribSize);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /**\n     * Packs attributes to single buffer.\n     *\n     * @protected\n     */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     *\n     * @param {PIXI.GraphicsData} data\n     * @protected\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            this.processHoles(data.holes);\n\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     *\n     * @param {PIXI.GraphicsData} data\n     * @protected\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     *\n     * @param {PIXI.GraphicsData[]} holes - Holes to render\n     * @protected\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     *\n     * @protected\n     */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                const alignment = lineStyle.alignment;\n\n                lineWidth = lineStyle.width;\n\n                if (type === SHAPES.POLY)\n                {\n                    lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\n                }\n                else\n                {\n                    lineWidth = lineWidth * Math.max(0, alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                const rect = shape as Rectangle | RoundedRectangle;\n\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                const circle = shape as Circle;\n\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\n                    circle.radius + lineWidth, circle.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                const ellipse = shape as Ellipse;\n\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\n            }\n            else\n            {\n                const poly = shape as Polygon;\n                // adding directly to the bounds\n\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     *\n     * @protected\n     * @param {number[]} colors - List of colors to add to\n     * @param {number} color - Color to add\n     * @param {number} alpha - Alpha to use\n     * @param {number} size - Number of colors to add\n     */\n    protected addColors(colors: Array<number>, color: number, alpha: number, size: number): void\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba =  premultiplyTint(rgb, alpha);\n\n        while (size-- > 0)\n        {\n            colors.push(rgba);\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     *\n     * @protected\n     * @param {number[]} textureIds\n     * @param {number} id\n     * @param {number} size\n     */\n    protected addTextureIds(textureIds: Array<number>, id: number, size: number): void\n    {\n        while (size-- > 0)\n        {\n            textureIds.push(id);\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     *\n     * @protected\n     * @param {number[]} verts - Vertices\n     * @param {number[]} uvs - UVs\n     * @param {PIXI.Texture} texture - Reference to Texture\n     * @param {number} start - Index buffer start index.\n     * @param {number} size - The size/length for index buffer.\n     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number, size:\n        number, matrix:\n        Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     *\n     * @param {number[]} uvs - array\n     * @param {PIXI.Texture} texture - region\n     * @param {number} start - starting index for uvs\n     * @param {number} size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n","import { FillStyle } from './FillStyle';\nimport { LINE_JOIN, LINE_CAP } from '../const';\n\n/**\n * Represents the line style for Graphics.\n * @memberof PIXI\n * @class\n * @extends PIXI.FillStyle\n */\nexport class LineStyle extends FillStyle\n{\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @member {number}\n     * @default 0\n     */\n    public width = 0;\n\n    /**\n     * The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner).\n     *\n     * @member {number}\n     * @default 0.5\n     */\n    public alignment = 0.5;\n\n    /**\n     * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     *\n     * @member {boolean}\n     * @default false\n     */\n    public native = false;\n\n    /**\n     * Line cap style.\n     *\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    public cap = LINE_CAP.BUTT;\n\n    /**\n     * Line join style.\n     *\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    public join = LINE_JOIN.MITER;\n\n    /**\n     * Miter limit.\n     *\n     * @member {number}\n     * @default 10\n     */\n    public miterLimit = 10;\n\n    /**\n     * Clones the object\n     *\n     * @return {PIXI.LineStyle}\n     */\n    public clone(): LineStyle\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n\n        return obj;\n    }\n\n    /**\n     * Reset the line style to default.\n     */\n    public reset(): void\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        this.alignment = 0.5;\n        this.width = 0;\n        this.native = false;\n    }\n}\n","import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n    SHAPES,\n} from '@pixi/math';\n\nimport { Texture, UniformGroup, State, Renderer, BatchDrawCall } from '@pixi/core';\nimport { BezierUtils, QuadraticUtils, ArcUtils, Star } from './utils';\nimport { hex2rgb, deprecation } from '@pixi/utils';\nimport { GraphicsGeometry } from './GraphicsGeometry';\nimport { FillStyle } from './styles/FillStyle';\nimport { LineStyle } from './styles/LineStyle';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\nimport { Shader } from '@pixi/core';\n\nimport type { IShape, IPointData } from '@pixi/math';\nimport type { IDestroyOptions } from '@pixi/display';\nimport { LINE_JOIN, LINE_CAP } from './const';\n\n/**\n * Batch element computed from Graphics geometry\n */\nexport interface IGraphicsBatchElement {\n    vertexData: Float32Array;\n    blendMode: BLEND_MODES;\n    indices: Uint16Array | Uint32Array;\n    uvs: Float32Array;\n    alpha: number;\n    worldAlpha: number;\n    _batchRGB: number[];\n    _tintRGB: number;\n    _texture: Texture;\n}\n\nexport interface IFillStyleOptions {\n    color?: number;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions {\n    width?: number;\n    alignment?: number;\n    native?: boolean;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\nconst temp = new Float32Array(3);\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: {[key: string]: Shader} = {};\n\nexport interface Graphics extends GlobalMixins.Graphics, Container {}\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * Note that because Graphics can share a GraphicsGeometry with other instances,\n * it is necessary to call `destroy()` to properly dereference the underlying\n * GraphicsGeometry and avoid a memory leak. Alternatively, keep using the same\n * Graphics instance and call `clear()` between redraws.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nexport class Graphics extends Container\n{\n    /**\n     * Temporary point to use for containsPoint\n     *\n     * @static\n     * @private\n     * @member {PIXI.Point}\n     */\n\n    static _TEMP_POINT = new Point();\n\n    public shader: Shader;\n    public pluginName: string;\n\n    protected currentPath: Polygon;\n    protected batches: Array<IGraphicsBatchElement>;\n    protected batchTint: number;\n    protected batchDirty: number;\n    protected vertexData: Float32Array;\n\n    protected _fillStyle: FillStyle;\n    protected _lineStyle: LineStyle;\n    protected _matrix: Matrix;\n    protected _holeMode: boolean;\n    protected _transformID: number;\n    protected _tint: number;\n\n    private state: State;\n    private _geometry: GraphicsGeometry;\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     *\n     * @member {PIXI.GraphicsGeometry}\n     * @readonly\n     */\n    public get geometry(): GraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    /**\n     * @param {PIXI.GraphicsGeometry} [geometry=null] - Geometry to use, if omitted\n     *        will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry: GraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new GraphicsGeometry();\n        this._geometry.refCount++;\n\n        /**\n         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n         * Can be shared between multiple Graphics objects.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n         *\n         * @member {PIXI.State}\n         */\n        this.state = State.for2d();\n\n        /**\n         * Current fill style\n         *\n         * @member {PIXI.FillStyle}\n         * @protected\n         */\n        this._fillStyle = new FillStyle();\n\n        /**\n         * Current line style\n         *\n         * @member {PIXI.LineStyle}\n         * @protected\n         */\n        this._lineStyle = new LineStyle();\n\n        /**\n         * Current shape transform matrix.\n         *\n         * @member {PIXI.Matrix}\n         * @protected\n         */\n        this._matrix = null;\n\n        /**\n         * Current hole mode is enabled.\n         *\n         * @member {boolean}\n         * @default false\n         * @protected\n         */\n        this._holeMode = false;\n\n        /**\n         * Current path\n         *\n         * @member {PIXI.Polygon}\n         * @protected\n         */\n        this.currentPath = null;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        /**\n         * A collections of batches! These can be drawn by the renderer batch system.\n         *\n         * @protected\n         * @member {object[]}\n         */\n        this.batches = [];\n\n        /**\n         * Update dirty for limiting calculating tints for batches.\n         *\n         * @protected\n         * @member {number}\n         * @default -1\n         */\n        this.batchTint = -1;\n\n        /**\n         * Update dirty for limiting calculating batches.\n         *\n         * @protected\n         * @member {number}\n         * @default -1\n         */\n        this.batchDirty = -1;\n\n        /**\n         * Copy of the object vertex data.\n         *\n         * @protected\n         * @member {Float32Array}\n         */\n        this.vertexData = null;\n\n        /**\n         * Renderer plugin for batching\n         *\n         * @member {string}\n         * @default 'batch'\n         */\n        this.pluginName = 'batch';\n\n        this._transformID = -1;\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n    public clone(): Graphics\n    {\n        this.finishPoly();\n\n        return new Graphics(this._geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    public get tint(): number\n    {\n        return this._tint;\n    }\n\n    public set tint(value: number)\n    {\n        this._tint = value;\n    }\n\n    /**\n     * The current fill style.\n     *\n     * @member {PIXI.FillStyle}\n     * @readonly\n     */\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     *\n     * @member {PIXI.LineStyle}\n     * @readonly\n     */\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @method PIXI.Graphics#lineStyle\n     * @param {number} [width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {object} [options] - Line style options\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(options: ILineStyleOptions = null): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            // eslint-disable-next-line\n            const args = arguments;\n\n            options = {\n                width: args[0] || 0,\n                color: args[1] || 0x0,\n                alpha: args[2] !== undefined ? args[2] : 1,\n                alignment: args[3] !== undefined ? args[3] : 0.5,\n                native: !!args[4],\n            };\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     *\n     * @param {object} [options] - Collection of options for setting line style.\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n     *  Default 0xFFFFFF if texture present.\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineTextureStyle(options: ILineStyleOptions): this\n    {\n        // backward compatibility with params: (width, texture,\n        // color, alpha, matrix, alignment, native)\n        if (typeof options === 'number')\n        {\n            deprecation('v5.2.0', 'Please use object-based options for Graphics#lineTextureStyle');\n\n            // eslint-disable-next-line\n            const [width, texture, color, alpha, matrix, alignment, native] = arguments as any;\n\n            options = { width, texture, color, alpha, matrix, alignment, native };\n\n            // Remove undefined keys\n            Object.keys(options).forEach((key) => (options as any)[key] === undefined && delete (options as any)[key]);\n        }\n\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally\n     * @protected\n     */\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     * @protected\n     */\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Initialize the curve\n     *\n     * @protected\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     */\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the first tangent point of the arc\n     * @param {number} y1 - The y-coordinate of the first tangent point of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public beginFill(color = 0, alpha = 1): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n    }\n\n    /**\n     * Begin the texture fill\n     *\n     * @param {object} [options] - Object object.\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {number} [options.color=0xffffff] - Background to fill behind texture\n     * @param {number} [options.alpha=1] - Alpha of fill\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(options: IFillStyleOptions): this\n    {\n        // backward compatibility with params: (texture, color, alpha, matrix)\n        if (options instanceof Texture)\n        {\n            deprecation('v5.2.0', 'Please use object-based options for Graphics#beginTextureFill');\n\n            // eslint-disable-next-line\n            const [texture, color, alpha, matrix] = arguments as any;\n\n            options = { texture, color, alpha, matrix };\n\n            // Remove undefined keys\n            Object.keys(options).forEach((key) => (options as any)[key] === undefined && delete (options as any)[key]);\n        }\n\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n        }, options) as IFillStyleOptions;\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<Point>): this\n    public drawPolygon(path: Array<number> | Array<Point> | Polygon): this\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<Point>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else\n        if (Array.isArray(path[0]))\n        {\n            points = path[0];\n        }\n        else\n        {\n            points = path;\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Draw a star shape with an arbitrary number of points.\n     *\n     * @param {number} x - Center X position of the star\n     * @param {number} y - Center Y position of the star\n     * @param {number} points - The number of points of the star, must be > 1\n     * @param {number} radius - The outer radius of the star\n     * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public drawStar(x: number, y: number, points: number, radius: number, innerRadius: number, rotation = 0): this\n    {\n        return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation) as Polygon);\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        const hasuit32 = renderer.context.supports.uint32Indices;\n        // batch part..\n        // batch it!\n\n        geometry.updateBatches(hasuit32);\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /**\n     * Populating batches for rendering\n     *\n     * @protected\n     */\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: hex2rgb(color) as Array<number>,\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1 };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this._geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /**\n     * Renders specific DrawCall\n     *\n     * @param {PIXI.Renderer} renderer\n     * @param {PIXI.BatchDrawCall} drawCall\n     */\n    protected _renderDrawCallDirect(renderer: Renderer, drawCall: BatchDrawCall): void\n    {\n        const { texArray, type, size, start } = drawCall;\n        const groupTextureCount = texArray.count;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(texArray.elements[j], j);\n        }\n\n        renderer.geometry.draw(type, size, start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _resolveDirectShader(renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const sampleValues = new Int32Array(16);\n\n                for (let i = 0; i < 16; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object\n     *\n     * @protected\n     */\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.IPointData} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /**\n     * Recalcuate the tint by applying tin to batches using Graphics tint.\n     * @protected\n     */\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                        + (color & 0xff00)\n                        + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    /**\n     * If there's a transform update or a change to the shape of the\n     * geometry, recaculate the vertices.\n     * @protected\n     */\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     *\n     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options: IDestroyOptions|boolean): void\n    {\n        super.destroy(options);\n\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n"],"mappings":";;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;AAcA,IAAYA,SAIX;AAJD,WAAYA,SAAS;EACjBA,SAAA,mBAAe;EACfA,SAAA,mBAAe;EACfA,SAAA,mBAAe;CAClB,EAJWA,SAAS,KAATA,SAAS;;;;;;;;;;;;;;AAmBrB,IAAYC,QAIX;AAJD,WAAYA,QAAQ;EAChBA,QAAA,iBAAa;EACbA,QAAA,mBAAe;EACfA,QAAA,qBAAiB;CACpB,EAJWA,QAAQ,KAARA,QAAQ;;;;;;;;;;;;;;;;AAgCpB,IAAaC,eAAe,GAA4B;EACpDC,QAAQ,EAAE,IAAI;EACdC,SAAS,EAAE,EAAE;EACbC,WAAW,EAAE,CAAC;EACdC,WAAW,EAAG,IAAI;EAElBC,OAAO,EAAE,MAAM;EAEfC,cAAc,EAAd,SAAAA,CAAeC,MAAc,EAAEC,eAAoB;IAApB,IAAAA,eAAA;MAAAA,eAAA,KAAoB;IAAA;IAE/C,IAAI,CAAC,IAAI,CAACP,QAAQ,IAAI,CAACM,MAAM,IAAIE,KAAK,CAACF,MAAM,CAAC,EAC9C;MACI,OAAOC,eAAe;;IAG1B,IAAIE,MAAM,GAAGC,IAAI,CAACC,IAAI,CAACL,MAAM,GAAG,IAAI,CAACL,SAAS,CAAC;IAE/C,IAAIQ,MAAM,GAAG,IAAI,CAACP,WAAW,EAC7B;MACIO,MAAM,GAAG,IAAI,CAACP,WAAW;KAC5B,MACI,IAAIO,MAAM,GAAG,IAAI,CAACN,WAAW,EAClC;MACIM,MAAM,GAAG,IAAI,CAACN,WAAW;;IAG7B,OAAOM,MAAM;;CAEpB;;;;;;;;ACpFD,IAAAG,SAAA;EA0CI,SAAAA,UAAA;;;;;;;IAlCO,KAAAC,KAAK,GAAG,QAAQ;;;;;;;IAQhB,KAAAC,KAAK,GAAG,GAAG;;;;;;;IAQX,KAAAC,OAAO,GAAYC,OAAO,CAACC,KAAK;;;;;;;IAQhC,KAAAC,MAAM,GAAW,IAAI;;;;;;;IAQrB,KAAAC,OAAO,GAAG,KAAK;IAIlB,IAAI,CAACC,KAAK,EAAE;;;;;;;EAQTR,SAAA,CAAAS,SAAA,CAAAC,KAAK,GAAZ;IAEI,IAAMC,GAAG,GAAG,IAAIX,SAAS,EAAE;IAE3BW,GAAG,CAACV,KAAK,GAAG,IAAI,CAACA,KAAK;IACtBU,GAAG,CAACT,KAAK,GAAG,IAAI,CAACA,KAAK;IACtBS,GAAG,CAACR,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1BQ,GAAG,CAACL,MAAM,GAAG,IAAI,CAACA,MAAM;IACxBK,GAAG,CAACJ,OAAO,GAAG,IAAI,CAACA,OAAO;IAE1B,OAAOI,GAAG;GACb;;;;EAKMX,SAAA,CAAAS,SAAA,CAAAD,KAAK,GAAZ;IAEI,IAAI,CAACP,KAAK,GAAG,QAAQ;IACrB,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,OAAO,GAAGC,OAAO,CAACC,KAAK;IAC5B,IAAI,CAACC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,OAAO,GAAG,KAAK;GACvB;;;;EAKMP,SAAA,CAAAS,SAAA,CAAAG,OAAO,GAAd;IAEI,IAAI,CAACT,OAAO,GAAG,IAAI;IACnB,IAAI,CAACG,MAAM,GAAG,IAAI;GACrB;EACL,OAAAN,SAAC;CAAA;;AC9FD;;;;;;;;;;;;;;;;AAgBA,IAAIa,aAAa,GAAG,SAAAA,CAASC,CAAC,EAAEC,CAAC,EAAE;EAC/BF,aAAa,GAAGG,MAAM,CAACC,cAAc,IAChC;IAAEC,SAAS,EAAE;EAAE,CAAE,YAAYC,KAAK,IAAI,UAAUL,CAAC,EAAEC,CAAC,EAAE;IAAED,CAAC,CAACI,SAAS,GAAGH,CAAC;EAAC,CAAG,IAC5E,UAAUD,CAAC,EAAEC,CAAC,EAAE;IAAE,KAAK,IAAIK,CAAC,IAAIL,CAAC;MAAE,IAAIA,CAAC,CAACM,cAAc,CAACD,CAAC,CAAC;QAAEN,CAAC,CAACM,CAAC,CAAC,GAAGL,CAAC,CAACK,CAAC,CAAC;MAAA;IAAA;EAAC,CAAE;EAC9E,OAAOP,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;CAC7B;AAED,SAAgBO,SAASA,CAACR,CAAC,EAAEC,CAAC,EAAE;EAC5BF,aAAa,CAACC,CAAC,EAAEC,CAAC,CAAC;EACnB,SAASQ,EAAEA,CAAA,EAAG;IAAE,IAAI,CAACC,WAAW,GAAGV,CAAC;EAAC;EACrCA,CAAC,CAACL,SAAS,GAAGM,CAAC,KAAK,IAAI,GAAGC,MAAM,CAACS,MAAM,CAACV,CAAC,CAAC,IAAIQ,EAAE,CAACd,SAAS,GAAGM,CAAC,CAACN,SAAS,EAAE,IAAIc,EAAE,EAAE,CAAC;;;;;;;;;;;;;;ACVxF,IAAaG,SAAS,GAAuB;EAEzCC,KAAK,EAAL,SAAAA,CAAMC,YAAY;IAEdA,YAAY,CAACC,MAAM,GAAID,YAAY,CAACE,KAAiB,CAACD,MAAM,CAACE,KAAK,EAAE;GACvE;EAEDC,WAAW,WAAAA,CAACJ,YAAY,EAAEK,gBAAgB;IAEtC,IAAIJ,MAAM,GAAGD,YAAY,CAACC,MAAM;IAChC,IAAMK,KAAK,GAAGN,YAAY,CAACM,KAAK;IAChC,IAAMC,KAAK,GAAGF,gBAAgB,CAACJ,MAAM;IACrC,IAAMO,OAAO,GAAGH,gBAAgB,CAACG,OAAO;IAExC,IAAIP,MAAM,CAACnC,MAAM,IAAI,CAAC,EACtB;MACI,IAAM2C,SAAS,GAAG,EAAE;;MAGpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACxC,MAAM,EAAE4C,CAAC,EAAE,EACrC;QACI,IAAMC,IAAI,GAAGL,KAAK,CAACI,CAAC,CAAC;QAErBD,SAAS,CAACG,IAAI,CAACX,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;QACjCmC,MAAM,GAAGA,MAAM,CAACY,MAAM,CAACF,IAAI,CAACV,MAAM,CAAC;;;MAIvC,IAAMa,SAAS,GAAGC,MAAM,CAACd,MAAM,EAAEQ,SAAS,EAAE,CAAC,CAAC;MAE9C,IAAI,CAACK,SAAS,EACd;QACI;;MAGJ,IAAME,OAAO,GAAGT,KAAK,CAACzC,MAAM,GAAG,CAAC;MAEhC,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,SAAS,CAAChD,MAAM,EAAE4C,CAAC,IAAI,CAAC,EAC5C;QACIF,OAAO,CAACI,IAAI,CAACE,SAAS,CAACJ,CAAC,CAAC,GAAGM,OAAO,CAAC;QACpCR,OAAO,CAACI,IAAI,CAACE,SAAS,CAACJ,CAAC,GAAG,CAAC,CAAC,GAAGM,OAAO,CAAC;QACxCR,OAAO,CAACI,IAAI,CAACE,SAAS,CAACJ,CAAC,GAAG,CAAC,CAAC,GAAGM,OAAO,CAAC;;MAG5C,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,CAACnC,MAAM,EAAE4C,CAAC,EAAE,EACtC;QACIH,KAAK,CAACK,IAAI,CAACX,MAAM,CAACS,CAAC,CAAC,CAAC;;;;CAIpC;;AClED;AACA;;;;;;;;;;;AAgBA,IAAaO,WAAW,GAAuB;EAE3ClB,KAAK,EAAL,SAAAA,CAAMC,YAAY;;IAGd,IAAMkB,UAAU,GAAGlB,YAAY,CAACE,KAAe;IAC/C,IAAMD,MAAM,GAAGD,YAAY,CAACC,MAAM;IAClC,IAAMkB,CAAC,GAAGD,UAAU,CAACC,CAAC;IACtB,IAAMC,CAAC,GAAGF,UAAU,CAACE,CAAC;IACtB,IAAIC,KAAK;IACT,IAAIC,MAAM;IAEVrB,MAAM,CAACnC,MAAM,GAAG,CAAC;;IAGjB,IAAIkC,YAAY,CAACuB,IAAI,KAAKC,MAAM,CAACC,IAAI,EACrC;MACIJ,KAAK,GAAGH,UAAU,CAACQ,MAAM;MACzBJ,MAAM,GAAGJ,UAAU,CAACQ,MAAM;KAC7B,MAED;MACI,IAAMC,WAAW,GAAG3B,YAAY,CAACE,KAAgB;MAEjDmB,KAAK,GAAGM,WAAW,CAACN,KAAK;MACzBC,MAAM,GAAGK,WAAW,CAACL,MAAM;;IAG/B,IAAID,KAAK,KAAK,CAAC,IAAIC,MAAM,KAAK,CAAC,EAC/B;MACI;;IAGJ,IAAIM,SAAS,GAAG1D,IAAI,CAAC2D,KAAK,CAAC,EAAE,GAAG3D,IAAI,CAAC4D,IAAI,CAACZ,UAAU,CAACQ,MAAM,CAAC,CAAC,IACtDxD,IAAI,CAAC2D,KAAK,CAAC,EAAE,GAAG3D,IAAI,CAAC4D,IAAI,CAACT,KAAK,GAAGC,MAAM,CAAC,CAAC;IAEjDM,SAAS,IAAI,GAAG;IAEhB,IAAMG,GAAG,GAAI7D,IAAI,CAAC8D,EAAE,GAAG,CAAC,GAAIJ,SAAS;IAErC,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,SAAS,GAAG,GAAG,EAAElB,CAAC,EAAE,EACxC;MACIT,MAAM,CAACW,IAAI,CACPO,CAAC,GAAIjD,IAAI,CAAC+D,GAAG,CAAC,CAACF,GAAG,GAAGrB,CAAC,CAAC,GAAGW,KAAM,EAChCD,CAAC,GAAIlD,IAAI,CAACgE,GAAG,CAAC,CAACH,GAAG,GAAGrB,CAAC,CAAC,GAAGY,MAAO,CACpC;;IAGLrB,MAAM,CAACW,IAAI,CAACX,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;GACpC;EAEDG,WAAW,EAAX,SAAAA,CAAYJ,YAAY,EAAEK,gBAAgB;IAEtC,IAAMJ,MAAM,GAAGD,YAAY,CAACC,MAAM;IAClC,IAAMM,KAAK,GAAGF,gBAAgB,CAACJ,MAAM;IACrC,IAAMO,OAAO,GAAGH,gBAAgB,CAACG,OAAO;IAExC,IAAIQ,OAAO,GAAGT,KAAK,CAACzC,MAAM,GAAG,CAAC;IAC9B,IAAMqE,MAAM,GAAGnB,OAAO;IAEtB,IAAMoB,MAAM,GAAIpC,YAAY,CAACE,KAAgB;IAC7C,IAAMxB,MAAM,GAAGsB,YAAY,CAACtB,MAAM;IAClC,IAAMyC,CAAC,GAAGiB,MAAM,CAACjB,CAAC;IAClB,IAAMC,CAAC,GAAGgB,MAAM,CAAChB,CAAC;;IAGlBb,KAAK,CAACK,IAAI,CACNZ,YAAY,CAACtB,MAAM,GAAIA,MAAM,CAAC2D,CAAC,GAAGlB,CAAC,GAAKzC,MAAM,CAAC4D,CAAC,GAAGlB,CAAE,GAAG1C,MAAM,CAAC6D,EAAE,GAAGpB,CAAC,EACrEnB,YAAY,CAACtB,MAAM,GAAIA,MAAM,CAACS,CAAC,GAAGgC,CAAC,GAAKzC,MAAM,CAACQ,CAAC,GAAGkC,CAAE,GAAG1C,MAAM,CAAC8D,EAAE,GAAGpB,CAAC,CAAC;IAE1E,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,CAACnC,MAAM,EAAE4C,CAAC,IAAI,CAAC,EACzC;MACIH,KAAK,CAACK,IAAI,CAACX,MAAM,CAACS,CAAC,CAAC,EAAET,MAAM,CAACS,CAAC,GAAG,CAAC,CAAC,CAAC;;MAGpCF,OAAO,CAACI,IAAI,CAACI,OAAO,EAAE,EAAEmB,MAAM,EAAEnB,OAAO,CAAC;;;CAGnD;;AC5FD;;;;;;;;;;;AAWA,IAAayB,cAAc,GAAuB;EAE9C1C,KAAK,EAAL,SAAAA,CAAMC,YAAY;;;;IAKd,IAAM0C,QAAQ,GAAG1C,YAAY,CAACE,KAAkB;IAChD,IAAMiB,CAAC,GAAGuB,QAAQ,CAACvB,CAAC;IACpB,IAAMC,CAAC,GAAGsB,QAAQ,CAACtB,CAAC;IACpB,IAAMC,KAAK,GAAGqB,QAAQ,CAACrB,KAAK;IAC5B,IAAMC,MAAM,GAAGoB,QAAQ,CAACpB,MAAM;IAE9B,IAAMrB,MAAM,GAAGD,YAAY,CAACC,MAAM;IAElCA,MAAM,CAACnC,MAAM,GAAG,CAAC;IAEjBmC,MAAM,CAACW,IAAI,CAACO,CAAC,EAAEC,CAAC,EACZD,CAAC,GAAGE,KAAK,EAAED,CAAC,EACZD,CAAC,GAAGE,KAAK,EAAED,CAAC,GAAGE,MAAM,EACrBH,CAAC,EAAEC,CAAC,GAAGE,MAAM,CAAC;GACrB;EAEDlB,WAAW,WAAAA,CAACJ,YAAY,EAAEK,gBAAgB;IAEtC,IAAMJ,MAAM,GAAGD,YAAY,CAACC,MAAM;IAClC,IAAMM,KAAK,GAAGF,gBAAgB,CAACJ,MAAM;IAErC,IAAMe,OAAO,GAAGT,KAAK,CAACzC,MAAM,GAAG,CAAC;IAEhCyC,KAAK,CAACK,IAAI,CAACX,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EAC3BA,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EACpBA,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,EACpBA,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;IAEzBI,gBAAgB,CAACG,OAAO,CAACI,IAAI,CAACI,OAAO,EAAEA,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,CAAC,EAC3DA,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,CAAC,CAAC;;CAEjD;;;;;;;;;;;;;;;ACjCD,SAAS2B,KAAKA,CAACC,EAAU,EAAEC,EAAU,EAAEC,IAAY;EAE/C,IAAMC,IAAI,GAAGF,EAAE,GAAGD,EAAE;EAEpB,OAAOA,EAAE,GAAIG,IAAI,GAAGD,IAAK;;;;;;;;;;;;;;;;;;;AAoB7B,SAASE,oBAAoBA,CACzBC,KAAa,EAAEC,KAAa,EAC5BC,GAAW,EAAEC,GAAW,EACxBC,GAAW,EAAEC,GAAW,EACxBC,GAAuB;EAAvB,IAAAA,GAAA;IAAAA,GAAA,KAAuB;EAAA;EAEvB,IAAMC,CAAC,GAAG,EAAE;EACZ,IAAMvD,MAAM,GAAGsD,GAAG;EAElB,IAAIE,EAAE,GAAG,CAAC;EACV,IAAIC,EAAE,GAAG,CAAC;EACV,IAAIC,EAAE,GAAG,CAAC;EACV,IAAIC,EAAE,GAAG,CAAC;EACV,IAAIzC,CAAC,GAAG,CAAC;EACT,IAAIC,CAAC,GAAG,CAAC;EAET,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEmD,CAAC,GAAG,CAAC,EAAEnD,CAAC,IAAI8C,CAAC,EAAE,EAAE9C,CAAC,EAClC;IACImD,CAAC,GAAGnD,CAAC,GAAG8C,CAAC;;IAGTC,EAAE,GAAGd,KAAK,CAACM,KAAK,EAAEE,GAAG,EAAEU,CAAC,CAAC;IACzBH,EAAE,GAAGf,KAAK,CAACO,KAAK,EAAEE,GAAG,EAAES,CAAC,CAAC;IACzBF,EAAE,GAAGhB,KAAK,CAACQ,GAAG,EAAEE,GAAG,EAAEQ,CAAC,CAAC;IACvBD,EAAE,GAAGjB,KAAK,CAACS,GAAG,EAAEE,GAAG,EAAEO,CAAC,CAAC;;IAGvB1C,CAAC,GAAGwB,KAAK,CAACc,EAAE,EAAEE,EAAE,EAAEE,CAAC,CAAC;IACpBzC,CAAC,GAAGuB,KAAK,CAACe,EAAE,EAAEE,EAAE,EAAEC,CAAC,CAAC;IAEpB5D,MAAM,CAACW,IAAI,CAACO,CAAC,EAAEC,CAAC,CAAC;;EAGrB,OAAOnB,MAAM;;;;;;;;;;;;;AAcjB,IAAa6D,qBAAqB,GAAuB;EAErD/D,KAAK,EAAL,SAAAA,CAAMC,YAAY;IAEd,IAAM+D,SAAS,GAAG/D,YAAY,CAACE,KAAyB;IACxD,IAAMD,MAAM,GAAGD,YAAY,CAACC,MAAM;IAClC,IAAMkB,CAAC,GAAG4C,SAAS,CAAC5C,CAAC;IACrB,IAAMC,CAAC,GAAG2C,SAAS,CAAC3C,CAAC;IACrB,IAAMC,KAAK,GAAG0C,SAAS,CAAC1C,KAAK;IAC7B,IAAMC,MAAM,GAAGyC,SAAS,CAACzC,MAAM;;IAG/B,IAAMI,MAAM,GAAGxD,IAAI,CAAC8F,GAAG,CAAC,CAAC,EAAE9F,IAAI,CAAC+F,GAAG,CAACF,SAAS,CAACrC,MAAM,EAAExD,IAAI,CAAC+F,GAAG,CAAC5C,KAAK,EAAEC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;IAEnFrB,MAAM,CAACnC,MAAM,GAAG,CAAC;;IAGjB,IAAI,CAAC4D,MAAM,EACX;MACIzB,MAAM,CAACW,IAAI,CAACO,CAAC,EAAEC,CAAC,EACZD,CAAC,GAAGE,KAAK,EAAED,CAAC,EACZD,CAAC,GAAGE,KAAK,EAAED,CAAC,GAAGE,MAAM,EACrBH,CAAC,EAAEC,CAAC,GAAGE,MAAM,CAAC;KACrB,MAED;MACI0B,oBAAoB,CAAC7B,CAAC,EAAEC,CAAC,GAAGM,MAAM,EAC9BP,CAAC,EAAEC,CAAC,EACJD,CAAC,GAAGO,MAAM,EAAEN,CAAC,EACbnB,MAAM,CAAC;MACX+C,oBAAoB,CAAC7B,CAAC,GAAGE,KAAK,GAAGK,MAAM,EACnCN,CAAC,EAAED,CAAC,GAAGE,KAAK,EAAED,CAAC,EACfD,CAAC,GAAGE,KAAK,EAAED,CAAC,GAAGM,MAAM,EACrBzB,MAAM,CAAC;MACX+C,oBAAoB,CAAC7B,CAAC,GAAGE,KAAK,EAAED,CAAC,GAAGE,MAAM,GAAGI,MAAM,EAC/CP,CAAC,GAAGE,KAAK,EAAED,CAAC,GAAGE,MAAM,EACrBH,CAAC,GAAGE,KAAK,GAAGK,MAAM,EAAEN,CAAC,GAAGE,MAAM,EAC9BrB,MAAM,CAAC;MACX+C,oBAAoB,CAAC7B,CAAC,GAAGO,MAAM,EAAEN,CAAC,GAAGE,MAAM,EACvCH,CAAC,EAAEC,CAAC,GAAGE,MAAM,EACbH,CAAC,EAAEC,CAAC,GAAGE,MAAM,GAAGI,MAAM,EACtBzB,MAAM,CAAC;;;;GAKlB;EAEDG,WAAW,WAAAA,CAACJ,YAAY,EAAEK,gBAAgB;IAEtC,IAAMJ,MAAM,GAAGD,YAAY,CAACC,MAAM;IAElC,IAAMM,KAAK,GAAGF,gBAAgB,CAACJ,MAAM;IACrC,IAAMO,OAAO,GAAGH,gBAAgB,CAACG,OAAO;IAExC,IAAM0D,MAAM,GAAG3D,KAAK,CAACzC,MAAM,GAAG,CAAC;IAE/B,IAAMgD,SAAS,GAAGC,MAAM,CAACd,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;IAEzC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEmD,CAAC,GAAG/C,SAAS,CAAChD,MAAM,EAAE4C,CAAC,GAAGmD,CAAC,EAAEnD,CAAC,IAAI,CAAC,EACnD;MACIF,OAAO,CAACI,IAAI,CAACE,SAAS,CAACJ,CAAC,CAAC,GAAGwD,MAAM,CAAC;;MAEnC1D,OAAO,CAACI,IAAI,CAACE,SAAS,CAACJ,CAAC,GAAG,CAAC,CAAC,GAAGwD,MAAM,CAAC;;MAEvC1D,OAAO,CAACI,IAAI,CAACE,SAAS,CAACJ,CAAC,GAAG,CAAC,CAAC,GAAGwD,MAAM,CAAC;;IAG3C,KAAK,IAAIxD,CAAC,GAAG,CAAC,EAAEmD,CAAC,GAAG5D,MAAM,CAACnC,MAAM,EAAE4C,CAAC,GAAGmD,CAAC,EAAEnD,CAAC,EAAE,EAC7C;MACIH,KAAK,CAACK,IAAI,CAACX,MAAM,CAACS,CAAC,CAAC,EAAET,MAAM,CAAC,EAAES,CAAC,CAAC,CAAC;;;CAG7C;;;;;;;;;;;;;;;;AC7ID,SAASyD,MAAMA,CACXhD,CAAS,EACTC,CAAS,EACTgD,EAAU,EACVC,EAAU,EACVC,WAAmB,EACnBC,WAAmB,EACnBC,SAAkB,kEAClBjE,KAAoB;EAGpB,IAAMkE,EAAE,GAAGtD,CAAC,GAAIiD,EAAE,GAAGE,WAAY;EACjC,IAAMI,EAAE,GAAGtD,CAAC,GAAIiD,EAAE,GAAGC,WAAY;EACjC,IAAMK,EAAE,GAAGxD,CAAC,GAAIiD,EAAE,GAAGG,WAAY;EACjC,IAAMK,EAAE,GAAGxD,CAAC,GAAIiD,EAAE,GAAGE,WAAY;;EAGjC,IAAIM,GAAG;EAAE,IACLC,GAAG;EAEP,IAAIN,SAAS,EACb;IACIK,GAAG,GAAGR,EAAE;IACRS,GAAG,GAAG,CAACV,EAAE;GACZ,MAED;IACIS,GAAG,GAAG,CAACR,EAAE;IACTS,GAAG,GAAGV,EAAE;;;EAIZ,IAAMW,GAAG,GAAGN,EAAE,GAAGI,GAAG;EACpB,IAAMG,GAAG,GAAGN,EAAE,GAAGI,GAAG;EACpB,IAAMG,GAAG,GAAGN,EAAE,GAAGE,GAAG;EACpB,IAAMK,GAAG,GAAGN,EAAE,GAAGE,GAAG;;EAGpBvE,KAAK,CAACK,IAAI,CAACmE,GAAG,EAAEC,GAAG,CAAC;EACpBzE,KAAK,CAACK,IAAI,CAACqE,GAAG,EAAEC,GAAG,CAAC;EAEpB,OAAO,CAAC;;;;;;;;;;;;;;;;;;;AAoBZ,SAASC,KAAKA,CACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVlF,KAAoB,EACpBiE,SAAkB;EAGlB,IAAMkB,MAAM,GAAGJ,EAAE,GAAGF,EAAE;EACtB,IAAMO,MAAM,GAAGJ,EAAE,GAAGF,EAAE;EAEtB,IAAIO,MAAM,GAAG1H,IAAI,CAAC2H,KAAK,CAACH,MAAM,EAAEC,MAAM,CAAC;EACvC,IAAIG,MAAM,GAAG5H,IAAI,CAAC2H,KAAK,CAACL,EAAE,GAAGJ,EAAE,EAAEK,EAAE,GAAGJ,EAAE,CAAC;EAEzC,IAAIb,SAAS,IAAIoB,MAAM,GAAGE,MAAM,EAChC;IACIF,MAAM,IAAI1H,IAAI,CAAC8D,EAAE,GAAG,CAAC;GACxB,MACI,IAAI,CAACwC,SAAS,IAAIoB,MAAM,GAAGE,MAAM,EACtC;IACIA,MAAM,IAAI5H,IAAI,CAAC8D,EAAE,GAAG,CAAC;;EAGzB,IAAI+D,UAAU,GAAGH,MAAM;EACvB,IAAMI,SAAS,GAAGF,MAAM,GAAGF,MAAM;EACjC,IAAMK,YAAY,GAAG/H,IAAI,CAACgI,GAAG,CAACF,SAAS,CAAC;;;;;;;;;;;;;;;;;EAoBxC,IAAMtE,MAAM,GAAGxD,IAAI,CAAC4D,IAAI,CAAE4D,MAAM,GAAGA,MAAM,GAAKC,MAAM,GAAGA,MAAO,CAAC;EAC/D,IAAMQ,QAAQ,GAAG,CAAE,EAAE,GAAGF,YAAY,GAAG/H,IAAI,CAAC4D,IAAI,CAACJ,MAAM,CAAC,GAAGxD,IAAI,CAAC8D,EAAE,IAAK,CAAC,IAAI,CAAC;EAC7E,IAAMoE,QAAQ,GAAGJ,SAAS,GAAGG,QAAQ;EAErCJ,UAAU,IAAIK,QAAQ;EAEtB,IAAI5B,SAAS,EACb;IACIjE,KAAK,CAACK,IAAI,CAACwE,EAAE,EAAEC,EAAE,CAAC;IAClB9E,KAAK,CAACK,IAAI,CAAC0E,EAAE,EAAEC,EAAE,CAAC;IAElB,KAAK,IAAI7E,CAAC,GAAG,CAAC,EAAE2F,KAAK,GAAGN,UAAU,EAAErF,CAAC,GAAGyF,QAAQ,EAAEzF,CAAC,EAAE,EAAE2F,KAAK,IAAID,QAAQ,EACxE;MACI7F,KAAK,CAACK,IAAI,CAACwE,EAAE,EAAEC,EAAE,CAAC;MAClB9E,KAAK,CAACK,IAAI,CAACwE,EAAE,GAAKlH,IAAI,CAAC+D,GAAG,CAACoE,KAAK,CAAC,GAAG3E,MAAQ,EACxC2D,EAAE,GAAKnH,IAAI,CAACgE,GAAG,CAACmE,KAAK,CAAC,GAAG3E,MAAQ,CAAC;;IAG1CnB,KAAK,CAACK,IAAI,CAACwE,EAAE,EAAEC,EAAE,CAAC;IAClB9E,KAAK,CAACK,IAAI,CAAC4E,EAAE,EAAEC,EAAE,CAAC;GACrB,MAED;IACIlF,KAAK,CAACK,IAAI,CAAC0E,EAAE,EAAEC,EAAE,CAAC;IAClBhF,KAAK,CAACK,IAAI,CAACwE,EAAE,EAAEC,EAAE,CAAC;IAElB,KAAK,IAAI3E,CAAC,GAAG,CAAC,EAAE2F,KAAK,GAAGN,UAAU,EAAErF,CAAC,GAAGyF,QAAQ,EAAEzF,CAAC,EAAE,EAAE2F,KAAK,IAAID,QAAQ,EACxE;MACI7F,KAAK,CAACK,IAAI,CAACwE,EAAE,GAAKlH,IAAI,CAAC+D,GAAG,CAACoE,KAAK,CAAC,GAAG3E,MAAQ,EACxC2D,EAAE,GAAKnH,IAAI,CAACgE,GAAG,CAACmE,KAAK,CAAC,GAAG3E,MAAQ,CAAC;MACtCnB,KAAK,CAACK,IAAI,CAACwE,EAAE,EAAEC,EAAE,CAAC;;IAGtB9E,KAAK,CAACK,IAAI,CAAC4E,EAAE,EAAEC,EAAE,CAAC;IAClBlF,KAAK,CAACK,IAAI,CAACwE,EAAE,EAAEC,EAAE,CAAC;;EAGtB,OAAOc,QAAQ,GAAG,CAAC;;;;;;;;;;;;AAavB,SAASG,kBAAkBA,CAACtG,YAA0B,EAAEK,gBAAkC;EAEtF,IAAMH,KAAK,GAAGF,YAAY,CAACE,KAAgB;EAC3C,IAAID,MAAM,GAAGD,YAAY,CAACC,MAAM,IAAIC,KAAK,CAACD,MAAM,CAACE,KAAK,EAAE;EACxD,IAAMoG,GAAG,GAAGlG,gBAAgB,CAACmG,aAAa;EAE1C,IAAIvG,MAAM,CAACnC,MAAM,KAAK,CAAC,EACvB;IACI;;;;;;;;;;;EAYJ,IAAM2I,KAAK,GAAGzG,YAAY,CAAC0G,SAAS;;EAGpC,IAAMC,UAAU,GAAG,IAAIC,KAAK,CAAC3G,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;EAClD,IAAM4G,SAAS,GAAG,IAAID,KAAK,CAAC3G,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC,EAAEmC,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC,CAAC;EACjF,IAAMgJ,WAAW,GAAG5G,KAAK,CAACqB,IAAI,KAAKC,MAAM,CAACuF,IAAI,IAAI7G,KAAK,CAAC8G,WAAW;EACnE,IAAMC,UAAU,GAAG/I,IAAI,CAACgI,GAAG,CAACS,UAAU,CAACxF,CAAC,GAAG0F,SAAS,CAAC1F,CAAC,CAAC,GAAGoF,GAAG,IACtDrI,IAAI,CAACgI,GAAG,CAACS,UAAU,CAACvF,CAAC,GAAGyF,SAAS,CAACzF,CAAC,CAAC,GAAGmF,GAAG;;EAGjD,IAAIO,WAAW,EACf;;IAEI7G,MAAM,GAAGA,MAAM,CAACE,KAAK,EAAE;IAEvB,IAAI8G,UAAU,EACd;MACIhH,MAAM,CAACiH,GAAG,EAAE;MACZjH,MAAM,CAACiH,GAAG,EAAE;MACZL,SAAS,CAACM,GAAG,CAAClH,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC,EAAEmC,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC,CAAC;;IAGvE,IAAMsJ,SAAS,GAAG,CAACT,UAAU,CAACxF,CAAC,GAAG0F,SAAS,CAAC1F,CAAC,IAAI,GAAG;IACpD,IAAMkG,SAAS,GAAG,CAACR,SAAS,CAACzF,CAAC,GAAGuF,UAAU,CAACvF,CAAC,IAAI,GAAG;IAEpDnB,MAAM,CAACqH,OAAO,CAACF,SAAS,EAAEC,SAAS,CAAC;IACpCpH,MAAM,CAACW,IAAI,CAACwG,SAAS,EAAEC,SAAS,CAAC;;EAGrC,IAAM9G,KAAK,GAAGF,gBAAgB,CAACJ,MAAM;EACrC,IAAMnC,MAAM,GAAGmC,MAAM,CAACnC,MAAM,GAAG,CAAC;EAChC,IAAIyJ,UAAU,GAAGtH,MAAM,CAACnC,MAAM;EAC9B,IAAM0J,UAAU,GAAGjH,KAAK,CAACzC,MAAM,GAAG,CAAC;;EAGnC,IAAMuD,KAAK,GAAGoF,KAAK,CAACpF,KAAK,GAAG,CAAC;EAC7B,IAAMoG,YAAY,GAAGpG,KAAK,GAAGA,KAAK;EAClC,IAAMqG,iBAAiB,GAAGjB,KAAK,CAACkB,UAAU,GAAGlB,KAAK,CAACkB,UAAU;;EAG7D,IAAIC,EAAE,GAAG3H,MAAM,CAAC,CAAC,CAAC;EAClB,IAAI4H,EAAE,GAAG5H,MAAM,CAAC,CAAC,CAAC;EAClB,IAAI6H,EAAE,GAAG7H,MAAM,CAAC,CAAC,CAAC;EAClB,IAAI8H,EAAE,GAAG9H,MAAM,CAAC,CAAC,CAAC;EAClB,IAAI+H,EAAE,GAAG,CAAC;EACV,IAAIC,EAAE,GAAG,CAAC;;EAGV,IAAIC,KAAK,GAAG,EAAEL,EAAE,GAAGE,EAAE,CAAC;EACtB,IAAII,KAAK,GAAGP,EAAE,GAAGE,EAAE;EACnB,IAAIM,MAAM,GAAG,CAAC;EACd,IAAIC,MAAM,GAAG,CAAC;EAEd,IAAIC,IAAI,GAAGpK,IAAI,CAAC4D,IAAI,CAAEoG,KAAK,GAAGA,KAAK,GAAKC,KAAK,GAAGA,KAAM,CAAC;EAEvDD,KAAK,IAAII,IAAI;EACbH,KAAK,IAAIG,IAAI;EACbJ,KAAK,IAAI7G,KAAK;EACd8G,KAAK,IAAI9G,KAAK;EAEd,IAAMkH,KAAK,GAAG9B,KAAK,CAAC+B,SAAS,CAAC;EAC9B,IAAMlE,WAAW,GAAG,CAAC,CAAC,GAAGiE,KAAK,IAAI,CAAC;EACnC,IAAMhE,WAAW,GAAGgE,KAAK,GAAG,CAAC;EAE7B,IAAI,CAACzB,WAAW,EAChB;IACI,IAAIL,KAAK,CAACgC,GAAG,KAAKnL,QAAQ,CAACoL,KAAK,EAChC;MACInB,UAAU,IAAIpC,KAAK,CACfyC,EAAE,GAAIM,KAAK,IAAI5D,WAAW,GAAGC,WAAW,CAAC,GAAG,GAAI,EAChDsD,EAAE,GAAIM,KAAK,IAAI7D,WAAW,GAAGC,WAAW,CAAC,GAAG,GAAI,EAChDqD,EAAE,GAAIM,KAAK,GAAG5D,WAAY,EAC1BuD,EAAE,GAAIM,KAAK,GAAG7D,WAAY,EAC1BsD,EAAE,GAAIM,KAAK,GAAG3D,WAAY,EAC1BsD,EAAE,GAAIM,KAAK,GAAG5D,WAAY,EAC1BhE,KAAK,EACL,IAAI,CACP,GAAG,CAAC;KACR,MACI,IAAIkG,KAAK,CAACgC,GAAG,KAAKnL,QAAQ,CAACqL,MAAM,EACtC;MACIpB,UAAU,IAAIpD,MAAM,CAACyD,EAAE,EAAEC,EAAE,EAAEK,KAAK,EAAEC,KAAK,EAAE7D,WAAW,EAAEC,WAAW,EAAE,IAAI,EAAEhE,KAAK,CAAC;;;;EAKzFA,KAAK,CAACK,IAAI,CACNgH,EAAE,GAAIM,KAAK,GAAG5D,WAAY,EAC1BuD,EAAE,GAAIM,KAAK,GAAG7D,WAAY,CAAC;EAC/B/D,KAAK,CAACK,IAAI,CACNgH,EAAE,GAAIM,KAAK,GAAG3D,WAAY,EAC1BsD,EAAE,GAAIM,KAAK,GAAG5D,WAAY,CAAC;EAE/B,KAAK,IAAI7D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,MAAM,GAAG,CAAC,EAAE,EAAE4C,CAAC,EACnC;IACIkH,EAAE,GAAG3H,MAAM,CAAC,CAACS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACxBmH,EAAE,GAAG5H,MAAM,CAAE,CAACS,CAAC,GAAG,CAAC,IAAI,CAAC,GAAI,CAAC,CAAC;IAE9BoH,EAAE,GAAG7H,MAAM,CAACS,CAAC,GAAG,CAAC,CAAC;IAClBqH,EAAE,GAAG9H,MAAM,CAAES,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC;IAExBsH,EAAE,GAAG/H,MAAM,CAAC,CAACS,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACxBuH,EAAE,GAAGhI,MAAM,CAAE,CAACS,CAAC,GAAG,CAAC,IAAI,CAAC,GAAI,CAAC,CAAC;IAE9BwH,KAAK,GAAG,EAAEL,EAAE,GAAGE,EAAE,CAAC;IAClBI,KAAK,GAAGP,EAAE,GAAGE,EAAE;IAEfQ,IAAI,GAAGpK,IAAI,CAAC4D,IAAI,CAAEoG,KAAK,GAAGA,KAAK,GAAKC,KAAK,GAAGA,KAAM,CAAC;IACnDD,KAAK,IAAII,IAAI;IACbH,KAAK,IAAIG,IAAI;IACbJ,KAAK,IAAI7G,KAAK;IACd8G,KAAK,IAAI9G,KAAK;IAEd+G,MAAM,GAAG,EAAEL,EAAE,GAAGE,EAAE,CAAC;IACnBI,MAAM,GAAGP,EAAE,GAAGE,EAAE;IAEhBM,IAAI,GAAGpK,IAAI,CAAC4D,IAAI,CAAEsG,MAAM,GAAGA,MAAM,GAAKC,MAAM,GAAGA,MAAO,CAAC;IACvDD,MAAM,IAAIE,IAAI;IACdD,MAAM,IAAIC,IAAI;IACdF,MAAM,IAAI/G,KAAK;IACfgH,MAAM,IAAIhH,KAAK;;IAGf,IAAMuH,GAAG,GAAGd,EAAE,GAAGF,EAAE;IACnB,IAAMiB,GAAG,GAAGhB,EAAE,GAAGE,EAAE;IACnB,IAAMe,GAAG,GAAGhB,EAAE,GAAGE,EAAE;IACnB,IAAMe,GAAG,GAAGd,EAAE,GAAGF,EAAE;;IAGnB,IAAMiB,KAAK,GAAIH,GAAG,GAAGC,GAAG,GAAKC,GAAG,GAAGH,GAAI;IACvC,IAAMpE,SAAS,GAAIwE,KAAK,GAAG,CAAE;;IAG7B,IAAI9K,IAAI,CAACgI,GAAG,CAAC8C,KAAK,CAAC,GAAG,GAAG,EACzB;MACIzI,KAAK,CAACK,IAAI,CACNkH,EAAE,GAAII,KAAK,GAAG5D,WAAY,EAC1ByD,EAAE,GAAII,KAAK,GAAG7D,WAAY,CAAC;MAC/B/D,KAAK,CAACK,IAAI,CACNkH,EAAE,GAAII,KAAK,GAAG3D,WAAY,EAC1BwD,EAAE,GAAII,KAAK,GAAG5D,WAAY,CAAC;MAE/B;;;IAIJ,IAAM0E,EAAE,GAAI,CAAC,CAACf,KAAK,GAAGN,EAAE,KAAK,CAACO,KAAK,GAAGJ,EAAE,CAAC,GAAK,CAAC,CAACG,KAAK,GAAGJ,EAAE,KAAK,CAACK,KAAK,GAAGN,EAAE,CAAE;IAC5E,IAAMqB,EAAE,GAAI,CAAC,CAACd,MAAM,GAAGJ,EAAE,KAAK,CAACK,MAAM,GAAGN,EAAE,CAAC,GAAK,CAAC,CAACK,MAAM,GAAGN,EAAE,KAAK,CAACO,MAAM,GAAGJ,EAAE,CAAE;IAChF,IAAMkB,EAAE,GAAG,CAAEP,GAAG,GAAGM,EAAE,GAAKJ,GAAG,GAAGG,EAAG,IAAID,KAAK;IAC5C,IAAMI,EAAE,GAAG,CAAEL,GAAG,GAAGE,EAAE,GAAKJ,GAAG,GAAGK,EAAG,IAAIF,KAAK;IAC5C,IAAMK,KAAK,GAAI,CAACF,EAAE,GAAGrB,EAAE,KAAKqB,EAAE,GAAGrB,EAAE,CAAC,GAAK,CAACsB,EAAE,GAAGrB,EAAE,KAAKqB,EAAE,GAAGrB,EAAE,CAAE;;IAG/D,IAAMuB,GAAG,GAAGxB,EAAE,GAAI,CAACqB,EAAE,GAAGrB,EAAE,IAAIxD,WAAY;IAC1C,IAAMiF,GAAG,GAAGxB,EAAE,GAAI,CAACqB,EAAE,GAAGrB,EAAE,IAAIzD,WAAY;;IAE1C,IAAMkF,GAAG,GAAG1B,EAAE,GAAI,CAACqB,EAAE,GAAGrB,EAAE,IAAIvD,WAAY;IAC1C,IAAMkF,GAAG,GAAG1B,EAAE,GAAI,CAACqB,EAAE,GAAGrB,EAAE,IAAIxD,WAAY;IAE1C,IAAIkC,KAAK,CAACiD,IAAI,KAAKrM,SAAS,CAACsM,KAAK,IAAIN,KAAK,GAAG5B,YAAY,GAAGC,iBAAiB,EAC9E;MACI,IAAIlD,SAAS,+BACb;UACIjE,KAAK,CAACK,IAAI,CAAC0I,GAAG,EAAEC,GAAG,CAAC,CAAC;UACrBhJ,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAII,KAAK,GAAG3D,WAAY,EAAEwD,EAAE,GAAII,KAAK,GAAG5D,WAAY,CAAC,CAAC;UACnEhE,KAAK,CAACK,IAAI,CAAC0I,GAAG,EAAEC,GAAG,CAAC,CAAC;UACrBhJ,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAIM,MAAM,GAAG7D,WAAY,EAAEwD,EAAE,GAAIM,MAAM,GAAG9D,WAAY,CAAC,CAAC;SACxE,M,6BAED;UACIhE,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAII,KAAK,GAAG5D,WAAY,EAAEyD,EAAE,GAAII,KAAK,GAAG7D,WAAY,CAAC,CAAC;UACnE/D,KAAK,CAACK,IAAI,CAAC4I,GAAG,EAAEC,GAAG,CAAC,CAAC;UACrBlJ,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAIM,MAAM,GAAG9D,WAAY,EAAEyD,EAAE,GAAIM,MAAM,GAAG/D,WAAY,CAAC,CAAC;UACrE/D,KAAK,CAACK,IAAI,CAAC4I,GAAG,EAAEC,GAAG,CAAC,CAAC;;MAGzBlC,UAAU,IAAI,CAAC;KAClB,MACI,IAAId,KAAK,CAACiD,IAAI,KAAKrM,SAAS,CAACqL,KAAK,EACvC;MACI,IAAIlE,SAAS,sBACb;UACIjE,KAAK,CAACK,IAAI,CAAC0I,GAAG,EAAEC,GAAG,CAAC;UACpBhJ,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAII,KAAK,GAAG3D,WAAY,EAAEwD,EAAE,GAAII,KAAK,GAAG5D,WAAY,CAAC;UAElEgD,UAAU,IAAIpC,KAAK,CACf2C,EAAE,EAAEC,EAAE,EACND,EAAE,GAAII,KAAK,GAAG3D,WAAY,EAAEwD,EAAE,GAAII,KAAK,GAAG5D,WAAY,EACtDuD,EAAE,GAAIM,MAAM,GAAG7D,WAAY,EAAEwD,EAAE,GAAIM,MAAM,GAAG9D,WAAY,EACxDhE,KAAK,EAAE,IAAI,CACd,GAAG,CAAC;UAELA,KAAK,CAACK,IAAI,CAAC0I,GAAG,EAAEC,GAAG,CAAC;UACpBhJ,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAIM,MAAM,GAAG7D,WAAY,EAAEwD,EAAE,GAAIM,MAAM,GAAG9D,WAAY,CAAC;SACvE,M,mBAED;UACIhE,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAII,KAAK,GAAG5D,WAAY,EAAEyD,EAAE,GAAII,KAAK,GAAG7D,WAAY,CAAC;UAClE/D,KAAK,CAACK,IAAI,CAAC4I,GAAG,EAAEC,GAAG,CAAC;UAEpBlC,UAAU,IAAIpC,KAAK,CACf2C,EAAE,EAAEC,EAAE,EACND,EAAE,GAAII,KAAK,GAAG5D,WAAY,EAAEyD,EAAE,GAAII,KAAK,GAAG7D,WAAY,EACtDwD,EAAE,GAAIM,MAAM,GAAG9D,WAAY,EAAEyD,EAAE,GAAIM,MAAM,GAAG/D,WAAY,EACxD/D,KAAK,EAAE,KAAK,CACf,GAAG,CAAC;UAELA,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAIM,MAAM,GAAG9D,WAAY,EAAEyD,EAAE,GAAIM,MAAM,GAAG/D,WAAY,CAAC;UACpE/D,KAAK,CAACK,IAAI,CAAC4I,GAAG,EAAEC,GAAG,CAAC;;KAE3B,MAED;MACIlJ,KAAK,CAACK,IAAI,CAAC0I,GAAG,EAAEC,GAAG,CAAC;MACpBhJ,KAAK,CAACK,IAAI,CAAC4I,GAAG,EAAEC,GAAG,CAAC;;;EAI5B7B,EAAE,GAAG3H,MAAM,CAAC,CAACnC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;EAC7B+J,EAAE,GAAG5H,MAAM,CAAE,CAACnC,MAAM,GAAG,CAAC,IAAI,CAAC,GAAI,CAAC,CAAC;EAEnCgK,EAAE,GAAG7H,MAAM,CAAC,CAACnC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;EAC7BiK,EAAE,GAAG9H,MAAM,CAAE,CAACnC,MAAM,GAAG,CAAC,IAAI,CAAC,GAAI,CAAC,CAAC;EAEnCoK,KAAK,GAAG,EAAEL,EAAE,GAAGE,EAAE,CAAC;EAClBI,KAAK,GAAGP,EAAE,GAAGE,EAAE;EAEfQ,IAAI,GAAGpK,IAAI,CAAC4D,IAAI,CAAEoG,KAAK,GAAGA,KAAK,GAAKC,KAAK,GAAGA,KAAM,CAAC;EACnDD,KAAK,IAAII,IAAI;EACbH,KAAK,IAAIG,IAAI;EACbJ,KAAK,IAAI7G,KAAK;EACd8G,KAAK,IAAI9G,KAAK;EAEdd,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAII,KAAK,GAAG5D,WAAY,EAAEyD,EAAE,GAAII,KAAK,GAAG7D,WAAY,CAAC;EAClE/D,KAAK,CAACK,IAAI,CAACkH,EAAE,GAAII,KAAK,GAAG3D,WAAY,EAAEwD,EAAE,GAAII,KAAK,GAAG5D,WAAY,CAAC;EAElE,IAAI,CAACuC,WAAW,EAChB;IACI,IAAIL,KAAK,CAACgC,GAAG,KAAKnL,QAAQ,CAACoL,KAAK,EAChC;MACInB,UAAU,IAAIpC,KAAK,CACf2C,EAAE,GAAII,KAAK,IAAI5D,WAAW,GAAGC,WAAW,CAAC,GAAG,GAAI,EAChDwD,EAAE,GAAII,KAAK,IAAI7D,WAAW,GAAGC,WAAW,CAAC,GAAG,GAAI,EAChDuD,EAAE,GAAII,KAAK,GAAG5D,WAAY,EAC1ByD,EAAE,GAAII,KAAK,GAAG7D,WAAY,EAC1BwD,EAAE,GAAII,KAAK,GAAG3D,WAAY,EAC1BwD,EAAE,GAAII,KAAK,GAAG5D,WAAY,EAC1BhE,KAAK,EACL,KAAK,CACR,GAAG,CAAC;KACR,MACI,IAAIkG,KAAK,CAACgC,GAAG,KAAKnL,QAAQ,CAACqL,MAAM,EACtC;MACIpB,UAAU,IAAIpD,MAAM,CAAC2D,EAAE,EAAEC,EAAE,EAAEG,KAAK,EAAEC,KAAK,EAAE7D,WAAW,EAAEC,WAAW,EAAE,KAAK,EAAEhE,KAAK,CAAC;;;EAI1F,IAAMC,OAAO,GAAGH,gBAAgB,CAACG,OAAO;EACxC,IAAMoJ,IAAI,GAAGrM,eAAe,CAACK,OAAO,GAAGL,eAAe,CAACK,OAAO;;EAG9D,KAAK,IAAI8C,CAAC,GAAG8G,UAAU,EAAE9G,CAAC,GAAG6G,UAAU,GAAGC,UAAU,GAAG,CAAC,EAAE,EAAE9G,CAAC,EAC7D;IACIkH,EAAE,GAAGrH,KAAK,CAAEG,CAAC,GAAG,CAAC,CAAE;IACnBmH,EAAE,GAAGtH,KAAK,CAAEG,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC;IAEvBoH,EAAE,GAAGvH,KAAK,CAAC,CAACG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACvBqH,EAAE,GAAGxH,KAAK,CAAE,CAACG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAI,CAAC,CAAC;IAE7BsH,EAAE,GAAGzH,KAAK,CAAC,CAACG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACvBuH,EAAE,GAAG1H,KAAK,CAAE,CAACG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAI,CAAC,CAAC;;IAG7B,IAAIxC,IAAI,CAACgI,GAAG,CAAE0B,EAAE,IAAIG,EAAE,GAAGE,EAAE,CAAC,GAAKH,EAAE,IAAIG,EAAE,GAAGJ,EAAE,CAAE,GAAIG,EAAE,IAAIH,EAAE,GAAGE,EAAE,CAAE,CAAC,GAAG6B,IAAI,EAC3E;MACI;;IAGJpJ,OAAO,CAACI,IAAI,CAACF,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;;;;;;;;;;;;;AAcrC,SAASmJ,eAAeA,CAAC7J,YAA0B,EAAEK,gBAAkC;EAEnF,IAAIK,CAAC,GAAG,CAAC;EAET,IAAMR,KAAK,GAAGF,YAAY,CAACE,KAAgB;EAC3C,IAAMD,MAAM,GAAGD,YAAY,CAACC,MAAM,IAAIC,KAAK,CAACD,MAAM;EAClD,IAAM6G,WAAW,GAAG5G,KAAK,CAACqB,IAAI,KAAKC,MAAM,CAACuF,IAAI,IAAI7G,KAAK,CAAC8G,WAAW;EAEnE,IAAI/G,MAAM,CAACnC,MAAM,KAAK,CAAC,E;IAAE;EAAA;EAEzB,IAAMyC,KAAK,GAAGF,gBAAgB,CAACJ,MAAM;EACrC,IAAMO,OAAO,GAAGH,gBAAgB,CAACG,OAAO;EACxC,IAAM1C,MAAM,GAAGmC,MAAM,CAACnC,MAAM,GAAG,CAAC;EAEhC,IAAMgM,UAAU,GAAGvJ,KAAK,CAACzC,MAAM,GAAG,CAAC;EACnC,IAAIiM,YAAY,GAAGD,UAAU;EAE7BvJ,KAAK,CAACK,IAAI,CAACX,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;EAEhC,KAAKS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5C,MAAM,EAAE4C,CAAC,EAAE,EAC3B;IACIH,KAAK,CAACK,IAAI,CAACX,MAAM,CAACS,CAAC,GAAG,CAAC,CAAC,EAAET,MAAM,CAAES,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC,CAAC;IAC9CF,OAAO,CAACI,IAAI,CAACmJ,YAAY,EAAEA,YAAY,GAAG,CAAC,CAAC;IAE5CA,YAAY,EAAE;;EAGlB,IAAIjD,WAAW,EACf;IACItG,OAAO,CAACI,IAAI,CAACmJ,YAAY,EAAED,UAAU,CAAC;;;;;;;;;;;;;AAc9C,SAAgBE,SAASA,CAAChK,YAA0B,EAAEK,gBAAkC;EAEpF,IAAIL,YAAY,CAAC0G,SAAS,CAACuD,MAAM,EACjC;IACIJ,eAAe,CAAC7J,YAAY,EAAEK,gBAAgB,CAAC;GAClD,MAED;IACIiG,kBAAkB,CAACtG,YAAY,EAAEK,gBAAgB,CAAC;;;;;;;;;;;;;;;;;;AChhB1D,IAAA6J,IAAA,0BAAAC,MAAA;EAA0BzK,SAAA,CAAAwK,IAAA,EAAAC,MAAA;EAEtB,SAAAD,KAAY/I,CAAS,EAAEC,CAAS,EAAEnB,MAAc,EAAEyB,MAAc,EAAE0I,WAAmB,EAAEC,QAAY;IAAZ,IAAAA,QAAA;MAAAA,QAAA,IAAY;IAAA;IAAnG,IAAAC,KAAA;IAEIF,WAAW,GAAGA,WAAW,IAAI1I,MAAM,GAAG,CAAC;IAEvC,IAAMqE,UAAU,GAAI,CAAC,CAAC,GAAG7H,IAAI,CAAC8D,EAAE,GAAG,CAAC,GAAIqI,QAAQ;IAChD,IAAME,GAAG,GAAGtK,MAAM,GAAG,CAAC;IACtB,IAAMuK,KAAK,GAAGC,IAAI,GAAGF,GAAG;IACxB,IAAMG,OAAO,GAAG,EAAE;IAElB,KAAK,IAAIhK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6J,GAAG,EAAE7J,CAAC,EAAE,EAC5B;MACI,IAAMiK,CAAC,GAAGjK,CAAC,GAAG,CAAC,GAAG0J,WAAW,GAAG1I,MAAM;MACtC,IAAM2E,KAAK,GAAI3F,CAAC,GAAG8J,KAAK,GAAIzE,UAAU;MAEtC2E,OAAO,CAAC9J,IAAI,CACRO,CAAC,GAAIwJ,CAAC,GAAGzM,IAAI,CAACgE,GAAG,CAACmE,KAAK,CAAE,EACzBjF,CAAC,GAAIuJ,CAAC,GAAGzM,IAAI,CAAC+D,GAAG,CAACoE,KAAK,CAAE,CAC5B;;IAGLiE,KAAA,GAAAH,MAAA,CAAAS,IAAA,OAAMF,OAAO,CAAC;;;EAEtB,OAAAR,IAAC;CAxBD,CAA0BW,OAAO;;;;;;;ACCjC,IAAAC,QAAA;EAAA,SAAAA,SAAA,G;;;;;;;;;;;;;;EAeWA,QAAA,CAAAC,OAAO,GAAd,UAAejD,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEvG,MAAc,EAAEzB,MAAqB;IAEhG,IAAMgD,KAAK,GAAGhD,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;IACvC,IAAMoF,KAAK,GAAGjD,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;IAEvC,IAAMkN,EAAE,GAAG9H,KAAK,GAAG6E,EAAE;IACrB,IAAMkD,EAAE,GAAGhI,KAAK,GAAG6E,EAAE;IACrB,IAAMoD,EAAE,GAAGjD,EAAE,GAAGF,EAAE;IAClB,IAAMoD,EAAE,GAAGnD,EAAE,GAAGF,EAAE;IAClB,IAAMsD,EAAE,GAAGlN,IAAI,CAACgI,GAAG,CAAE8E,EAAE,GAAGG,EAAE,GAAKF,EAAE,GAAGC,EAAG,CAAC;IAE1C,IAAIE,EAAE,GAAG,MAAM,IAAI1J,MAAM,KAAK,CAAC,EAC/B;MACI,IAAIzB,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC,KAAKgK,EAAE,IAAI7H,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC,KAAKiK,EAAE,EACxE;QACI9H,MAAM,CAACW,IAAI,CAACkH,EAAE,EAAEC,EAAE,CAAC;;MAGvB,OAAO,IAAI;;IAGf,IAAMsD,EAAE,GAAIL,EAAE,GAAGA,EAAE,GAAKC,EAAE,GAAGA,EAAG;IAChC,IAAMK,EAAE,GAAIJ,EAAE,GAAGA,EAAE,GAAKC,EAAE,GAAGA,EAAG;IAChC,IAAMI,EAAE,GAAIP,EAAE,GAAGE,EAAE,GAAKD,EAAE,GAAGE,EAAG;IAChC,IAAMK,EAAE,GAAG9J,MAAM,GAAGxD,IAAI,CAAC4D,IAAI,CAACuJ,EAAE,CAAC,GAAGD,EAAE;IACtC,IAAMK,EAAE,GAAG/J,MAAM,GAAGxD,IAAI,CAAC4D,IAAI,CAACwJ,EAAE,CAAC,GAAGF,EAAE;IACtC,IAAMM,EAAE,GAAGF,EAAE,GAAGD,EAAE,GAAGF,EAAE;IACvB,IAAMM,EAAE,GAAGF,EAAE,GAAGF,EAAE,GAAGD,EAAE;IACvB,IAAMlG,EAAE,GAAIoG,EAAE,GAAGL,EAAE,GAAKM,EAAE,GAAGR,EAAG;IAChC,IAAM5F,EAAE,GAAImG,EAAE,GAAGN,EAAE,GAAKO,EAAE,GAAGT,EAAG;IAChC,IAAM7B,EAAE,GAAG8B,EAAE,IAAIQ,EAAE,GAAGC,EAAE,CAAC;IACzB,IAAMtC,EAAE,GAAG4B,EAAE,IAAIS,EAAE,GAAGC,EAAE,CAAC;IACzB,IAAME,EAAE,GAAGT,EAAE,IAAIK,EAAE,GAAGG,EAAE,CAAC;IACzB,IAAME,EAAE,GAAGX,EAAE,IAAIM,EAAE,GAAGG,EAAE,CAAC;IACzB,IAAM5F,UAAU,GAAG7H,IAAI,CAAC2H,KAAK,CAACuD,EAAE,GAAG/D,EAAE,EAAE8D,EAAE,GAAG/D,EAAE,CAAC;IAC/C,IAAM0G,QAAQ,GAAG5N,IAAI,CAAC2H,KAAK,CAACgG,EAAE,GAAGxG,EAAE,EAAEuG,EAAE,GAAGxG,EAAE,CAAC;IAE7C,OAAO;MACHA,EAAE,EAAGA,EAAE,GAAG0C,EAAG;MACbzC,EAAE,EAAGA,EAAE,GAAG0C,EAAG;MACbrG,MAAM,EAAAA,MAAA;MACNqE,UAAU,EAAAA,UAAA;MACV+F,QAAQ,EAAAA,QAAA;MACRC,aAAa,EAAGd,EAAE,GAAGC,EAAE,GAAGC,EAAE,GAAGH;KAClC;GACJ;;;;;;;;;;;;;;;;;;;EAoBMF,QAAA,CAAAkB,GAAG,GAAV,UAAWC,OAAe,EAAEC,OAAe,EAAE9G,EAAU,EAAEC,EAAU,EAAE3D,MAAc,EAC/EqE,UAAkB,EAAE+F,QAAgB,EAAEK,cAAuB,EAAElM,MAAqB;IAEpF,IAAMmM,KAAK,GAAGN,QAAQ,GAAG/F,UAAU;IACnC,IAAMvC,CAAC,GAAGjG,eAAe,CAACM,cAAc,CACpCK,IAAI,CAACgI,GAAG,CAACkG,KAAK,CAAC,GAAG1K,MAAM,EACxBxD,IAAI,CAACC,IAAI,CAACD,IAAI,CAACgI,GAAG,CAACkG,KAAK,CAAC,GAAG3B,IAAI,CAAC,GAAG,EAAE,CACzC;IAED,IAAM4B,KAAK,GAAID,KAAK,IAAK5I,CAAC,GAAG,CAAC,CAAC;IAC/B,IAAM8I,MAAM,GAAGD,KAAK,GAAG,CAAC;IACxB,IAAME,MAAM,GAAGrO,IAAI,CAACgE,GAAG,CAACmK,KAAK,CAAC;IAC9B,IAAMG,MAAM,GAAGtO,IAAI,CAAC+D,GAAG,CAACoK,KAAK,CAAC;IAC9B,IAAMI,QAAQ,GAAGjJ,CAAC,GAAG,CAAC;IACtB,IAAMkJ,SAAS,GAAID,QAAQ,GAAG,CAAC,GAAIA,QAAQ;IAE3C,KAAK,IAAI/L,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI+L,QAAQ,EAAE,EAAE/L,CAAC,EAClC;MACI,IAAMiM,IAAI,GAAGjM,CAAC,GAAIgM,SAAS,GAAGhM,CAAE;MAChC,IAAM2F,KAAK,GAAKgG,KAAK,GAAItG,UAAU,GAAIuG,MAAM,GAAGK,IAAM;MACtD,IAAMrK,CAAC,GAAGpE,IAAI,CAACgE,GAAG,CAACmE,KAAK,CAAC;MACzB,IAAMuG,CAAC,GAAG,CAAC1O,IAAI,CAAC+D,GAAG,CAACoE,KAAK,CAAC;MAE1BpG,MAAM,CAACW,IAAI,CACN,CAAE2L,MAAM,GAAGjK,CAAC,GAAKkK,MAAM,GAAGI,CAAE,IAAIlL,MAAM,GAAI0D,EAAE,EAC5C,CAAEmH,MAAM,GAAG,CAACK,CAAC,GAAKJ,MAAM,GAAGlK,CAAE,IAAIZ,MAAM,GAAI2D,EAAE,CACjD;;GAER;EAEL,OAAAyF,QAAC;CAAA;;;;;;;ACxHD,IAAA+B,WAAA;EAAA,SAAAA,YAAA,G;;;;;;;;;;;;;;;;;EAkBWA,WAAA,CAAAC,WAAW,GAAlB,UACI7J,KAAa,EAAEC,KAAa,EAC5BC,GAAW,EAAEC,GAAW,EACxB2J,IAAY,EAAEC,IAAY,EAC1B3J,GAAW,EAAEC,GAAW;IAExB,IAAME,CAAC,GAAG,EAAE;IACZ,IAAIvF,MAAM,GAAG,GAAG;IAChB,IAAIgP,CAAC,GAAG,GAAG;IACX,IAAIC,EAAE,GAAG,GAAG;IACZ,IAAIC,EAAE,GAAG,GAAG;IACZ,IAAIC,EAAE,GAAG,GAAG;IACZ,IAAIC,GAAG,GAAG,GAAG;IACb,IAAIC,GAAG,GAAG,GAAG;IACb,IAAInM,CAAC,GAAG,GAAG;IACX,IAAIC,CAAC,GAAG,GAAG;IACX,IAAImM,EAAE,GAAG,GAAG;IACZ,IAAIC,EAAE,GAAG,GAAG;IACZ,IAAIC,KAAK,GAAGxK,KAAK;IACjB,IAAIyK,KAAK,GAAGxK,KAAK;IAEjB,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI8C,CAAC,EAAE,EAAE9C,CAAC,EAC3B;MACIuM,CAAC,GAAGvM,CAAC,GAAG8C,CAAC;MACT0J,EAAE,GAAGD,CAAC,GAAGA,CAAC;MACVE,EAAE,GAAGD,EAAE,GAAGD,CAAC;MACXG,EAAE,GAAI,GAAG,GAAGH,CAAE;MACdI,GAAG,GAAGD,EAAE,GAAGA,EAAE;MACbE,GAAG,GAAGD,GAAG,GAAGD,EAAE;MAEdjM,CAAC,GAAImM,GAAG,GAAGrK,KAAK,GAAK,GAAG,GAAGoK,GAAG,GAAGJ,CAAC,GAAG9J,GAAI,GAAI,GAAG,GAAGiK,EAAE,GAAGF,EAAE,GAAGH,IAAK,GAAII,EAAE,GAAG9J,GAAI;MAC/EjC,CAAC,GAAIkM,GAAG,GAAGpK,KAAK,GAAK,GAAG,GAAGmK,GAAG,GAAGJ,CAAC,GAAG7J,GAAI,GAAI,CAAC,GAAGgK,EAAE,GAAGF,EAAE,GAAGF,IAAK,GAAIG,EAAE,GAAG7J,GAAI;MAC7EiK,EAAE,GAAGE,KAAK,GAAGtM,CAAC;MACdqM,EAAE,GAAGE,KAAK,GAAGtM,CAAC;MACdqM,KAAK,GAAGtM,CAAC;MACTuM,KAAK,GAAGtM,CAAC;MAETnD,MAAM,IAAIC,IAAI,CAAC4D,IAAI,CAAEyL,EAAE,GAAGA,EAAE,GAAKC,EAAE,GAAGA,EAAG,CAAC;;IAG9C,OAAOvP,MAAM;GAChB;;;;;;;;;;;;;;;EAgBM4O,WAAA,CAAA9B,OAAO,GAAd,UACI5H,GAAW,EAAEC,GAAW,EACxB2J,IAAY,EAAEC,IAAY,EAC1B3J,GAAW,EAAEC,GAAW,EACxBrD,MAAqB;IAErB,IAAMgD,KAAK,GAAGhD,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;IACvC,IAAMoF,KAAK,GAAGjD,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;IAEvCmC,MAAM,CAACnC,MAAM,IAAI,CAAC;IAElB,IAAM0F,CAAC,GAAGjG,eAAe,CAACM,cAAc,CACpCgP,WAAW,CAACC,WAAW,CAAC7J,KAAK,EAAEC,KAAK,EAAEC,GAAG,EAAEC,GAAG,EAAE2J,IAAI,EAAEC,IAAI,EAAE3J,GAAG,EAAEC,GAAG,CAAC,CACxE;IAED,IAAIqK,EAAE,GAAG,CAAC;IACV,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIX,EAAE,GAAG,CAAC;IACV,IAAIC,EAAE,GAAG,CAAC;IAEVlN,MAAM,CAACW,IAAI,CAACqC,KAAK,EAAEC,KAAK,CAAC;IAEzB,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEmD,CAAC,GAAG,CAAC,EAAEnD,CAAC,IAAI8C,CAAC,EAAE,EAAE9C,CAAC,EAClC;MACImD,CAAC,GAAGnD,CAAC,GAAG8C,CAAC;MAETmK,EAAE,GAAI,CAAC,GAAG9J,CAAE;MACZ+J,GAAG,GAAGD,EAAE,GAAGA,EAAE;MACbE,GAAG,GAAGD,GAAG,GAAGD,EAAE;MAEdT,EAAE,GAAGrJ,CAAC,GAAGA,CAAC;MACVsJ,EAAE,GAAGD,EAAE,GAAGrJ,CAAC;MAEX5D,MAAM,CAACW,IAAI,CACNiN,GAAG,GAAG5K,KAAK,GAAK,CAAC,GAAG2K,GAAG,GAAG/J,CAAC,GAAGV,GAAI,GAAI,CAAC,GAAGwK,EAAE,GAAGT,EAAE,GAAGH,IAAK,GAAII,EAAE,GAAG9J,GAAI,EACtEwK,GAAG,GAAG3K,KAAK,GAAK,CAAC,GAAG0K,GAAG,GAAG/J,CAAC,GAAGT,GAAI,GAAI,CAAC,GAAGuK,EAAE,GAAGT,EAAE,GAAGF,IAAK,GAAIG,EAAE,GAAG7J,GAAI,CAC1E;;GAER;EACL,OAAAuJ,WAAC;CAAA;;;;;;;ACnHD,IAAAiB,cAAA;EAAA,SAAAA,eAAA,G;;;;;;;;;;;;;;;EAgBWA,cAAA,CAAAhB,WAAW,GAAlB,UACI7J,KAAa,EAAEC,KAAa,EAC5BC,GAAW,EAAEC,GAAW,EACxBC,GAAW,EAAEC,GAAW;IAExB,IAAMyK,EAAE,GAAG9K,KAAK,GAAI,GAAG,GAAGE,GAAI,GAAGE,GAAG;IACpC,IAAM2K,EAAE,GAAG9K,KAAK,GAAI,GAAG,GAAGE,GAAI,GAAGE,GAAG;IACpC,IAAM2K,EAAE,GAAI,GAAG,GAAG9K,GAAG,GAAK,GAAG,GAAGF,KAAM;IACtC,IAAMiL,EAAE,GAAI,GAAG,GAAG9K,GAAG,GAAK,GAAG,GAAGF,KAAM;IACtC,IAAMb,CAAC,GAAG,GAAG,IAAK0L,EAAE,GAAGA,EAAE,GAAKC,EAAE,GAAGA,EAAG,CAAC;IACvC,IAAM7O,CAAC,GAAG,GAAG,IAAK4O,EAAE,GAAGE,EAAE,GAAKD,EAAE,GAAGE,EAAG,CAAC;IACvC,IAAM5L,CAAC,GAAI2L,EAAE,GAAGA,EAAE,GAAKC,EAAE,GAAGA,EAAG;IAE/B,IAAMtB,CAAC,GAAG,GAAG,GAAG1O,IAAI,CAAC4D,IAAI,CAACO,CAAC,GAAGlD,CAAC,GAAGmD,CAAC,CAAC;IACpC,IAAM4I,EAAE,GAAGhN,IAAI,CAAC4D,IAAI,CAACO,CAAC,CAAC;IACvB,IAAM8L,GAAG,GAAG,GAAG,GAAG9L,CAAC,GAAG6I,EAAE;IACxB,IAAMhC,EAAE,GAAG,GAAG,GAAGhL,IAAI,CAAC4D,IAAI,CAACQ,CAAC,CAAC;IAC7B,IAAM8L,EAAE,GAAGjP,CAAC,GAAG+L,EAAE;IAEjB,OAAO,CACFiD,GAAG,GAAGvB,CAAC,GACD1B,EAAE,GAAG/L,CAAC,IAAIyN,CAAC,GAAG1D,EAAE,CAAE,GAEjB,CAAE,GAAG,GAAG5G,CAAC,GAAGD,CAAC,GAAKlD,CAAC,GAAGA,CAAE,IACvBjB,IAAI,CAACmQ,GAAG,CAAC,CAAE,GAAG,GAAGnD,EAAE,GAAIkD,EAAE,GAAGxB,CAAC,KAAKwB,EAAE,GAAGlF,EAAE,CAAC,CAC9C,KACJ,GAAG,GAAGiF,GAAG,CAAC;GAClB;;;;;;;;;;;;EAaML,cAAA,CAAA/C,OAAO,GAAd,UAAe5H,GAAW,EAAEC,GAAW,EAAEC,GAAW,EAAEC,GAAW,EAAErD,MAAqB;IAEpF,IAAMgD,KAAK,GAAGhD,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;IACvC,IAAMoF,KAAK,GAAGjD,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;IAEvC,IAAM0F,CAAC,GAAGjG,eAAe,CAACM,cAAc,CACpCiQ,cAAc,CAAChB,WAAW,CAAC7J,KAAK,EAAEC,KAAK,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC,CAC/D;IAED,IAAIG,EAAE,GAAG,CAAC;IACV,IAAIC,EAAE,GAAG,CAAC;IAEV,KAAK,IAAIhD,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI8C,CAAC,EAAE,EAAE9C,CAAC,EAC3B;MACI,IAAMmD,CAAC,GAAGnD,CAAC,GAAG8C,CAAC;MAEfC,EAAE,GAAGR,KAAK,GAAI,CAACE,GAAG,GAAGF,KAAK,IAAIY,CAAE;MAChCH,EAAE,GAAGR,KAAK,GAAI,CAACE,GAAG,GAAGF,KAAK,IAAIW,CAAE;MAEhC5D,MAAM,CAACW,IAAI,CAAC6C,EAAE,GAAI,CAAEN,GAAG,GAAI,CAACE,GAAG,GAAGF,GAAG,IAAIU,CAAE,GAAIJ,EAAE,IAAII,CAAE,EACnDH,EAAE,GAAI,CAAEN,GAAG,GAAI,CAACE,GAAG,GAAGF,GAAG,IAAIS,CAAE,GAAIH,EAAE,IAAIG,CAAE,CAAC;;GAEvD;EACL,OAAAiK,cAAC;CAAA;;ACnFD;;;;;AAKA,IAAAQ,SAAA;EAQI,SAAAA,UAAA;IAEI,IAAI,CAAC1P,KAAK,EAAE;;;;;;;;;EAUT0P,SAAA,CAAAzP,SAAA,CAAA0P,KAAK,GAAZ,UAAa9H,KAA4B,EAAEqD,UAAkB,EAAE0E,WAAmB;IAE9E,IAAI,CAAC5P,KAAK,EAAE;IACZ,IAAI,CAAC6H,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACgI,KAAK,GAAG3E,UAAU;IACvB,IAAI,CAAC0E,WAAW,GAAGA,WAAW;GACjC;;;;;;;EAQMF,SAAA,CAAAzP,SAAA,CAAA6P,GAAG,GAAV,UAAWC,QAAgB,EAAEC,SAAiB;IAE1C,IAAI,CAACC,UAAU,GAAGD,SAAS,GAAG,IAAI,CAACJ,WAAW;IAC9C,IAAI,CAACM,IAAI,GAAGH,QAAQ,GAAG,IAAI,CAACF,KAAK;GACpC;EAEMH,SAAA,CAAAzP,SAAA,CAAAD,KAAK,GAAZ;IAEI,IAAI,CAAC6H,KAAK,GAAG,IAAI;IACjB,IAAI,CAACqI,IAAI,GAAG,CAAC;IACb,IAAI,CAACL,KAAK,GAAG,CAAC;IACd,IAAI,CAACD,WAAW,GAAG,CAAC;IACpB,IAAI,CAACK,UAAU,GAAG,CAAC;GACtB;EACL,OAAAP,SAAC;CAAA;;ACxDD;;;;;;;AAOA;;;;;;AA+BA,IAAaS,aAAa,IAAAC,EAAA,OACtBA,EAAA,CAACxN,MAAM,CAACuF,IAAI,IAAGjH,SAAS,EACxBkP,EAAA,CAACxN,MAAM,CAACC,IAAI,IAAGR,WAAW,EAC1B+N,EAAA,CAACxN,MAAM,CAACyN,IAAI,IAAGhO,WAAW,EAC1B+N,EAAA,CAACxN,MAAM,CAAC0N,IAAI,IAAGzM,cAAc,EAC7BuM,EAAA,CAACxN,MAAM,CAAC2N,IAAI,IAAGrL,qBAAqB,E,GACvC;;;;;;;AAQD,IAAasL,UAAU,GAAqB,EAAE;;;;;;;AAQ9C,IAAaC,cAAc,GAAyB,EAAE;;;;;;;;;;;;;;;;;ACxDtD;;;;;;AAMA,IAAAC,YAAA;;;;;;;;EAgBI,SAAAA,aAAYpP,KAAa,EAAEqP,SAA2B,EAAE7I,SAA2B,EAAEhI,MAAqB;IAA/E,IAAA6Q,SAAA;MAAAA,SAAA,OAA2B;IAAA;IAAE,IAAA7I,SAAA;MAAAA,SAAA,OAA2B;IAAA;IAAE,IAAAhI,MAAA;MAAAA,MAAA,OAAqB;IAAA;;;;;IAMtG,IAAI,CAACwB,KAAK,GAAGA,KAAK;;;;;IAMlB,IAAI,CAACwG,SAAS,GAAGA,SAAS;;;;;IAM1B,IAAI,CAAC6I,SAAS,GAAGA,SAAS;;;;;IAM1B,IAAI,CAAC7Q,MAAM,GAAGA,MAAM;;;;;IAMpB,IAAI,CAAC6C,IAAI,GAAGrB,KAAK,CAACqB,IAAI;;;;;IAMtB,IAAI,CAACtB,MAAM,GAAG,EAAE;;;;;IAMhB,IAAI,CAACK,KAAK,GAAG,EAAE;;;;;;;EAQZgP,YAAA,CAAAzQ,SAAA,CAAAC,KAAK,GAAZ;IAEI,OAAO,IAAIwQ,YAAY,CACnB,IAAI,CAACpP,KAAK,EACV,IAAI,CAACqP,SAAS,EACd,IAAI,CAAC7I,SAAS,EACd,IAAI,CAAChI,MAAM,CACd;GACJ;;;;;EAMM4Q,YAAA,CAAAzQ,SAAA,CAAAG,OAAO,GAAd;IAEI,IAAI,CAACkB,KAAK,GAAG,IAAI;IACjB,IAAI,CAACI,KAAK,CAACxC,MAAM,GAAG,CAAC;IACrB,IAAI,CAACwC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACL,MAAM,CAACnC,MAAM,GAAG,CAAC;IACtB,IAAI,CAACmC,MAAM,GAAG,IAAI;IAClB,IAAI,CAACyG,SAAS,GAAG,IAAI;IACrB,IAAI,CAAC6I,SAAS,GAAG,IAAI;GACxB;EACL,OAAAD,YAAC;CAAA;ACnED,IAAME,QAAQ,GAAG,IAAI5I,KAAK,EAAE;AAC5B,IAAM6I,SAAS,GAAG,IAAIC,MAAM,EAAE;;;;;;;;;;;;AAa9B,IAAAC,gBAAA,0BAAAxF,MAAA;EAAsCzK,SAAA,CAAAiQ,gBAAA,EAAAxF,MAAA;EAoClC,SAAAwF,iBAAA;IAAA,IAAArF,KAAA,GAEIH,MAAA,CAAAS,IAAA,MAAO;IAtBXN,KAAA,CAAAsF,UAAU,GAAiB,IAAI;IAC/BtF,KAAA,CAAAuF,aAAa,GAA8B,IAAI;;;;;;;IA6B3CvF,KAAI,CAACrK,MAAM,GAAG,EAAE;;;;;;;IAQhBqK,KAAI,CAACwF,MAAM,GAAG,EAAE;;;;;;;IAQhBxF,KAAI,CAACyF,GAAG,GAAG,EAAE;;;;;;;IAQbzF,KAAI,CAAC9J,OAAO,GAAG,EAAE;;;;;;;IAQjB8J,KAAI,CAAC0F,UAAU,GAAG,EAAE;;;;;;;IAQpB1F,KAAI,CAACtK,YAAY,GAAG,EAAE;;;;;;;IAQtBsK,KAAI,CAAC2F,KAAK,GAAG,CAAC;;;;;;;IAQd3F,KAAI,CAAC4F,UAAU,GAAG,CAAC,CAAC;;;;;;;IAQpB5F,KAAI,CAAC6F,UAAU,GAAG,CAAC,CAAC;;;;;;;;IASpB7F,KAAI,CAAC8F,UAAU,GAAG,CAAC;;;;;;;IAQnB9F,KAAI,CAAC+F,SAAS,GAAG,EAAE;;;;;;;;IASnB/F,KAAI,CAACgG,OAAO,GAAG,EAAE;;;;;;;IAQjBhG,KAAI,CAACiG,UAAU,GAAG,CAAC;;;;;;;IAQnBjG,KAAI,CAACkG,OAAO,GAAG,IAAId,MAAM,EAAE;;;;;;;IAQ3BpF,KAAI,CAACmG,WAAW,GAAG,CAAC,CAAC;;;;;;;IAQrBnG,KAAI,CAACoG,aAAa,GAAG,CAAC;IAEtBpG,KAAI,CAACqG,SAAS,GAAG,KAAK;IAEtBrG,KAAI,CAACuF,aAAa,GAAG,IAAI;IAEzBvF,KAAI,CAACsF,UAAU,GAAG,IAAI;;;;;;;IAQtBtF,KAAI,CAAC9D,aAAa,GAAG,IAAI;;;EAS7BpH,MAAA,CAAAwR,cAAA,CAAWjB,gBAAA,CAAA9Q,SAAA,UAAM;;;;;;;SAAjB,SAAAgS,CAAA;MAEI,IAAI,IAAI,CAACJ,WAAW,KAAK,IAAI,CAACR,KAAK,EACnC;QACI,IAAI,CAACQ,WAAW,GAAG,IAAI,CAACR,KAAK;QAC7B,IAAI,CAACa,eAAe,EAAE;;MAG1B,OAAO,IAAI,CAACN,OAAO;KACtB;;;;;;;;EAMSb,gBAAA,CAAA9Q,SAAA,CAAAkS,UAAU,GAApB;IAEI,IAAI,CAACN,WAAW,GAAG,CAAC,CAAC;IACrB,IAAI,CAACR,KAAK,EAAE;IACZ,IAAI,CAACC,UAAU,EAAE;IACjB,IAAI,CAACK,UAAU,GAAG,CAAC;IAEnB,IAAI,CAACtQ,MAAM,CAACnC,MAAM,GAAG,CAAC;IACtB,IAAI,CAACgS,MAAM,CAAChS,MAAM,GAAG,CAAC;IACtB,IAAI,CAACiS,GAAG,CAACjS,MAAM,GAAG,CAAC;IACnB,IAAI,CAAC0C,OAAO,CAAC1C,MAAM,GAAG,CAAC;IACvB,IAAI,CAACkS,UAAU,CAAClS,MAAM,GAAG,CAAC;IAE1B,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC2P,SAAS,CAACvS,MAAM,EAAE4C,CAAC,EAAE,EAC9C;MACI,IAAI,CAAC2P,SAAS,CAAC3P,CAAC,CAAC,CAACsQ,QAAQ,CAACC,KAAK,EAAE;MAClC5B,cAAc,CAACzO,IAAI,CAAC,IAAI,CAACyP,SAAS,CAAC3P,CAAC,CAAC,CAAC;;IAG1C,IAAI,CAAC2P,SAAS,CAACvS,MAAM,GAAG,CAAC;IAEzB,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4P,OAAO,CAACxS,MAAM,EAAE4C,CAAC,EAAE,EAC5C;MACI,IAAMwQ,SAAS,GAAG,IAAI,CAACZ,OAAO,CAAC5P,CAAC,CAAC;MAEjCwQ,SAAS,CAACtS,KAAK,EAAE;MACjBwQ,UAAU,CAACxO,IAAI,CAACsQ,SAAS,CAAC;;IAG9B,IAAI,CAACZ,OAAO,CAACxS,MAAM,GAAG,CAAC;GAC1B;;;;;;EAOM6R,gBAAA,CAAA9Q,SAAA,CAAAoS,KAAK,GAAZ;IAEI,IAAI,IAAI,CAACjR,YAAY,CAAClC,MAAM,GAAG,CAAC,EAChC;MACI,IAAI,CAACiT,UAAU,EAAE;MACjB,IAAI,CAACX,UAAU,EAAE;MACjB,IAAI,CAACpQ,YAAY,CAAClC,MAAM,GAAG,CAAC;;IAGhC,OAAO,IAAI;GACd;;;;;;;;;;EAWM6R,gBAAA,CAAA9Q,SAAA,CAAAsS,SAAS,GAAhB,UACIjR,KAAa,EACbqP,SAA2B,EAC3B7I,SAA2B,EAC3BhI,MAAqB;IAFrB,IAAA6Q,SAAA;MAAAA,SAAA,OAA2B;IAAA;IAC3B,IAAA7I,SAAA;MAAAA,SAAA,OAA2B;IAAA;IAC3B,IAAAhI,MAAA;MAAAA,MAAA,OAAqB;IAAA;IAErB,IAAM0S,IAAI,GAAG,IAAI9B,YAAY,CAACpP,KAAK,EAAEqP,SAAS,EAAE7I,SAAS,EAAEhI,MAAM,CAAC;IAElE,IAAI,CAACsB,YAAY,CAACY,IAAI,CAACwQ,IAAI,CAAC;IAC5B,IAAI,CAACnB,KAAK,EAAE;IAEZ,OAAO,IAAI;GACd;;;;;;;;EASMN,gBAAA,CAAA9Q,SAAA,CAAAwS,QAAQ,GAAf,UAAgBnR,KAAa,EAAExB,MAAqB;IAArB,IAAAA,MAAA;MAAAA,MAAA,OAAqB;IAAA;IAEhD,IAAI,CAAC,IAAI,CAACsB,YAAY,CAAClC,MAAM,EAC7B;MACI,OAAO,IAAI;;IAGf,IAAMsT,IAAI,GAAG,IAAI9B,YAAY,CAACpP,KAAK,EAAE,IAAI,EAAE,IAAI,EAAExB,MAAM,CAAC;IAExD,IAAM4S,SAAS,GAAG,IAAI,CAACtR,YAAY,CAAC,IAAI,CAACA,YAAY,CAAClC,MAAM,GAAG,CAAC,CAAC;IAEjEsT,IAAI,CAAC1K,SAAS,GAAG4K,SAAS,CAAC5K,SAAS;IAEpC4K,SAAS,CAAChR,KAAK,CAACM,IAAI,CAACwQ,IAAI,CAAC;IAE1B,IAAI,CAACnB,KAAK,EAAE;IAEZ,OAAO,IAAI;GACd;;;;;EAMMN,gBAAA,CAAA9Q,SAAA,CAAAG,OAAO,GAAd;IAEImL,MAAA,CAAAtL,SAAA,CAAMG,OAAO,CAAA4L,IAAA,MAAE;;IAGf,KAAK,IAAIlK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACV,YAAY,CAAClC,MAAM,EAAE,EAAE4C,CAAC,EACjD;MACI,IAAI,CAACV,YAAY,CAACU,CAAC,CAAC,CAAC1B,OAAO,EAAE;;IAGlC,IAAI,CAACiB,MAAM,CAACnC,MAAM,GAAG,CAAC;IACtB,IAAI,CAACmC,MAAM,GAAG,IAAI;IAClB,IAAI,CAAC6P,MAAM,CAAChS,MAAM,GAAG,CAAC;IACtB,IAAI,CAACgS,MAAM,GAAG,IAAI;IAClB,IAAI,CAACC,GAAG,CAACjS,MAAM,GAAG,CAAC;IACnB,IAAI,CAACiS,GAAG,GAAG,IAAI;IACf,IAAI,CAACvP,OAAO,CAAC1C,MAAM,GAAG,CAAC;IACvB,IAAI,CAAC0C,OAAO,GAAG,IAAI;IACnB,IAAI,CAAC+Q,WAAW,CAACvS,OAAO,EAAE;IAC1B,IAAI,CAACuS,WAAW,GAAG,IAAI;IACvB,IAAI,CAACvR,YAAY,CAAClC,MAAM,GAAG,CAAC;IAC5B,IAAI,CAACkC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACqQ,SAAS,CAACvS,MAAM,GAAG,CAAC;IACzB,IAAI,CAACuS,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,OAAO,CAACxS,MAAM,GAAG,CAAC;IACvB,IAAI,CAACwS,OAAO,GAAG,IAAI;IACnB,IAAI,CAACE,OAAO,GAAG,IAAI;GACtB;;;;;;;EAQMb,gBAAA,CAAA9Q,SAAA,CAAA2S,aAAa,GAApB,UAAqBC,KAAiB;IAElC,IAAMzR,YAAY,GAAG,IAAI,CAACA,YAAY;IAEtC,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,YAAY,CAAClC,MAAM,EAAE,EAAE4C,CAAC,EAC5C;MACI,IAAM0Q,IAAI,GAAGpR,YAAY,CAACU,CAAC,CAAC;MAE5B,IAAI,CAAC0Q,IAAI,CAAC7B,SAAS,CAAC5Q,OAAO,EAC3B;QACI;;;MAIJ,IAAIyS,IAAI,CAAClR,KAAK,EACd;QACI,IAAIkR,IAAI,CAAC1S,MAAM,EACf;UACI0S,IAAI,CAAC1S,MAAM,CAACgT,YAAY,CAACD,KAAK,EAAEjC,QAAQ,CAAC;SAC5C,MAED;UACIA,QAAQ,CAACmC,QAAQ,CAACF,KAAK,CAAC;;QAG5B,IAAIL,IAAI,CAAClR,KAAK,CAAC0R,QAAQ,CAACpC,QAAQ,CAACrO,CAAC,EAAEqO,QAAQ,CAACpO,CAAC,CAAC,EAC/C;UACI,IAAIyQ,OAAO,GAAG,KAAK;UAEnB,IAAIT,IAAI,CAAC9Q,KAAK,EACd;YACI,KAAK,IAAIwR,GAAC,GAAG,CAAC,EAAEA,GAAC,GAAGV,IAAI,CAAC9Q,KAAK,CAACxC,MAAM,EAAEgU,GAAC,EAAE,EAC1C;cACI,IAAMnR,IAAI,GAAGyQ,IAAI,CAAC9Q,KAAK,CAACwR,GAAC,CAAC;cAE1B,IAAInR,IAAI,CAACT,KAAK,CAAC0R,QAAQ,CAACpC,QAAQ,CAACrO,CAAC,EAAEqO,QAAQ,CAACpO,CAAC,CAAC,EAC/C;gBACIyQ,OAAO,GAAG,IAAI;gBACd;;;;UAKZ,IAAI,CAACA,OAAO,EACZ;YACI,OAAO,IAAI;;;;;IAM3B,OAAO,KAAK;GACf;;;;;;;EAQDlC,gBAAA,CAAA9Q,SAAA,CAAAkT,aAAa,GAAb,UAAcC,cAAwB;IAElC,IAAI,CAAC,IAAI,CAAChS,YAAY,CAAClC,MAAM,EAC7B;MACI,IAAI,CAAC6S,SAAS,GAAG,IAAI;MAErB;;IAGJ,IAAI,CAAC,IAAI,CAACsB,gBAAgB,EAAE,EAC5B;MACI;;IAGJ,IAAI,CAAC9B,UAAU,GAAG,IAAI,CAACF,KAAK;IAE5B,IAAMF,GAAG,GAAG,IAAI,CAACA,GAAG;IACpB,IAAM/P,YAAY,GAAG,IAAI,CAACA,YAAY;IAEtC,IAAIkR,SAAS,GAAc,IAAI;IAE/B,IAAIgB,YAAY,GAAG,IAAI;IAEvB,IAAI,IAAI,CAAC5B,OAAO,CAACxS,MAAM,GAAG,CAAC,EAC3B;MACIoT,SAAS,GAAG,IAAI,CAACZ,OAAO,CAAC,IAAI,CAACA,OAAO,CAACxS,MAAM,GAAG,CAAC,CAAC;MACjDoU,YAAY,GAAGhB,SAAS,CAACzK,KAAK;;IAGlC,KAAK,IAAI/F,CAAC,GAAG,IAAI,CAAC6P,UAAU,EAAE7P,CAAC,GAAGV,YAAY,CAAClC,MAAM,EAAE4C,CAAC,EAAE,EAC1D;MACI,IAAI,CAAC6P,UAAU,EAAE;MAEjB,IAAMa,IAAI,GAAGpR,YAAY,CAACU,CAAC,CAAC;MAC5B,IAAM6O,SAAS,GAAG6B,IAAI,CAAC7B,SAAS;MAChC,IAAM7I,SAAS,GAAG0K,IAAI,CAAC1K,SAAS;MAChC,IAAMyL,OAAO,GAAGpD,aAAa,CAACqC,IAAI,CAAC7P,IAAI,CAAC;;MAGxC4Q,OAAO,CAACpS,KAAK,CAACqR,IAAI,CAAC;MAEnB,IAAIA,IAAI,CAAC1S,MAAM,EACf;QACI,IAAI,CAAC0T,eAAe,CAAChB,IAAI,CAACnR,MAAM,EAAEmR,IAAI,CAAC1S,MAAM,CAAC;;MAGlD,KAAK,IAAImF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAC1B;QACI,IAAM4C,KAAK,GAAI5C,CAAC,KAAK,CAAC,GAAI0L,SAAS,GAAG7I,SAAS;QAE/C,IAAI,CAACD,KAAK,CAAC9H,OAAO,E;UAAE;QAAA;QAEpB,IAAM0T,WAAW,GAAG5L,KAAK,CAAClI,OAAO,CAAC+T,WAAW;QAC7C,IAAMC,OAAK,GAAG,IAAI,CAAC/R,OAAO,CAAC1C,MAAM;QACjC,IAAM0U,WAAW,GAAG,IAAI,CAACvS,MAAM,CAACnC,MAAM,GAAG,CAAC;QAE1CuU,WAAW,CAACI,QAAQ,GAAGC,UAAU,CAACC,MAAM;QAExC,IAAI9O,CAAC,KAAK,CAAC,EACX;UACI,IAAI,CAAC+O,WAAW,CAACxB,IAAI,CAAC;SACzB,MAED;UACI,IAAI,CAACyB,WAAW,CAACzB,IAAI,CAAC;;QAG1B,IAAMtC,IAAI,GAAI,IAAI,CAAC7O,MAAM,CAACnC,MAAM,GAAG,CAAC,GAAI0U,WAAW;QAEnD,IAAI1D,IAAI,KAAK,CAAC,E;UAAE;QAAA;;QAEhB,IAAIoC,SAAS,IAAI,CAAC,IAAI,CAAC4B,cAAc,CAACZ,YAAY,EAAEzL,KAAK,CAAC,EAC1D;UACIyK,SAAS,CAACxC,GAAG,CAAC6D,OAAK,EAAEC,WAAW,CAAC;UACjCtB,SAAS,GAAG,IAAI;;;QAGpB,IAAI,CAACA,SAAS,EACd;UACIA,SAAS,GAAG9B,UAAU,CAAClI,GAAG,EAAE,IAAI,IAAIoH,SAAS,EAAE;UAC/C4C,SAAS,CAAC3C,KAAK,CAAC9H,KAAK,EAAE8L,OAAK,EAAEC,WAAW,CAAC;UAC1C,IAAI,CAAClC,OAAO,CAAC1P,IAAI,CAACsQ,SAAS,CAAC;UAC5BgB,YAAY,GAAGzL,KAAK;;QAGxB,IAAI,CAACsM,MAAM,CAAC,IAAI,CAAC9S,MAAM,EAAE8P,GAAG,EAAEtJ,KAAK,CAAClI,OAAO,EAAEiU,WAAW,EAAE1D,IAAI,EAAErI,KAAK,CAAC/H,MAAM,CAAC;;;IAIrF,IAAMsU,KAAK,GAAG,IAAI,CAACxS,OAAO,CAAC1C,MAAM;IACjC,IAAMmV,MAAM,GAAG,IAAI,CAAChT,MAAM,CAACnC,MAAM,GAAG,CAAC;IAErC,IAAIoT,SAAS,EACb;MACIA,SAAS,CAACxC,GAAG,CAACsE,KAAK,EAAEC,MAAM,CAAC;;IAGhC,IAAI,IAAI,CAAC3C,OAAO,CAACxS,MAAM,KAAK,CAAC,EAC7B;;;MAGI,IAAI,CAAC6S,SAAS,GAAG,IAAI;MAErB;;;IAIJ,IAAI,IAAI,CAACd,aAAa,IAAI,IAAI,CAACrP,OAAO,CAAC1C,MAAM,KAAK,IAAI,CAAC+R,aAAa,CAAC/R,MAAM,EAC3E;MACI,IAAI,CAAC+R,aAAa,CAAC1I,GAAG,CAAC,IAAI,CAAC3G,OAAO,CAAC;KACvC,MAED;MACI,IAAM0S,MAAM,GACND,MAAM,GAAG,MAAM,IAAIjB,cAAc;MAEvC,IAAI,CAACnC,aAAa,GAAGqD,MAAM,GAAG,IAAIC,WAAW,CAAC,IAAI,CAAC3S,OAAO,CAAC,GAAG,IAAI4S,WAAW,CAAC,IAAI,CAAC5S,OAAO,CAAC;;;IAI/F,IAAI,CAACmQ,SAAS,GAAG,IAAI,CAAC0C,WAAW,EAAE;IAEnC,IAAI,IAAI,CAAC1C,SAAS,EAClB;MACI,IAAI,CAAC2C,WAAW,EAAE;KACrB,MAED;MACI,IAAI,CAACC,cAAc,EAAE;;GAE5B;;;;;;;EAQS5D,gBAAA,CAAA9Q,SAAA,CAAAiU,cAAc,GAAxB,UAAyBU,MAA6B,EAAEC,MAA6B;IAEjF,IAAI,CAACD,MAAM,IAAI,CAACC,MAAM,EACtB;MACI,OAAO,KAAK;;IAGhB,IAAID,MAAM,CAACjV,OAAO,CAAC+T,WAAW,KAAKmB,MAAM,CAAClV,OAAO,CAAC+T,WAAW,EAC7D;MACI,OAAO,KAAK;;IAGhB,IAAIkB,MAAM,CAACnV,KAAK,GAAGmV,MAAM,CAAClV,KAAK,KAAKmV,MAAM,CAACpV,KAAK,GAAGoV,MAAM,CAACnV,KAAK,EAC/D;MACI,OAAO,KAAK;;IAGhB,IAAI,CAAC,CAAEkV,MAAoB,CAACvJ,MAAM,KAAK,CAAC,CAAEwJ,MAAoB,CAACxJ,MAAM,EACrE;MACI,OAAO,KAAK;;IAGhB,OAAO,IAAI;GACd;;;;;;EAOS0F,gBAAA,CAAA9Q,SAAA,CAAAoT,gBAAgB,GAA1B;IAEI,IAAI,IAAI,CAAChC,KAAK,KAAK,IAAI,CAACE,UAAU,IAAI,CAAC,IAAI,CAACnQ,YAAY,CAAClC,MAAM,EAC/D;MACI,OAAO,KAAK;;IAGhB,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEgT,CAAC,GAAG,IAAI,CAAC1T,YAAY,CAAClC,MAAM,EAAE4C,CAAC,GAAGgT,CAAC,EAAEhT,CAAC,EAAE,EACxD;MACI,IAAM0Q,IAAI,GAAG,IAAI,CAACpR,YAAY,CAACU,CAAC,CAAC;MACjC,IAAMiT,IAAI,GAAGvC,IAAI,CAAC7B,SAAS;MAC3B,IAAMqE,IAAI,GAAGxC,IAAI,CAAC1K,SAAS;MAE3B,IAAIiN,IAAI,IAAI,CAACA,IAAI,CAACpV,OAAO,CAAC+T,WAAW,CAACuB,KAAK,E;QAAE,OAAO,KAAK;MAAA;MACzD,IAAID,IAAI,IAAI,CAACA,IAAI,CAACrV,OAAO,CAAC+T,WAAW,CAACuB,KAAK,E;QAAE,OAAO,KAAK;MAAA;;IAG7D,OAAO,IAAI;GACd;;;;;;EAOSlE,gBAAA,CAAA9Q,SAAA,CAAAyU,WAAW,GAArB;IAEI,IAAI,CAACpD,UAAU,EAAE;IACjB,IAAI,CAACN,UAAU,GAAG,IAAIkE,YAAY,CAAC,IAAI,CAAC/D,GAAG,CAAC;IAE5C,IAAMO,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5B,KAAK,IAAI5P,CAAC,GAAG,CAAC,EAAEgT,CAAC,GAAGpD,OAAO,CAACxS,MAAM,EAAE4C,CAAC,GAAGgT,CAAC,EAAEhT,CAAC,EAAE,EAC9C;MACI,IAAMqT,KAAK,GAAGzD,OAAO,CAAC5P,CAAC,CAAC;MAExB,KAAK,IAAImD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkQ,KAAK,CAACjF,IAAI,EAAEjL,CAAC,EAAE,EACnC;QACI,IAAMmP,KAAK,GAAGe,KAAK,CAACtF,KAAK,GAAG5K,CAAC;QAE7B,IAAI,CAACgM,aAAa,CAACmD,KAAK,CAAC,GAAG,IAAI,CAACnD,aAAa,CAACmD,KAAK,CAAC,GAAGe,KAAK,CAACvF,WAAW;;;GAGpF;;;;;;;EAQSmB,gBAAA,CAAA9Q,SAAA,CAAAwU,WAAW,GAArB;;IAGI,IAAI,IAAI,CAACpT,MAAM,CAACnC,MAAM,GAAG,MAAM,GAAG,CAAC,EACnC;MACI,OAAO,KAAK;;IAGhB,IAAMwS,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5B,KAAK,IAAI5P,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4P,OAAO,CAACxS,MAAM,EAAE4C,CAAC,EAAE,EACvC;MACI,IAAK4P,OAAO,CAAC5P,CAAC,CAAC,CAAC+F,KAAmB,CAACwD,MAAM,EAC1C;QACI,OAAO,KAAK;;;IAIpB,OAAQ,IAAI,CAAChK,MAAM,CAACnC,MAAM,GAAG6R,gBAAgB,CAACqE,cAAc,GAAG,CAAC;GACnE;;;;;;EAOSrE,gBAAA,CAAA9Q,SAAA,CAAA0U,cAAc,GAAxB;IAEI,IAAIU,IAAI,GAAG,EAAEC,WAAW,CAACC,YAAY;IAErC,KAAK,IAAIzT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC2P,SAAS,CAACvS,MAAM,EAAE4C,CAAC,EAAE,EAC9C;MACI,IAAI,CAAC2P,SAAS,CAAC3P,CAAC,CAAC,CAACsQ,QAAQ,CAACC,KAAK,EAAE;MAClC5B,cAAc,CAACzO,IAAI,CAAC,IAAI,CAACyP,SAAS,CAAC3P,CAAC,CAAC,CAAC;;IAG1C,IAAI,CAAC2P,SAAS,CAACvS,MAAM,GAAG,CAAC;IAEzB,IAAMgS,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAME,UAAU,GAAG,IAAI,CAACA,UAAU;IAElC,IAAIoE,YAAY,GAAmB/E,cAAc,CAACnI,GAAG,EAAE;IAEvD,IAAI,CAACkN,YAAY,EACjB;MACIA,YAAY,GAAG,IAAIC,aAAa,EAAE;MAClCD,YAAY,CAACpD,QAAQ,GAAG,IAAIsD,iBAAiB,EAAE;;IAEnDF,YAAY,CAACpD,QAAQ,CAACuD,KAAK,GAAG,CAAC;IAC/BH,YAAY,CAAC3F,KAAK,GAAG,CAAC;IACtB2F,YAAY,CAACtF,IAAI,GAAG,CAAC;IACrBsF,YAAY,CAAC7S,IAAI,GAAGiT,UAAU,CAACC,SAAS;IAExC,IAAIC,YAAY,GAAG,CAAC;IACpB,IAAIC,cAAc,GAAG,IAAI;IACzB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAI3K,MAAM,GAAG,KAAK;IAClB,IAAI4K,QAAQ,GAAGL,UAAU,CAACC,SAAS;IAEnC,IAAIzB,KAAK,GAAG,CAAC;IAEb,IAAI,CAAC3C,SAAS,CAACzP,IAAI,CAACwT,YAAY,CAAC;;IAGjC,KAAK,IAAI1T,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4P,OAAO,CAACxS,MAAM,EAAE4C,CAAC,EAAE,EAC5C;MACI,IAAM0Q,IAAI,GAAG,IAAI,CAACd,OAAO,CAAC5P,CAAC,CAAC;;MAG5B,IAAMoU,YAAY,GAAG,CAAC;;MAGtB,IAAMrO,KAAK,GAAG2K,IAAI,CAAC3K,KAAkB;MAErC,IAAM4L,WAAW,GAAG5L,KAAK,CAAClI,OAAO,CAAC+T,WAAW;MAE7C,IAAIrI,MAAM,KAAK,CAAC,CAACxD,KAAK,CAACwD,MAAM,EAC7B;QACIA,MAAM,GAAG,CAAC,CAACxD,KAAK,CAACwD,MAAM;QACvB4K,QAAQ,GAAG5K,MAAM,GAAGuK,UAAU,CAACO,KAAK,GAAGP,UAAU,CAACC,SAAS;;QAG3DE,cAAc,GAAG,IAAI;QACrBD,YAAY,GAAGI,YAAY;QAC3Bb,IAAI,EAAE;;MAGV,IAAIU,cAAc,KAAKtC,WAAW,EAClC;QACIsC,cAAc,GAAGtC,WAAW;QAE5B,IAAIA,WAAW,CAAC2C,aAAa,KAAKf,IAAI,EACtC;UACI,IAAIS,YAAY,KAAKI,YAAY,EACjC;YACIb,IAAI,EAAE;YAENS,YAAY,GAAG,CAAC;YAEhB,IAAIN,YAAY,CAACtF,IAAI,GAAG,CAAC,EACzB;cACIsF,YAAY,GAAG/E,cAAc,CAACnI,GAAG,EAAE;cACnC,IAAI,CAACkN,YAAY,EACjB;gBACIA,YAAY,GAAG,IAAIC,aAAa,EAAE;gBAClCD,YAAY,CAACpD,QAAQ,GAAG,IAAIsD,iBAAiB,EAAE;;cAEnD,IAAI,CAACjE,SAAS,CAACzP,IAAI,CAACwT,YAAY,CAAC;;YAGrCA,YAAY,CAAC3F,KAAK,GAAGuE,KAAK;YAC1BoB,YAAY,CAACtF,IAAI,GAAG,CAAC;YACrBsF,YAAY,CAACpD,QAAQ,CAACuD,KAAK,GAAG,CAAC;YAC/BH,YAAY,CAAC7S,IAAI,GAAGsT,QAAQ;;;;UAKhCxC,WAAW,CAAC4C,OAAO,GAAG,CAAC,CAAC;UAExB5C,WAAW,CAAC2C,aAAa,GAAGf,IAAI;UAChC5B,WAAW,CAAC6C,cAAc,GAAGR,YAAY;UACzCrC,WAAW,CAACI,QAAQ,GAAG,KAAK;UAE5B2B,YAAY,CAACpD,QAAQ,CAACmE,QAAQ,CAACf,YAAY,CAACpD,QAAQ,CAACuD,KAAK,EAAE,CAAC,GAAGlC,WAAW;UAC3EqC,YAAY,EAAE;;;MAItBN,YAAY,CAACtF,IAAI,IAAIsC,IAAI,CAACtC,IAAI;MAC9BkE,KAAK,IAAI5B,IAAI,CAACtC,IAAI;MAElB8F,SAAS,GAAGvC,WAAW,CAAC6C,cAAc;MAEtC,IAAI,CAACE,SAAS,CAACtF,MAAM,EAAErJ,KAAK,CAACpI,KAAK,EAAEoI,KAAK,CAACnI,KAAK,EAAE8S,IAAI,CAACvC,UAAU,CAAC;MACjE,IAAI,CAACwG,aAAa,CAACrF,UAAU,EAAE4E,SAAS,EAAExD,IAAI,CAACvC,UAAU,CAAC;;IAG9DqF,WAAW,CAACC,YAAY,GAAGF,IAAI;;;IAI/B,IAAI,CAACqB,cAAc,EAAE;GACxB;;;;;;EAOS3F,gBAAA,CAAA9Q,SAAA,CAAAyW,cAAc,GAAxB;IAEI,IAAM/U,KAAK,GAAG,IAAI,CAACN,MAAM;IACzB,IAAM8P,GAAG,GAAG,IAAI,CAACA,GAAG;IACpB,IAAMD,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,IAAME,UAAU,GAAG,IAAI,CAACA,UAAU;;IAGlC,IAAMuF,QAAQ,GAAG,IAAIC,WAAW,CAACjV,KAAK,CAACzC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;IACtD,IAAM2X,GAAG,GAAG,IAAI3B,YAAY,CAACyB,QAAQ,CAAC;IACtC,IAAMG,GAAG,GAAG,IAAIvC,WAAW,CAACoC,QAAQ,CAAC;IAErC,IAAI/V,CAAC,GAAG,CAAC;IAET,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACzC,MAAM,GAAG,CAAC,EAAE4C,CAAC,EAAE,EACzC;MACI+U,GAAG,CAACjW,CAAC,EAAE,CAAC,GAAGe,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC;MACvB+U,GAAG,CAACjW,CAAC,EAAE,CAAC,GAAGe,KAAK,CAAEG,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC;MAE7B+U,GAAG,CAACjW,CAAC,EAAE,CAAC,GAAGuQ,GAAG,CAACrP,CAAC,GAAG,CAAC,CAAC;MACrB+U,GAAG,CAACjW,CAAC,EAAE,CAAC,GAAGuQ,GAAG,CAAErP,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC;MAE3BgV,GAAG,CAAClW,CAAC,EAAE,CAAC,GAAGsQ,MAAM,CAACpP,CAAC,CAAC;MAEpB+U,GAAG,CAACjW,CAAC,EAAE,CAAC,GAAGwQ,UAAU,CAACtP,CAAC,CAAC;;IAG5B,IAAI,CAACiV,OAAO,CAACC,MAAM,CAACL,QAAQ,CAAC;IAC7B,IAAI,CAACM,YAAY,CAACD,MAAM,CAAC,IAAI,CAAC/F,aAAa,CAAC;GAC/C;;;;;;;EAQSF,gBAAA,CAAA9Q,SAAA,CAAA+T,WAAW,GAArB,UAAsBxB,IAAkB;IAEpC,IAAIA,IAAI,CAAC9Q,KAAK,CAACxC,MAAM,EACrB;MACI,IAAI,CAACgY,YAAY,CAAC1E,IAAI,CAAC9Q,KAAK,CAAC;MAE7BR,SAAS,CAACM,WAAW,CAACgR,IAAI,EAAE,IAAI,CAAC;KACpC,MAED;MACI,IAAMe,OAAO,GAAGpD,aAAa,CAACqC,IAAI,CAAC7P,IAAI,CAAC;MAExC4Q,OAAO,CAAC/R,WAAW,CAACgR,IAAI,EAAE,IAAI,CAAC;;GAEtC;;;;;;;EAQSzB,gBAAA,CAAA9Q,SAAA,CAAAgU,WAAW,GAArB,UAAsBzB,IAAkB;IAEpCpH,SAAS,CAACoH,IAAI,EAAE,IAAI,CAAC;IAErB,KAAK,IAAI1Q,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0Q,IAAI,CAAC9Q,KAAK,CAACxC,MAAM,EAAE4C,CAAC,EAAE,EAC1C;MACIsJ,SAAS,CAACoH,IAAI,CAAC9Q,KAAK,CAACI,CAAC,CAAC,EAAE,IAAI,CAAC;;GAErC;;;;;;;EAQSiP,gBAAA,CAAA9Q,SAAA,CAAAiX,YAAY,GAAtB,UAAuBxV,KAA0B;IAE7C,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACxC,MAAM,EAAE4C,CAAC,EAAE,EACrC;MACI,IAAMC,IAAI,GAAGL,KAAK,CAACI,CAAC,CAAC;MACrB,IAAMyR,OAAO,GAAGpD,aAAa,CAACpO,IAAI,CAACY,IAAI,CAAC;MAExC4Q,OAAO,CAACpS,KAAK,CAACY,IAAI,CAAC;MAEnB,IAAIA,IAAI,CAACjC,MAAM,EACf;QACI,IAAI,CAAC0T,eAAe,CAACzR,IAAI,CAACV,MAAM,EAAEU,IAAI,CAACjC,MAAM,CAAC;;;GAGzD;;;;;;EAOSiR,gBAAA,CAAA9Q,SAAA,CAAAiS,eAAe,GAAzB;IAEI,IAAMiF,MAAM,GAAG,IAAI,CAACvF,OAAO;IAC3B,IAAMwF,cAAc,GAAGvG,SAAS;IAChC,IAAIwG,SAAS,GAAGC,MAAM,CAACC,QAAQ;IAE/B,IAAI,CAAC3F,OAAO,CAACS,KAAK,EAAE;IACpB+E,cAAc,CAAC/E,KAAK,EAAE;IAEtB,KAAK,IAAIvQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACV,YAAY,CAAClC,MAAM,EAAE4C,CAAC,EAAE,EACjD;MACI,IAAM0Q,IAAI,GAAG,IAAI,CAACpR,YAAY,CAACU,CAAC,CAAC;MACjC,IAAMR,KAAK,GAAGkR,IAAI,CAAClR,KAAK;MACxB,IAAMqB,IAAI,GAAG6P,IAAI,CAAC7P,IAAI;MACtB,IAAMmF,SAAS,GAAG0K,IAAI,CAAC1K,SAAS;MAChC,IAAM0P,UAAU,GAAGhF,IAAI,CAAC1S,MAAM,IAAIwX,MAAM,CAACC,QAAQ;MACjD,IAAIE,SAAS,GAAG,GAAG;MAEnB,IAAI3P,SAAS,IAAIA,SAAS,CAAC/H,OAAO,EAClC;QACI,IAAM6J,SAAS,GAAG9B,SAAS,CAAC8B,SAAS;QAErC6N,SAAS,GAAG3P,SAAS,CAACrF,KAAK;QAE3B,IAAIE,IAAI,KAAKC,MAAM,CAACuF,IAAI,EACxB;UACIsP,SAAS,GAAGA,SAAS,IAAI,GAAG,GAAGnY,IAAI,CAACgI,GAAG,CAAC,GAAG,GAAGsC,SAAS,CAAC,CAAC;SAC5D,MAED;UACI6N,SAAS,GAAGA,SAAS,GAAGnY,IAAI,CAAC8F,GAAG,CAAC,CAAC,EAAEwE,SAAS,CAAC;;;MAItD,IAAIyN,SAAS,KAAKG,UAAU,EAC5B;QACI,IAAI,CAACJ,cAAc,CAACM,OAAO,EAAE,EAC7B;UACIP,MAAM,CAACQ,eAAe,CAACP,cAAc,EAAEC,SAAS,CAAC;UACjDD,cAAc,CAAC/E,KAAK,EAAE;;QAE1BgF,SAAS,GAAGG,UAAU;;MAG1B,IAAI7U,IAAI,KAAKC,MAAM,CAAC0N,IAAI,IAAI3N,IAAI,KAAKC,MAAM,CAAC2N,IAAI,EAChD;QACI,IAAMqH,IAAI,GAAGtW,KAAqC;QAElD8V,cAAc,CAACS,WAAW,CAACD,IAAI,CAACrV,CAAC,EAAEqV,IAAI,CAACpV,CAAC,EAAEoV,IAAI,CAACrV,CAAC,GAAGqV,IAAI,CAACnV,KAAK,EAAEmV,IAAI,CAACpV,CAAC,GAAGoV,IAAI,CAAClV,MAAM,EAChF+U,SAAS,EAAEA,SAAS,CAAC;OAC5B,MACI,IAAI9U,IAAI,KAAKC,MAAM,CAACC,IAAI,EAC7B;QACI,IAAMW,MAAM,GAAGlC,KAAe;QAE9B8V,cAAc,CAACS,WAAW,CAACrU,MAAM,CAACjB,CAAC,EAAEiB,MAAM,CAAChB,CAAC,EAAEgB,MAAM,CAACjB,CAAC,EAAEiB,MAAM,CAAChB,CAAC,EAC7DgB,MAAM,CAACV,MAAM,GAAG2U,SAAS,EAAEjU,MAAM,CAACV,MAAM,GAAG2U,SAAS,CAAC;OAC5D,MACI,IAAI9U,IAAI,KAAKC,MAAM,CAACyN,IAAI,EAC7B;QACI,IAAMyH,OAAO,GAAGxW,KAAgB;QAEhC8V,cAAc,CAACS,WAAW,CAACC,OAAO,CAACvV,CAAC,EAAEuV,OAAO,CAACtV,CAAC,EAAEsV,OAAO,CAACvV,CAAC,EAAEuV,OAAO,CAACtV,CAAC,EACjEsV,OAAO,CAACrV,KAAK,GAAGgV,SAAS,EAAEK,OAAO,CAACpV,MAAM,GAAG+U,SAAS,CAAC;OAC7D,MAED;QACI,IAAMM,IAAI,GAAGzW,KAAgB;;QAG7B6V,MAAM,CAACa,iBAAiB,CAACX,SAAS,EAAGU,IAAI,CAAC1W,MAAc,EAAE,CAAC,EAAE0W,IAAI,CAAC1W,MAAM,CAACnC,MAAM,EAAEuY,SAAS,EAAEA,SAAS,CAAC;;;IAI9G,IAAI,CAACL,cAAc,CAACM,OAAO,EAAE,EAC7B;MACIP,MAAM,CAACQ,eAAe,CAACP,cAAc,EAAEC,SAAS,CAAC;;IAGrDF,MAAM,CAACc,GAAG,CAAC,IAAI,CAACnG,aAAa,EAAE,IAAI,CAACA,aAAa,CAAC;GACrD;;;;;;;;EASSf,gBAAA,CAAA9Q,SAAA,CAAAuT,eAAe,GAAzB,UAA0BnS,MAAqB,EAAEvB,MAAc;IAE3D,KAAK,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,MAAM,CAACnC,MAAM,GAAG,CAAC,EAAE4C,CAAC,EAAE,EAC1C;MACI,IAAMS,CAAC,GAAGlB,MAAM,CAAES,CAAC,GAAG,CAAC,CAAE;MACzB,IAAMU,CAAC,GAAGnB,MAAM,CAAES,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC;MAE7BT,MAAM,CAAES,CAAC,GAAG,CAAC,CAAE,GAAIhC,MAAM,CAAC2D,CAAC,GAAGlB,CAAC,GAAKzC,MAAM,CAAC4D,CAAC,GAAGlB,CAAE,GAAG1C,MAAM,CAAC6D,EAAE;MAC7DtC,MAAM,CAAES,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC,GAAIhC,MAAM,CAACS,CAAC,GAAGgC,CAAC,GAAKzC,MAAM,CAACQ,CAAC,GAAGkC,CAAE,GAAG1C,MAAM,CAAC8D,EAAE;;GAExE;;;;;;;;;;EAWSmN,gBAAA,CAAA9Q,SAAA,CAAAuW,SAAS,GAAnB,UAAoBtF,MAAqB,EAAEzR,KAAa,EAAEC,KAAa,EAAEwQ,IAAY;;IAGjF,IAAMgI,GAAG,GAAG,CAACzY,KAAK,IAAI,EAAE,KAAKA,KAAK,GAAG,MAAM,CAAC,IAAI,CAACA,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;IAErE,IAAM0Y,IAAI,GAAIC,eAAe,CAACF,GAAG,EAAExY,KAAK,CAAC;IAEzC,OAAOwQ,IAAI,EAAE,GAAG,CAAC,EACjB;MACIgB,MAAM,CAAClP,IAAI,CAACmW,IAAI,CAAC;;GAExB;;;;;;;;;EAUSpH,gBAAA,CAAA9Q,SAAA,CAAAwW,aAAa,GAAvB,UAAwBrF,UAAyB,EAAEiH,EAAU,EAAEnI,IAAY;IAEvE,OAAOA,IAAI,EAAE,GAAG,CAAC,EACjB;MACIkB,UAAU,CAACpP,IAAI,CAACqW,EAAE,CAAC;;GAE1B;;;;;;;;;;;;EAaStH,gBAAA,CAAA9Q,SAAA,CAAAkU,MAAM,GAAhB,UACIxS,KAAoB,EACpBwP,GAAkB,EAClBxR,OAAgB,EAChBkQ,KAAa,EAAEK,IACT,EAAEpQ,MACK;IADL,IAAAA,MAAA;MAAAA,MAAA,OACK;IAAA;IAEb,IAAIsU,KAAK,GAAG,CAAC;IACb,IAAMkE,QAAQ,GAAGnH,GAAG,CAACjS,MAAM;IAC3B,IAAMqZ,KAAK,GAAG5Y,OAAO,CAAC4Y,KAAK;IAE3B,OAAOnE,KAAK,GAAGlE,IAAI,EACnB;MACI,IAAI3N,CAAC,GAAGZ,KAAK,CAAC,CAACkO,KAAK,GAAGuE,KAAK,IAAI,CAAC,CAAC;MAClC,IAAI5R,CAAC,GAAGb,KAAK,CAAE,CAACkO,KAAK,GAAGuE,KAAK,IAAI,CAAC,GAAI,CAAC,CAAC;MAExC,IAAItU,MAAM,EACV;QACI,IAAM0F,EAAE,GAAI1F,MAAM,CAAC2D,CAAC,GAAGlB,CAAC,GAAKzC,MAAM,CAAC4D,CAAC,GAAGlB,CAAE,GAAG1C,MAAM,CAAC6D,EAAE;QAEtDnB,CAAC,GAAI1C,MAAM,CAACS,CAAC,GAAGgC,CAAC,GAAKzC,MAAM,CAACQ,CAAC,GAAGkC,CAAE,GAAG1C,MAAM,CAAC8D,EAAE;QAC/CrB,CAAC,GAAGiD,EAAE;;MAGV4O,KAAK,EAAE;MAEPjD,GAAG,CAACnP,IAAI,CAACO,CAAC,GAAGgW,KAAK,CAAC9V,KAAK,EAAED,CAAC,GAAG+V,KAAK,CAAC7V,MAAM,CAAC;;IAG/C,IAAMgR,WAAW,GAAG/T,OAAO,CAAC+T,WAAW;IAEvC,IAAI6E,KAAK,CAAC9V,KAAK,GAAGiR,WAAW,CAACjR,KAAK,IAC5B8V,KAAK,CAAC7V,MAAM,GAAGgR,WAAW,CAAChR,MAAM,EACxC;MACI,IAAI,CAAC8V,SAAS,CAACrH,GAAG,EAAExR,OAAO,EAAE2Y,QAAQ,EAAEpI,IAAI,CAAC;;GAEnD;;;;;;;;;;EAWSa,gBAAA,CAAA9Q,SAAA,CAAAuY,SAAS,GAAnB,UAAoBrH,GAAkB,EAAExR,OAAgB,EAAEkQ,KAAa,EAAEK,IAAY;IAEjF,IAAMwD,WAAW,GAAG/T,OAAO,CAAC+T,WAAW;IACvC,IAAM/L,GAAG,GAAG,IAAI;IAChB,IAAM8Q,MAAM,GAAG5I,KAAK,GAAIK,IAAI,GAAG,CAAE;IACjC,IAAMqI,KAAK,GAAG5Y,OAAO,CAAC4Y,KAAK;IAC3B,IAAMG,MAAM,GAAGH,KAAK,CAAC9V,KAAK,GAAGiR,WAAW,CAACjR,KAAK;IAC9C,IAAMkW,MAAM,GAAGJ,KAAK,CAAC7V,MAAM,GAAGgR,WAAW,CAAChR,MAAM;IAChD,IAAIkW,OAAO,GAAGL,KAAK,CAAChW,CAAC,GAAGgW,KAAK,CAAC9V,KAAK;IACnC,IAAIoW,OAAO,GAAGN,KAAK,CAAC/V,CAAC,GAAG+V,KAAK,CAAC7V,MAAM;IACpC,IAAIoW,IAAI,GAAGxZ,IAAI,CAAC2D,KAAK,CAACkO,GAAG,CAACtB,KAAK,CAAC,GAAGlI,GAAG,CAAC;IACvC,IAAIoR,IAAI,GAAGzZ,IAAI,CAAC2D,KAAK,CAACkO,GAAG,CAACtB,KAAK,GAAG,CAAC,CAAC,GAAGlI,GAAG,CAAC;IAE3C,KAAK,IAAI7F,CAAC,GAAG+N,KAAK,GAAG,CAAC,EAAE/N,CAAC,GAAG2W,MAAM,EAAE3W,CAAC,IAAI,CAAC,EAC1C;MACIgX,IAAI,GAAGxZ,IAAI,CAAC+F,GAAG,CAACyT,IAAI,EAAExZ,IAAI,CAAC2D,KAAK,CAACkO,GAAG,CAACrP,CAAC,CAAC,GAAG6F,GAAG,CAAC,CAAC;MAC/CoR,IAAI,GAAGzZ,IAAI,CAAC+F,GAAG,CAAC0T,IAAI,EAAEzZ,IAAI,CAAC2D,KAAK,CAACkO,GAAG,CAACrP,CAAC,GAAG,CAAC,CAAC,GAAG6F,GAAG,CAAC,CAAC;;IAEvDiR,OAAO,IAAIE,IAAI;IACfD,OAAO,IAAIE,IAAI;IACf,KAAK,IAAIjX,CAAC,GAAG+N,KAAK,EAAE/N,CAAC,GAAG2W,MAAM,EAAE3W,CAAC,IAAI,CAAC,EACtC;MACIqP,GAAG,CAACrP,CAAC,CAAC,GAAG,CAACqP,GAAG,CAACrP,CAAC,CAAC,GAAG8W,OAAO,IAAIF,MAAM;MACpCvH,GAAG,CAACrP,CAAC,GAAG,CAAC,CAAC,GAAG,CAACqP,GAAG,CAACrP,CAAC,GAAG,CAAC,CAAC,GAAG+W,OAAO,IAAIF,MAAM;;GAEnD;;;;;;;;;;EAzjCa5H,gBAAA,CAAAqE,cAAc,GAAG,GAAG;EA0jCtC,OAAArE,gBAAC;CAAA,CArkCqCiI,aAAa;;;;;;;;ACtCnD,IAAAC,SAAA,0BAAA1N,MAAA;EAA+BzK,SAAA,CAAAmY,SAAA,EAAA1N,MAAA;EAA/B,SAAA0N,UAAA;IAAA,IAAAvN,KAAA,GAAAH,MAAA,aAAAA,MAAA,CAAA2N,KAAA,OAAAC,SAAA;;;;;;;IAQWzN,KAAA,CAAAjJ,KAAK,GAAG,CAAC;;;;;;;IAQTiJ,KAAA,CAAA9B,SAAS,GAAG,GAAG;;;;;;;IAQf8B,KAAA,CAAAL,MAAM,GAAG,KAAK;;;;;;;IAQdK,KAAA,CAAA7B,GAAG,GAAGnL,QAAQ,CAAC0a,IAAI;;;;;;;IAQnB1N,KAAA,CAAAZ,IAAI,GAAGrM,SAAS,CAAC4a,KAAK;;;;;;;IAQtB3N,KAAA,CAAA3C,UAAU,GAAG,EAAE;;;;;;;;EAOfkQ,SAAA,CAAAhZ,SAAA,CAAAC,KAAK,GAAZ;IAEI,IAAMC,GAAG,GAAG,IAAI8Y,SAAS,EAAE;IAE3B9Y,GAAG,CAACV,KAAK,GAAG,IAAI,CAACA,KAAK;IACtBU,GAAG,CAACT,KAAK,GAAG,IAAI,CAACA,KAAK;IACtBS,GAAG,CAACR,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1BQ,GAAG,CAACL,MAAM,GAAG,IAAI,CAACA,MAAM;IACxBK,GAAG,CAACJ,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1BI,GAAG,CAACsC,KAAK,GAAG,IAAI,CAACA,KAAK;IACtBtC,GAAG,CAACyJ,SAAS,GAAG,IAAI,CAACA,SAAS;IAC9BzJ,GAAG,CAACkL,MAAM,GAAG,IAAI,CAACA,MAAM;IACxBlL,GAAG,CAAC0J,GAAG,GAAG,IAAI,CAACA,GAAG;IAClB1J,GAAG,CAAC2K,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB3K,GAAG,CAAC4I,UAAU,GAAG,IAAI,CAACA,UAAU;IAEhC,OAAO5I,GAAG;GACb;;;;EAKM8Y,SAAA,CAAAhZ,SAAA,CAAAD,KAAK,GAAZ;IAEIuL,MAAA,CAAAtL,SAAA,CAAMD,KAAK,CAAAgM,IAAA,MAAE;;IAGb,IAAI,CAACvM,KAAK,GAAG,GAAG;IAEhB,IAAI,CAACmK,SAAS,GAAG,GAAG;IACpB,IAAI,CAACnH,KAAK,GAAG,CAAC;IACd,IAAI,CAAC4I,MAAM,GAAG,KAAK;GACtB;EACL,OAAA4N,SAAC;CAxFD,CAA+BzZ,SAAS;ACgDxC,IAAM8Z,IAAI,GAAG,IAAIpE,YAAY,CAAC,CAAC,CAAC;;AAGhC,IAAMqE,eAAe,GAA4B,EAAE;;;;;;;;;;;;;;AAiBnD,IAAAC,QAAA,0BAAAjO,MAAA;EAA8BzK,SAAA,CAAA0Y,QAAA,EAAAjO,MAAA;;;;;EAgD1B,SAAAiO,SAAYC,QAAiC;IAAjC,IAAAA,QAAA;MAAAA,QAAA,OAAiC;IAAA;IAA7C,IAAA/N,KAAA,GAEIH,MAAA,CAAAS,IAAA,MAAO;IAEPN,KAAI,CAACgO,SAAS,GAAGD,QAAQ,IAAI,IAAI1I,gBAAgB,EAAE;IACnDrF,KAAI,CAACgO,SAAS,CAACC,QAAQ,EAAE;;;;;;;IAQzBjO,KAAI,CAACkO,MAAM,GAAG,IAAI;;;;;;;IAQlBlO,KAAI,CAACmO,KAAK,GAAGC,KAAK,CAACC,KAAK,EAAE;;;;;;;IAQ1BrO,KAAI,CAACsO,UAAU,GAAG,IAAIxa,SAAS,EAAE;;;;;;;IAQjCkM,KAAI,CAACuO,UAAU,GAAG,IAAIhB,SAAS,EAAE;;;;;;;IAQjCvN,KAAI,CAACwO,OAAO,GAAG,IAAI;;;;;;;;IASnBxO,KAAI,CAACyO,SAAS,GAAG,KAAK;;;;;;;IAQtBzO,KAAI,CAAC0O,WAAW,GAAG,IAAI;;;;;;;;;;;;;;;;;;;IAqBvB1O,KAAI,CAACgG,OAAO,GAAG,EAAE;;;;;;;;IASjBhG,KAAI,CAAC2O,SAAS,GAAG,CAAC,CAAC;;;;;;;;IASnB3O,KAAI,CAAC4F,UAAU,GAAG,CAAC,CAAC;;;;;;;IAQpB5F,KAAI,CAAC4O,UAAU,GAAG,IAAI;;;;;;;IAQtB5O,KAAI,CAAC6O,UAAU,GAAG,OAAO;IAEzB7O,KAAI,CAAC8O,YAAY,GAAG,CAAC,CAAC;;IAGtB9O,KAAI,CAAC+O,IAAI,GAAG,QAAQ;IACpB/O,KAAI,CAACgP,SAAS,GAAGC,WAAW,CAACC,MAAM;;;EApIvCpa,MAAA,CAAAwR,cAAA,CAAWwH,QAAA,CAAAvZ,SAAA,YAAQ;;;;;;;;;SAAnB,SAAAgS,CAAA;MAEI,OAAO,IAAI,CAACyH,SAAS;KACxB;;;;;;;;;;EA0IMF,QAAA,CAAAvZ,SAAA,CAAAC,KAAK,GAAZ;IAEI,IAAI,CAAC2a,UAAU,EAAE;IAEjB,OAAO,IAAIrB,QAAQ,CAAC,IAAI,CAACE,SAAS,CAAC;GACtC;EAUDlZ,MAAA,CAAAwR,cAAA,CAAWwH,QAAA,CAAAvZ,SAAA,aAAS;SAKpB,SAAAgS,CAAA;MAEI,OAAO,IAAI,CAAC4H,KAAK,CAACa,SAAS;KAC9B;;;;;;;;;SARD,SAAAnS,CAAqBuS,KAAkB;MAEnC,IAAI,CAACjB,KAAK,CAACa,SAAS,GAAGI,KAAK;KAC/B;;;;EAcDta,MAAA,CAAAwR,cAAA,CAAWwH,QAAA,CAAAvZ,SAAA,QAAI;;;;;;;;SAAf,SAAAgS,CAAA;MAEI,OAAO,IAAI,CAAC8I,KAAK;KACpB;SAED,SAAAxS,CAAgBuS,KAAa;MAEzB,IAAI,CAACC,KAAK,GAAGD,KAAK;KACrB;;;;EAQDta,MAAA,CAAAwR,cAAA,CAAWwH,QAAA,CAAAvZ,SAAA,QAAI;;;;;;;SAAf,SAAAgS,CAAA;MAEI,OAAO,IAAI,CAAC+H,UAAU;KACzB;;;;EAQDxZ,MAAA,CAAAwR,cAAA,CAAWwH,QAAA,CAAAvZ,SAAA,QAAI;;;;;;;SAAf,SAAAgS,CAAA;MAEI,OAAO,IAAI,CAACgI,UAAU;KACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6BMT,QAAA,CAAAvZ,SAAA,CAAA6H,SAAS,GAAhB,UAAiBkT,OAAiC;IAAjC,IAAAA,OAAA;MAAAA,OAAA,OAAiC;IAAA;;IAG9C,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAC/B;;MAEI,IAAMC,IAAI,GAAG9B,SAAS;MAEtB6B,OAAO,GAAG;QACNvY,KAAK,EAAEwY,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;QACnBxb,KAAK,EAAEwb,IAAI,CAAC,CAAC,CAAC,IAAI,GAAG;QACrBvb,KAAK,EAAEub,IAAI,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC;QAC1CrR,SAAS,EAAEqR,IAAI,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG;QAChD5P,MAAM,EAAE,CAAC,CAAC4P,IAAI,CAAC,CAAC;OACnB;;IAGL,OAAO,IAAI,CAACE,gBAAgB,CAACH,OAAO,CAAC;GACxC;;;;;;;;;;;;;;;;;;EAmBMxB,QAAA,CAAAvZ,SAAA,CAAAkb,gBAAgB,GAAvB,UAAwBH,OAA0B;;;IAI9C,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAC/B;MACII,WAAW,CAAC,QAAQ,EAAE,+DAA+D,CAAC;;MAGhF,IAAAhL,EAAA,GAA4D+I,SAAgB;QAA3E1W,KAAK,GAAA2N,EAAA;QAAEzQ,OAAO,GAAAyQ,EAAA;QAAE3Q,KAAK,GAAA2Q,EAAA;QAAE1Q,KAAK,GAAA0Q,EAAA;QAAEtQ,MAAM,GAAAsQ,EAAA;QAAExG,SAAS,GAAAwG,EAAA;QAAE/E,MAAM,GAAA+E,EAAA,GAAoB;MAElF4K,OAAO,GAAG;QAAEvY,KAAK,EAAAA,KAAA;QAAE9C,OAAO,EAAAA,OAAA;QAAEF,KAAK,EAAAA,KAAA;QAAEC,KAAK,EAAAA,KAAA;QAAEI,MAAM,EAAAA,MAAA;QAAE8J,SAAS,EAAAA,SAAA;QAAEyB,MAAM,EAAAA;MAAA,CAAE;;MAGrE7K,MAAM,CAAC6a,IAAI,CAACL,OAAO,CAAC,CAACM,OAAO,CAAC,UAACC,GAAG;QAAK,OAACP,OAAe,CAACO,GAAG,CAAC,KAAKL,SAAS,IAAI,OAAQF,OAAe,CAACO,GAAG,CAAC;MAAA,EAAC;;;IAI9GP,OAAO,GAAGxa,MAAM,CAACgb,MAAM,CAAC;MACpB/Y,KAAK,EAAE,CAAC;MACR9C,OAAO,EAAEC,OAAO,CAACC,KAAK;MACtBJ,KAAK,EAAGub,OAAO,IAAIA,OAAO,CAACrb,OAAO,GAAI,QAAQ,GAAG,GAAG;MACpDD,KAAK,EAAE,CAAC;MACRI,MAAM,EAAE,IAAI;MACZ8J,SAAS,EAAE,GAAG;MACdyB,MAAM,EAAE,KAAK;MACbxB,GAAG,EAAEnL,QAAQ,CAAC0a,IAAI;MAClBtO,IAAI,EAAErM,SAAS,CAAC4a,KAAK;MACrBtQ,UAAU,EAAE;KACf,EAAEiS,OAAO,CAAC;IAEX,IAAI,IAAI,CAACZ,WAAW,EACpB;MACI,IAAI,CAACqB,SAAS,EAAE;;IAGpB,IAAM1b,OAAO,GAAGib,OAAO,CAACvY,KAAK,GAAG,CAAC,IAAIuY,OAAO,CAACtb,KAAK,GAAG,CAAC;IAEtD,IAAI,CAACK,OAAO,EACZ;MACI,IAAI,CAACka,UAAU,CAACja,KAAK,EAAE;KAC1B,MAED;MACI,IAAIgb,OAAO,CAAClb,MAAM,EAClB;QACIkb,OAAO,CAAClb,MAAM,GAAGkb,OAAO,CAAClb,MAAM,CAACI,KAAK,EAAE;QACvC8a,OAAO,CAAClb,MAAM,CAAC4b,MAAM,EAAE;;MAG3Blb,MAAM,CAACgb,MAAM,CAAC,IAAI,CAACvB,UAAU,EAAE;QAAEla,OAAO,EAAAA;MAAA,CAAE,EAAEib,OAAO,CAAC;;IAGxD,OAAO,IAAI;GACd;;;;;EAMSxB,QAAA,CAAAvZ,SAAA,CAAAwb,SAAS,GAAnB;IAEI,IAAI,IAAI,CAACrB,WAAW,EACpB;MACI,IAAM/Y,MAAM,GAAG,IAAI,CAAC+Y,WAAW,CAAC/Y,MAAM;MACtC,IAAMsK,GAAG,GAAG,IAAI,CAACyO,WAAW,CAAC/Y,MAAM,CAACnC,MAAM;MAE1C,IAAIyM,GAAG,GAAG,CAAC,EACX;QACI,IAAI,CAAC4G,SAAS,CAAC,IAAI,CAAC6H,WAAW,CAAC;QAChC,IAAI,CAACA,WAAW,GAAG,IAAInO,OAAO,EAAE;QAChC,IAAI,CAACmO,WAAW,CAAChS,WAAW,GAAG,KAAK;QACpC,IAAI,CAACgS,WAAW,CAAC/Y,MAAM,CAACW,IAAI,CAACX,MAAM,CAACsK,GAAG,GAAG,CAAC,CAAC,EAAEtK,MAAM,CAACsK,GAAG,GAAG,CAAC,CAAC,CAAC;;KAErE,MAED;MACI,IAAI,CAACyO,WAAW,GAAG,IAAInO,OAAO,EAAE;MAChC,IAAI,CAACmO,WAAW,CAAChS,WAAW,GAAG,KAAK;;GAE3C;;;;;EAMDoR,QAAA,CAAAvZ,SAAA,CAAA4a,UAAU,GAAV;IAEI,IAAI,IAAI,CAACT,WAAW,EACpB;MACI,IAAI,IAAI,CAACA,WAAW,CAAC/Y,MAAM,CAACnC,MAAM,GAAG,CAAC,EACtC;QACI,IAAI,CAACqT,SAAS,CAAC,IAAI,CAAC6H,WAAW,CAAC;QAChC,IAAI,CAACA,WAAW,GAAG,IAAI;OAC1B,MAED;QACI,IAAI,CAACA,WAAW,CAAC/Y,MAAM,CAACnC,MAAM,GAAG,CAAC;;;GAG7C;;;;;;;;EASMsa,QAAA,CAAAvZ,SAAA,CAAA0b,MAAM,GAAb,UAAcpZ,CAAS,EAAEC,CAAS;IAE9B,IAAI,CAACiZ,SAAS,EAAE;IAChB,IAAI,CAACrB,WAAW,CAAC/Y,MAAM,CAAC,CAAC,CAAC,GAAGkB,CAAC;IAC9B,IAAI,CAAC6X,WAAW,CAAC/Y,MAAM,CAAC,CAAC,CAAC,GAAGmB,CAAC;IAE9B,OAAO,IAAI;GACd;;;;;;;;;EAUMgX,QAAA,CAAAvZ,SAAA,CAAA2b,MAAM,GAAb,UAAcrZ,CAAS,EAAEC,CAAS;IAE9B,IAAI,CAAC,IAAI,CAAC4X,WAAW,EACrB;MACI,IAAI,CAACuB,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;;;IAIrB,IAAMta,MAAM,GAAG,IAAI,CAAC+Y,WAAW,CAAC/Y,MAAM;IACtC,IAAMgD,KAAK,GAAGhD,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;IACvC,IAAMoF,KAAK,GAAGjD,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC;IAEvC,IAAImF,KAAK,KAAK9B,CAAC,IAAI+B,KAAK,KAAK9B,CAAC,EAC9B;MACInB,MAAM,CAACW,IAAI,CAACO,CAAC,EAAEC,CAAC,CAAC;;IAGrB,OAAO,IAAI;GACd;;;;;;;;EASSgX,QAAA,CAAAvZ,SAAA,CAAA4b,UAAU,GAApB,UAAqBtZ,CAAK,EAAEC,CAAK;IAAZ,IAAAD,CAAA;MAAAA,CAAA,IAAK;IAAA;IAAE,IAAAC,CAAA;MAAAA,CAAA,IAAK;IAAA;IAE7B,IAAI,IAAI,CAAC4X,WAAW,EACpB;MACI,IAAI,IAAI,CAACA,WAAW,CAAC/Y,MAAM,CAACnC,MAAM,KAAK,CAAC,EACxC;QACI,IAAI,CAACkb,WAAW,CAAC/Y,MAAM,GAAG,CAACkB,CAAC,EAAEC,CAAC,CAAC;;KAEvC,MAED;MACI,IAAI,CAACmZ,MAAM,CAACpZ,CAAC,EAAEC,CAAC,CAAC;;GAExB;;;;;;;;;;;EAYMgX,QAAA,CAAAvZ,SAAA,CAAA6b,gBAAgB,GAAvB,UAAwBvX,GAAW,EAAEC,GAAW,EAAEC,GAAW,EAAEC,GAAW;IAEtE,IAAI,CAACmX,UAAU,EAAE;IAEjB,IAAMxa,MAAM,GAAG,IAAI,CAAC+Y,WAAW,CAAC/Y,MAAM;IAEtC,IAAIA,MAAM,CAACnC,MAAM,KAAK,CAAC,EACvB;MACI,IAAI,CAACyc,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;;IAGrBzM,cAAc,CAAC/C,OAAO,CAAC5H,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAErD,MAAM,CAAC;IAElD,OAAO,IAAI;GACd;;;;;;;;;;;;EAaMmY,QAAA,CAAAvZ,SAAA,CAAA8b,aAAa,GAApB,UAAqBxX,GAAW,EAAEC,GAAW,EAAE2J,IAAY,EAAEC,IAAY,EAAE3J,GAAW,EAAEC,GAAW;IAE/F,IAAI,CAACmX,UAAU,EAAE;IAEjB5N,WAAW,CAAC9B,OAAO,CAAC5H,GAAG,EAAEC,GAAG,EAAE2J,IAAI,EAAEC,IAAI,EAAE3J,GAAG,EAAEC,GAAG,EAAE,IAAI,CAAC0V,WAAW,CAAC/Y,MAAM,CAAC;IAE5E,OAAO,IAAI;GACd;;;;;;;;;;;;;EAcMmY,QAAA,CAAAvZ,SAAA,CAAA+b,KAAK,GAAZ,UAAa9S,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEvG,MAAc;IAEvE,IAAI,CAAC+Y,UAAU,CAAC3S,EAAE,EAAEC,EAAE,CAAC;IAEvB,IAAM9H,MAAM,GAAG,IAAI,CAAC+Y,WAAW,CAAC/Y,MAAM;IAEtC,IAAMhC,MAAM,GAAG6M,QAAQ,CAACC,OAAO,CAACjD,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEvG,MAAM,EAAEzB,MAAM,CAAC;IAE/D,IAAIhC,MAAM,EACV;MACY,IAAAmH,EAAE,GAAsDnH,MAAM,CAAAmH,EAA5D;QAAEC,EAAE,GAAkDpH,MAAM,CAAAoH,EAAxD;QAAEwV,QAAM,GAA0C5c,MAAM,CAAAyD,MAAhD;QAAEqE,UAAU,GAA8B9H,MAAM,CAAA8H,UAApC;QAAE+F,QAAQ,GAAoB7N,MAAM,CAAA6N,QAA1B;QAAEC,aAAa,GAAK9N,MAAM,CAAA8N,aAAX;MAE3D,IAAI,CAACC,GAAG,CAAC5G,EAAE,EAAEC,EAAE,EAAEwV,QAAM,EAAE9U,UAAU,EAAE+F,QAAQ,EAAEC,aAAa,CAAC;;IAGjE,OAAO,IAAI;GACd;;;;;;;;;;;;;;;EAgBMqM,QAAA,CAAAvZ,SAAA,CAAAmN,GAAG,GAAV,UAAW5G,EAAU,EAAEC,EAAU,EAAE3D,MAAc,EAAEqE,UAAkB,EAAE+F,QAAgB,EAAEC,aAAqB;IAArB,IAAAA,aAAA;MAAAA,aAAA,QAAqB;IAAA;IAE1G,IAAIhG,UAAU,KAAK+F,QAAQ,EAC3B;MACI,OAAO,IAAI;;IAGf,IAAI,CAACC,aAAa,IAAID,QAAQ,IAAI/F,UAAU,EAC5C;MACI+F,QAAQ,IAAIrB,IAAI;KACnB,MACI,IAAIsB,aAAa,IAAIhG,UAAU,IAAI+F,QAAQ,EAChD;MACI/F,UAAU,IAAI0E,IAAI;;IAGtB,IAAM2B,KAAK,GAAGN,QAAQ,GAAG/F,UAAU;IAEnC,IAAIqG,KAAK,KAAK,CAAC,EACf;MACI,OAAO,IAAI;;IAGf,IAAM0O,MAAM,GAAG1V,EAAE,GAAIlH,IAAI,CAACgE,GAAG,CAAC6D,UAAU,CAAC,GAAGrE,MAAO;IACnD,IAAMqZ,MAAM,GAAG1V,EAAE,GAAInH,IAAI,CAAC+D,GAAG,CAAC8D,UAAU,CAAC,GAAGrE,MAAO;IACnD,IAAM6E,GAAG,GAAG,IAAI,CAAC+R,SAAS,CAAC9R,aAAa;;IAGxC,IAAIvG,MAAM,GAAG,IAAI,CAAC+Y,WAAW,GAAG,IAAI,CAACA,WAAW,CAAC/Y,MAAM,GAAG,IAAI;IAE9D,IAAIA,MAAM,EACV;;;MAII,IAAM+a,KAAK,GAAG9c,IAAI,CAACgI,GAAG,CAACjG,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC,GAAGgd,MAAM,CAAC;MAC1D,IAAMG,KAAK,GAAG/c,IAAI,CAACgI,GAAG,CAACjG,MAAM,CAACA,MAAM,CAACnC,MAAM,GAAG,CAAC,CAAC,GAAGid,MAAM,CAAC;MAE1D,IAAIC,KAAK,GAAGzU,GAAG,IAAI0U,KAAK,GAAG1U,GAAG,EAC9B,CAGC,KAED;QACItG,MAAM,CAACW,IAAI,CAACka,MAAM,EAAEC,MAAM,CAAC;;KAElC,MAED;MACI,IAAI,CAACR,MAAM,CAACO,MAAM,EAAEC,MAAM,CAAC;MAC3B9a,MAAM,GAAG,IAAI,CAAC+Y,WAAW,CAAC/Y,MAAM;;IAGpC6K,QAAQ,CAACkB,GAAG,CAAC8O,MAAM,EAAEC,MAAM,EAAE3V,EAAE,EAAEC,EAAE,EAAE3D,MAAM,EAAEqE,UAAU,EAAE+F,QAAQ,EAAEC,aAAa,EAAE9L,MAAM,CAAC;IAEzF,OAAO,IAAI;GACd;;;;;;;;;EAUMmY,QAAA,CAAAvZ,SAAA,CAAAqc,SAAS,GAAhB,UAAiB7c,KAAS,EAAEC,KAAS;IAApB,IAAAD,KAAA;MAAAA,KAAA,IAAS;IAAA;IAAE,IAAAC,KAAA;MAAAA,KAAA,IAAS;IAAA;IAEjC,OAAO,IAAI,CAAC6c,gBAAgB,CAAC;MAAE5c,OAAO,EAAEC,OAAO,CAACC,KAAK;MAAEJ,KAAK,EAAAA,KAAA;MAAEC,KAAK,EAAAA;IAAA,CAAE,CAAC;GACzE;;;;;;;;;;;EAYD8Z,QAAA,CAAAvZ,SAAA,CAAAsc,gBAAgB,GAAhB,UAAiBvB,OAA0B;;IAGvC,IAAIA,OAAO,YAAYpb,OAAO,EAC9B;MACIwb,WAAW,CAAC,QAAQ,EAAE,+DAA+D,CAAC;;MAGhF,IAAAhL,EAAA,GAAkC+I,SAAgB;QAAjDxZ,OAAO,GAAAyQ,EAAA;QAAE3Q,KAAK,GAAA2Q,EAAA;QAAE1Q,KAAK,GAAA0Q,EAAA;QAAEtQ,MAAM,GAAAsQ,EAAA,GAAoB;MAExD4K,OAAO,GAAG;QAAErb,OAAO,EAAAA,OAAA;QAAEF,KAAK,EAAAA,KAAA;QAAEC,KAAK,EAAAA,KAAA;QAAEI,MAAM,EAAAA;MAAA,CAAE;;MAG3CU,MAAM,CAAC6a,IAAI,CAACL,OAAO,CAAC,CAACM,OAAO,CAAC,UAACC,GAAG;QAAK,OAACP,OAAe,CAACO,GAAG,CAAC,KAAKL,SAAS,IAAI,OAAQF,OAAe,CAACO,GAAG,CAAC;MAAA,EAAC;;;IAI9GP,OAAO,GAAGxa,MAAM,CAACgb,MAAM,CAAC;MACpB7b,OAAO,EAAEC,OAAO,CAACC,KAAK;MACtBJ,KAAK,EAAE,QAAQ;MACfC,KAAK,EAAE,CAAC;MACRI,MAAM,EAAE;KACX,EAAEkb,OAAO,CAAsB;IAEhC,IAAI,IAAI,CAACZ,WAAW,EACpB;MACI,IAAI,CAACqB,SAAS,EAAE;;IAGpB,IAAM1b,OAAO,GAAGib,OAAO,CAACtb,KAAK,GAAG,CAAC;IAEjC,IAAI,CAACK,OAAO,EACZ;MACI,IAAI,CAACia,UAAU,CAACha,KAAK,EAAE;KAC1B,MAED;MACI,IAAIgb,OAAO,CAAClb,MAAM,EAClB;QACIkb,OAAO,CAAClb,MAAM,GAAGkb,OAAO,CAAClb,MAAM,CAACI,KAAK,EAAE;QACvC8a,OAAO,CAAClb,MAAM,CAAC4b,MAAM,EAAE;;MAG3Blb,MAAM,CAACgb,MAAM,CAAC,IAAI,CAACxB,UAAU,EAAE;QAAEja,OAAO,EAAAA;MAAA,CAAE,EAAEib,OAAO,CAAC;;IAGxD,OAAO,IAAI;GACd;;;;;;EAOMxB,QAAA,CAAAvZ,SAAA,CAAAuc,OAAO,GAAd;IAEI,IAAI,CAAC3B,UAAU,EAAE;IAEjB,IAAI,CAACb,UAAU,CAACha,KAAK,EAAE;IAEvB,OAAO,IAAI;GACd;;;;;;;;;;EAWMwZ,QAAA,CAAAvZ,SAAA,CAAAwc,QAAQ,GAAf,UAAgBla,CAAS,EAAEC,CAAS,EAAEC,KAAa,EAAEC,MAAc;IAE/D,OAAO,IAAI,CAAC6P,SAAS,CAAC,IAAImK,SAAS,CAACna,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAC,CAAC;GAC5D;;;;;;;;;;;EAYM8W,QAAA,CAAAvZ,SAAA,CAAA0c,eAAe,GAAtB,UAAuBpa,CAAS,EAAEC,CAAS,EAAEC,KAAa,EAAEC,MAAc,EAAEI,MAAc;IAEtF,OAAO,IAAI,CAACyP,SAAS,CAAC,IAAIqK,gBAAgB,CAACra,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,EAAEI,MAAM,CAAC,CAAC;GAC3E;;;;;;;;;EAUM0W,QAAA,CAAAvZ,SAAA,CAAA4c,UAAU,GAAjB,UAAkBta,CAAS,EAAEC,CAAS,EAAEM,MAAc;IAElD,OAAO,IAAI,CAACyP,SAAS,CAAC,IAAIuK,MAAM,CAACva,CAAC,EAAEC,CAAC,EAAEM,MAAM,CAAC,CAAC;GAClD;;;;;;;;;;EAWM0W,QAAA,CAAAvZ,SAAA,CAAA8c,WAAW,GAAlB,UAAmBxa,CAAS,EAAEC,CAAS,EAAEC,KAAa,EAAEC,MAAc;IAElE,OAAO,IAAI,CAAC6P,SAAS,CAAC,IAAIyK,OAAO,CAACza,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEC,MAAM,CAAC,CAAC;GAC1D;;;;;;;EAWM8W,QAAA,CAAAvZ,SAAA,CAAAgd,WAAW,GAAlB;;IAAmB,IAAAC,IAAA;SAAA,IAAAC,EAAA,IAAc,EAAdA,EAAA,GAAAhE,SAAA,CAAAja,MAAc,EAAdie,EAAA,EAAc;MAAdD,IAAA,CAAAC,EAAA,IAAAC,WAAA,CAAAD,EAAA;;IAEf,IAAI9b,MAAoC;IACxC,IAAI+G,WAAW,GAAG,IAAI,CAAC;IAEvB,IAAM2P,IAAI,GAAGmF,IAAI,CAAC,CAAC,CAAY;;IAG/B,IAAInF,IAAI,CAAC1W,MAAM,EACf;MACI+G,WAAW,GAAG2P,IAAI,CAAC3P,WAAW;MAC9B/G,MAAM,GAAG0W,IAAI,CAAC1W,MAAM;KACvB,MAED,IAAIV,KAAK,CAAC0c,OAAO,CAACH,IAAI,CAAC,CAAC,CAAC,CAAC,EAC1B;MACI7b,MAAM,GAAG6b,IAAI,CAAC,CAAC,CAAC;KACnB,MAED;MACI7b,MAAM,GAAG6b,IAAI;;IAGjB,IAAM5b,KAAK,GAAG,IAAI2K,OAAO,CAAC5K,MAAM,CAAC;IAEjCC,KAAK,CAAC8G,WAAW,GAAGA,WAAW;IAE/B,IAAI,CAACmK,SAAS,CAACjR,KAAK,CAAC;IAErB,OAAO,IAAI;GACd;;;;;;;EAQMkY,QAAA,CAAAvZ,SAAA,CAAAsS,SAAS,GAAhB,UAAiBjR,KAAa;IAE1B,IAAI,CAAC,IAAI,CAAC6Y,SAAS,EACnB;MACI,IAAI,CAACT,SAAS,CAACnH,SAAS,CACpBjR,KAAK,EACL,IAAI,CAAC0Y,UAAU,CAAC9Z,KAAK,EAAE,EACvB,IAAI,CAAC+Z,UAAU,CAAC/Z,KAAK,EAAE,EACvB,IAAI,CAACga,OAAO,CACf;KACJ,MAED;MACI,IAAI,CAACR,SAAS,CAACjH,QAAQ,CAACnR,KAAK,EAAE,IAAI,CAAC4Y,OAAO,CAAC;;IAGhD,OAAO,IAAI;GACd;;;;;;;;;;;;EAaMV,QAAA,CAAAvZ,SAAA,CAAAqd,QAAQ,GAAf,UAAgB/a,CAAS,EAAEC,CAAS,EAAEnB,MAAc,EAAEyB,MAAc,EAAE0I,WAAmB,EAAEC,QAAY;IAAZ,IAAAA,QAAA;MAAAA,QAAA,IAAY;IAAA;IAEnG,OAAO,IAAI,CAACwR,WAAW,CAAC,IAAI3R,IAAI,CAAC/I,CAAC,EAAEC,CAAC,EAAEnB,MAAM,EAAEyB,MAAM,EAAE0I,WAAW,EAAEC,QAAQ,CAAY,CAAC;GAC5F;;;;;;EAOM+N,QAAA,CAAAvZ,SAAA,CAAAoS,KAAK,GAAZ;IAEI,IAAI,CAACqH,SAAS,CAACrH,KAAK,EAAE;IACtB,IAAI,CAAC4H,UAAU,CAACja,KAAK,EAAE;IACvB,IAAI,CAACga,UAAU,CAACha,KAAK,EAAE;IAEvB,IAAI,CAACud,SAAS,EAAE;IAChB,IAAI,CAACrD,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,WAAW,GAAG,IAAI;IAEvB,OAAO,IAAI;GACd;;;;;;;EAQMZ,QAAA,CAAAvZ,SAAA,CAAAud,UAAU,GAAjB;IAEI,IAAMhL,IAAI,GAAG,IAAI,CAACkH,SAAS,CAACtY,YAAY;IAExC,OAAOoR,IAAI,CAACtT,MAAM,KAAK,CAAC,IACjBsT,IAAI,CAAC,CAAC,CAAC,CAAClR,KAAK,CAACqB,IAAI,KAAKC,MAAM,CAAC0N,IAAI,IAClC,EAAEkC,IAAI,CAAC,CAAC,CAAC,CAAC1K,SAAS,CAAC/H,OAAO,IAAIyS,IAAI,CAAC,CAAC,CAAC,CAAC1K,SAAS,CAACrF,KAAK,CAAC;GACjE;;;;;;;EAQS+W,QAAA,CAAAvZ,SAAA,CAAAwd,OAAO,GAAjB,UAAkBC,QAAkB;IAEhC,IAAI,CAAC7C,UAAU,EAAE;IAEjB,IAAMpB,QAAQ,GAAG,IAAI,CAACC,SAAS;IAC/B,IAAMiE,QAAQ,GAAGD,QAAQ,CAACE,OAAO,CAACC,QAAQ,CAACC,aAAa;;;IAIxDrE,QAAQ,CAACtG,aAAa,CAACwK,QAAQ,CAAC;IAEhC,IAAIlE,QAAQ,CAAC1H,SAAS,EACtB;MACI,IAAI,IAAI,CAACT,UAAU,KAAKmI,QAAQ,CAACnI,UAAU,EAC3C;QACI,IAAI,CAACyM,gBAAgB,EAAE;;MAG3B,IAAI,CAACC,cAAc,CAACN,QAAQ,CAAC;KAChC,MAED;;MAEIA,QAAQ,CAACvI,KAAK,CAAC8I,KAAK,EAAE;MAEtB,IAAI,CAACC,aAAa,CAACR,QAAQ,CAAC;;GAEnC;;;;;;EAOSlE,QAAA,CAAAvZ,SAAA,CAAA8d,gBAAgB,GAA1B;IAEI,IAAMtE,QAAQ,GAAG,IAAI,CAACC,SAAS;IAC/B,IAAMgB,SAAS,GAAG,IAAI,CAACA,SAAS;IAChC,IAAM/O,GAAG,GAAG8N,QAAQ,CAAC/H,OAAO,CAACxS,MAAM;IAEnC,IAAI,CAACmb,SAAS,GAAG,CAAC,CAAC;IACnB,IAAI,CAACG,YAAY,GAAG,CAAC,CAAC;IACtB,IAAI,CAAClJ,UAAU,GAAGmI,QAAQ,CAACnI,UAAU;IACrC,IAAI,CAACI,OAAO,CAACxS,MAAM,GAAGyM,GAAG;IAEzB,IAAI,CAAC2O,UAAU,GAAG,IAAIpF,YAAY,CAACuE,QAAQ,CAACpY,MAAM,CAAC;IAEnD,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6J,GAAG,EAAE7J,CAAC,EAAE,EAC5B;MACI,IAAMqc,EAAE,GAAG1E,QAAQ,CAAC/H,OAAO,CAAC5P,CAAC,CAAC;MAC9B,IAAMrC,KAAK,GAAG0e,EAAE,CAACtW,KAAK,CAACpI,KAAK;MAC5B,IAAM6a,UAAU,GAAG,IAAIpF,YAAY,CAAC,IAAI,CAACoF,UAAU,CAAC8D,MAAM,EACtDD,EAAE,CAACvO,WAAW,GAAG,CAAC,GAAG,CAAC,EACtBuO,EAAE,CAAClO,UAAU,GAAG,CAAC,CAAC;MAEtB,IAAMkB,GAAG,GAAG,IAAI+D,YAAY,CAACuE,QAAQ,CAACzI,UAAU,CAACoN,MAAM,EACnDD,EAAE,CAACvO,WAAW,GAAG,CAAC,GAAG,CAAC,EACtBuO,EAAE,CAAClO,UAAU,GAAG,CAAC,CAAC;MAEtB,IAAMrO,OAAO,GAAG,IAAI4S,WAAW,CAACiF,QAAQ,CAACxI,aAAa,CAACmN,MAAM,EACzDD,EAAE,CAACtO,KAAK,GAAG,CAAC,EACZsO,EAAE,CAACjO,IAAI,CAAC;MAEZ,IAAMiF,KAAK,GAAG;QACVmF,UAAU,EAAAA,UAAA;QACVI,SAAS,EAAAA,SAAA;QACT9Y,OAAO,EAAAA,OAAA;QACPuP,GAAG,EAAAA,GAAA;QACHkN,SAAS,EAAEC,OAAO,CAAC7e,KAAK,CAAkB;QAC1C8e,QAAQ,EAAE9e,KAAK;QACf+e,QAAQ,EAAEL,EAAE,CAACtW,KAAK,CAAClI,OAAO;QAC1BD,KAAK,EAAEye,EAAE,CAACtW,KAAK,CAACnI,KAAK;QACrB+e,UAAU,EAAE;OAAG;MAEnB,IAAI,CAAC/M,OAAO,CAAC5P,CAAC,CAAC,GAAGqT,KAAK;;GAE9B;;;;;;;EAQSqE,QAAA,CAAAvZ,SAAA,CAAA+d,cAAc,GAAxB,UAAyBN,QAAkB;IAEvC,IAAI,CAAC,IAAI,CAAChM,OAAO,CAACxS,MAAM,EACxB;MACI;;IAGJwe,QAAQ,CAACvI,KAAK,CAACuJ,iBAAiB,CAAChB,QAAQ,CAACiB,OAAO,CAAC,IAAI,CAACpE,UAAU,CAAC,CAAC;IAEnE,IAAI,CAACqE,iBAAiB,EAAE;IACxB,IAAI,CAACC,cAAc,EAAE;IAErB,KAAK,IAAI/c,CAAC,GAAG,CAAC,EAAEgT,CAAC,GAAG,IAAI,CAACpD,OAAO,CAACxS,MAAM,EAAE4C,CAAC,GAAGgT,CAAC,EAAEhT,CAAC,EAAE,EACnD;MACI,IAAMqT,KAAK,GAAG,IAAI,CAACzD,OAAO,CAAC5P,CAAC,CAAC;MAE7BqT,KAAK,CAACsJ,UAAU,GAAG,IAAI,CAACA,UAAU,GAAGtJ,KAAK,CAACzV,KAAK;MAEhDge,QAAQ,CAACiB,OAAO,CAAC,IAAI,CAACpE,UAAU,CAAC,CAACuE,MAAM,CAAC3J,KAAK,CAAC;;GAEtD;;;;;;;EAQSqE,QAAA,CAAAvZ,SAAA,CAAAie,aAAa,GAAvB,UAAwBR,QAAkB;IAEtC,IAAM9D,MAAM,GAAG,IAAI,CAACmF,oBAAoB,CAACrB,QAAQ,CAAC;IAElD,IAAMjE,QAAQ,GAAG,IAAI,CAACC,SAAS;IAC/B,IAAMe,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,IAAMgE,UAAU,GAAG,IAAI,CAACA,UAAU;IAClC,IAAMO,QAAQ,GAAGpF,MAAM,CAACoF,QAAQ;IAChC,IAAMvN,SAAS,GAAGgI,QAAQ,CAAChI,SAAS;;IAGpCuN,QAAQ,CAACC,iBAAiB,GAAG,IAAI,CAACC,SAAS,CAACC,cAAc;;IAG1DH,QAAQ,CAACvE,IAAI,CAAC,CAAC,CAAC,GAAI,CAAEA,IAAI,IAAI,EAAE,GAAI,IAAI,IAAI,GAAG,GAAIgE,UAAU;IAC7DO,QAAQ,CAACvE,IAAI,CAAC,CAAC,CAAC,GAAI,CAAEA,IAAI,IAAI,CAAC,GAAI,IAAI,IAAI,GAAG,GAAIgE,UAAU;IAC5DO,QAAQ,CAACvE,IAAI,CAAC,CAAC,CAAC,GAAI,CAACA,IAAI,GAAG,IAAI,IAAI,GAAG,GAAIgE,UAAU;IACrDO,QAAQ,CAACvE,IAAI,CAAC,CAAC,CAAC,GAAGgE,UAAU;;;;;IAO7Bf,QAAQ,CAAC9D,MAAM,CAACwF,IAAI,CAACxF,MAAM,CAAC;IAC5B8D,QAAQ,CAACjE,QAAQ,CAAC2F,IAAI,CAAC3F,QAAQ,EAAEG,MAAM,CAAC;;IAGxC8D,QAAQ,CAAC7D,KAAK,CAACtR,GAAG,CAAC,IAAI,CAACsR,KAAK,CAAC;;IAG9B,KAAK,IAAI/X,CAAC,GAAG,CAAC,EAAEgT,CAAC,GAAGrD,SAAS,CAACvS,MAAM,EAAE4C,CAAC,GAAGgT,CAAC,EAAEhT,CAAC,EAAE,EAChD;MACI,IAAI,CAACud,qBAAqB,CAAC3B,QAAQ,EAAEjE,QAAQ,CAAChI,SAAS,CAAC3P,CAAC,CAAC,CAAC;;GAElE;;;;;;;EAQS0X,QAAA,CAAAvZ,SAAA,CAAAof,qBAAqB,GAA/B,UAAgC3B,QAAkB,EAAE4B,QAAuB;IAE/D,IAAAlN,QAAQ,GAAwBkN,QAAQ,CAAAlN,QAAhC;MAAEzP,IAAI,GAAkB2c,QAAQ,CAAA3c,IAA1B;MAAEuN,IAAI,GAAYoP,QAAQ,CAAApP,IAApB;MAAEL,KAAK,GAAKyP,QAAQ,CAAAzP,KAAb;IACnC,IAAM0P,iBAAiB,GAAGnN,QAAQ,CAACuD,KAAK;IAExC,KAAK,IAAI1Q,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsa,iBAAiB,EAAEta,CAAC,EAAE,EAC1C;MACIyY,QAAQ,CAAC/d,OAAO,CAACyf,IAAI,CAAChN,QAAQ,CAACmE,QAAQ,CAACtR,CAAC,CAAC,EAAEA,CAAC,CAAC;;IAGlDyY,QAAQ,CAACjE,QAAQ,CAAC+F,IAAI,CAAC7c,IAAI,EAAEuN,IAAI,EAAEL,KAAK,CAAC;GAC5C;;;;;;;EAQS2J,QAAA,CAAAvZ,SAAA,CAAA8e,oBAAoB,GAA9B,UAA+BrB,QAAkB;IAE7C,IAAI9D,MAAM,GAAG,IAAI,CAACA,MAAM;IAExB,IAAMW,UAAU,GAAG,IAAI,CAACA,UAAU;IAElC,IAAI,CAACX,MAAM,EACX;;;;MAII,IAAI,CAACL,eAAe,CAACgB,UAAU,CAAC,EAChC;QACI,IAAMkF,YAAY,GAAG,IAAIC,UAAU,CAAC,EAAE,CAAC;QAEvC,KAAK,IAAI5d,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAC3B;UACI2d,YAAY,CAAC3d,CAAC,CAAC,GAAGA,CAAC;;QAGvB,IAAMkd,QAAQ,GAAG;UACbvE,IAAI,EAAE,IAAIvF,YAAY,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;UACpC+J,iBAAiB,EAAE,IAAI3H,MAAM,EAAE;UAC/BqI,OAAO,EAAEC,YAAY,CAACC,IAAI,CAAC;YAAEC,SAAS,EAAEL;UAAY,CAAE,EAAE,IAAI;SAC/D;QAED,IAAMM,OAAO,GAAGrC,QAAQ,CAACiB,OAAO,CAACpE,UAAU,CAAC,CAACyF,OAAO,CAACD,OAAO;QAE5DxG,eAAe,CAACgB,UAAU,CAAC,GAAG,IAAI0F,MAAM,CAACF,OAAO,EAAEf,QAAQ,CAAC;;MAG/DpF,MAAM,GAAGL,eAAe,CAACgB,UAAU,CAAC;;IAGxC,OAAOX,MAAM;GAChB;;;;;;EAOSJ,QAAA,CAAAvZ,SAAA,CAAAigB,gBAAgB,GAA1B;IAEI,IAAI,CAACrF,UAAU,EAAE;IAEjB,IAAMpB,QAAQ,GAAG,IAAI,CAACC,SAAS;;IAG/B,IAAI,CAACD,QAAQ,CAACrY,YAAY,CAAClC,MAAM,EACjC;MACI;;IAGE,IAAAkR,EAAA,GAA6BqJ,QAAQ,CAACtC,MAAM;MAA1C2B,IAAI,GAAA1I,EAAA,CAAA0I,IAAA;MAAEC,IAAI,GAAA3I,EAAA,CAAA2I,IAAA;MAAEoH,IAAI,GAAA/P,EAAA,CAAA+P,IAAA;MAAEC,IAAI,GAAAhQ,EAAA,CAAAgQ,IAAoB;IAElD,IAAI,CAACxO,OAAO,CAACyO,QAAQ,CAAC,IAAI,CAACnB,SAAS,EAAEpG,IAAI,EAAEC,IAAI,EAAEoH,IAAI,EAAEC,IAAI,CAAC;GAChE;;;;;;;EAQM5G,QAAA,CAAAvZ,SAAA,CAAA2S,aAAa,GAApB,UAAqBC,KAAiB;IAElC,IAAI,CAACsM,cAAc,CAACrM,YAAY,CAACD,KAAK,EAAE2G,QAAQ,CAAC8G,WAAW,CAAC;IAE7D,OAAO,IAAI,CAAC5G,SAAS,CAAC9G,aAAa,CAAC4G,QAAQ,CAAC8G,WAAW,CAAC;GAC5D;;;;;EAMS9G,QAAA,CAAAvZ,SAAA,CAAA4e,cAAc,GAAxB;IAEI,IAAI,IAAI,CAACxE,SAAS,KAAK,IAAI,CAACI,IAAI,EAChC;MACI,IAAI,CAACJ,SAAS,GAAG,IAAI,CAACI,IAAI;MAE1B,IAAM8F,OAAO,GAAGjC,OAAO,CAAC,IAAI,CAAC7D,IAAI,EAAEnB,IAAI,CAAC;MAExC,KAAK,IAAIxX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC4P,OAAO,CAACxS,MAAM,EAAE4C,CAAC,EAAE,EAC5C;QACI,IAAMqT,KAAK,GAAG,IAAI,CAACzD,OAAO,CAAC5P,CAAC,CAAC;QAE7B,IAAMuY,SAAS,GAAGlF,KAAK,CAACkJ,SAAS;QAEjC,IAAMtS,CAAC,GAAIwU,OAAO,CAAC,CAAC,CAAC,GAAGlG,SAAS,CAAC,CAAC,CAAC,GAAI,GAAG;QAC3C,IAAMmG,CAAC,GAAID,OAAO,CAAC,CAAC,CAAC,GAAGlG,SAAS,CAAC,CAAC,CAAC,GAAI,GAAG;QAC3C,IAAM9Z,CAAC,GAAIggB,OAAO,CAAC,CAAC,CAAC,GAAGlG,SAAS,CAAC,CAAC,CAAC,GAAI,GAAG;;QAG3C,IAAM5a,KAAK,GAAG,CAACsM,CAAC,IAAI,EAAE,KAAKyU,CAAC,IAAI,CAAC,CAAC,IAAIjgB,CAAC,GAAG,CAAC,CAAC;QAE5C4U,KAAK,CAACoJ,QAAQ,GAAG,CAAC9e,KAAK,IAAI,EAAE,KAClBA,KAAK,GAAG,MAAM,CAAC,IACf,CAACA,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;;;GAG3C;;;;;;EAOS+Z,QAAA,CAAAvZ,SAAA,CAAA2e,iBAAiB,GAA3B;IAEI,IAAM6B,IAAI,GAAG,IAAI,CAACvB,SAAS,CAACwB,QAAQ;IAEpC,IAAI,IAAI,CAAClG,YAAY,KAAKiG,IAAI,EAC9B;MACI;;IAGJ,IAAI,CAACjG,YAAY,GAAGiG,IAAI;IAExB,IAAME,EAAE,GAAG,IAAI,CAACzB,SAAS,CAACC,cAAc;IACxC,IAAM1b,CAAC,GAAGkd,EAAE,CAACld,CAAC;IACd,IAAMlD,CAAC,GAAGogB,EAAE,CAACpgB,CAAC;IACd,IAAMmD,CAAC,GAAGid,EAAE,CAACjd,CAAC;IACd,IAAMpD,CAAC,GAAGqgB,EAAE,CAACrgB,CAAC;IACd,IAAMqD,EAAE,GAAGgd,EAAE,CAAChd,EAAE;IAChB,IAAMC,EAAE,GAAG+c,EAAE,CAAC/c,EAAE;IAEhB,IAAM4O,IAAI,GAAG,IAAI,CAACkH,SAAS,CAACrY,MAAM,CAAC;IACnC,IAAMiZ,UAAU,GAAG,IAAI,CAACA,UAAU;IAElC,IAAI3E,KAAK,GAAG,CAAC;IAEb,KAAK,IAAI7T,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0Q,IAAI,CAACtT,MAAM,EAAE4C,CAAC,IAAI,CAAC,EACvC;MACI,IAAMS,CAAC,GAAGiQ,IAAI,CAAC1Q,CAAC,CAAC;MACjB,IAAMU,CAAC,GAAGgQ,IAAI,CAAC1Q,CAAC,GAAG,CAAC,CAAC;MAErBwY,UAAU,CAAC3E,KAAK,EAAE,CAAC,GAAIlS,CAAC,GAAGlB,CAAC,GAAKmB,CAAC,GAAGlB,CAAE,GAAGmB,EAAE;MAC5C2W,UAAU,CAAC3E,KAAK,EAAE,CAAC,GAAIrV,CAAC,GAAGkC,CAAC,GAAKjC,CAAC,GAAGgC,CAAE,GAAGqB,EAAE;;GAEnD;;;;;;EAOM4V,QAAA,CAAAvZ,SAAA,CAAA2gB,SAAS,GAAhB;IAEI,IAAMxG,WAAW,GAAG,IAAI,CAACA,WAAW;IAEpC,IAAIA,WAAW,EACf;;MAEIA,WAAW,CAAChS,WAAW,GAAG,IAAI;;IAGlC,OAAO,IAAI;GACd;;;;;;;EAQMoR,QAAA,CAAAvZ,SAAA,CAAA4gB,SAAS,GAAhB,UAAiB/gB,MAAc;IAE3B,IAAI,CAACoa,OAAO,GAAGpa,MAAM;IAErB,OAAO,IAAI;GACd;;;;;;;;;EAUM0Z,QAAA,CAAAvZ,SAAA,CAAA6gB,SAAS,GAAhB;IAEI,IAAI,CAACjG,UAAU,EAAE;IACjB,IAAI,CAACV,SAAS,GAAG,IAAI;IAErB,OAAO,IAAI;GACd;;;;;EAMMX,QAAA,CAAAvZ,SAAA,CAAA8gB,OAAO,GAAd;IAEI,IAAI,CAAClG,UAAU,EAAE;IACjB,IAAI,CAACV,SAAS,GAAG,KAAK;IAEtB,OAAO,IAAI;GACd;;;;;;;;;;;;;EAcMX,QAAA,CAAAvZ,SAAA,CAAAG,OAAO,GAAd,UAAe4a,OAAgC;IAE3CzP,MAAA,CAAAtL,SAAA,CAAMG,OAAO,CAAA4L,IAAA,OAACgP,OAAO,CAAC;IAEtB,IAAI,CAACtB,SAAS,CAACC,QAAQ,EAAE;IACzB,IAAI,IAAI,CAACD,SAAS,CAACC,QAAQ,KAAK,CAAC,EACjC;MACI,IAAI,CAACD,SAAS,CAACsH,OAAO,EAAE;;IAG5B,IAAI,CAAC9G,OAAO,GAAG,IAAI;IACnB,IAAI,CAACE,WAAW,GAAG,IAAI;IACvB,IAAI,CAACH,UAAU,CAAC7Z,OAAO,EAAE;IACzB,IAAI,CAAC6Z,UAAU,GAAG,IAAI;IACtB,IAAI,CAACD,UAAU,CAAC5Z,OAAO,EAAE;IACzB,IAAI,CAAC4Z,UAAU,GAAG,IAAI;IACtB,IAAI,CAACN,SAAS,GAAG,IAAI;IACrB,IAAI,CAACE,MAAM,GAAG,IAAI;IAClB,IAAI,CAACU,UAAU,GAAG,IAAI;IACtB,IAAI,CAAC5I,OAAO,CAACxS,MAAM,GAAG,CAAC;IACvB,IAAI,CAACwS,OAAO,GAAG,IAAI;IAEnBnG,MAAA,CAAAtL,SAAA,CAAMG,OAAO,CAAA4L,IAAA,OAACgP,OAAO,CAAC;GACzB;;;;;;;;EA1wCMxB,QAAA,CAAA8G,WAAW,GAAG,IAAItY,KAAK,EAAE;EA2wCpC,OAAAwR,QAAC;CAAA,CArxC6ByH,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}