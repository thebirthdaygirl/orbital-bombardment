{"ast":null,"code":"/*!\n * @pixi/display - v5.3.3\n * Compiled Tue, 04 Aug 2020 16:23:09 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { settings } from '@pixi/settings';\nimport { Rectangle, Transform, RAD_TO_DEG, DEG_TO_RAD } from '@pixi/math';\nimport { EventEmitter, removeItems } from '@pixi/utils';\n\n/**\n * Sets the default value for the container property 'sortableChildren'.\n * If set to true, the container will sort its children by zIndex value\n * when updateTransform() is called, or manually if sortChildren() is called.\n *\n * This actually changes the order of elements in the array, so should be treated\n * as a basic solution that is not performant compared to other solutions,\n * such as @link https://github.com/pixijs/pixi-display\n *\n * Also be aware of that this may not work nicely with the addChildAt() function,\n * as the zIndex sorting may cause the child to automatically sorted to another position.\n *\n * @static\n * @constant\n * @name SORTABLE_CHILDREN\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */\nsettings.SORTABLE_CHILDREN = false;\n\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n *\n * @class\n * @memberof PIXI\n */\nvar Bounds = /** @class */function () {\n  function Bounds() {\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.minX = Infinity;\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.minY = Infinity;\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.maxX = -Infinity;\n    /**\n     * @member {number}\n     * @default 0\n     */\n    this.maxY = -Infinity;\n    this.rect = null;\n    /**\n     * It is updated to _boundsID of corresponding object to keep bounds in sync with content.\n     * Updated from outside, thus public modifier.\n     *\n     * @member {number}\n     * @public\n     */\n    this.updateID = -1;\n  }\n  /**\n   * Checks if bounds are empty.\n   *\n   * @return {boolean} True if empty.\n   */\n  Bounds.prototype.isEmpty = function () {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  };\n  /**\n   * Clears the bounds and resets.\n   *\n   */\n  Bounds.prototype.clear = function () {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n  };\n  /**\n   * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n   * It is not guaranteed that it will return tempRect\n   *\n   * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty\n   * @returns {PIXI.Rectangle} A rectangle of the bounds\n   */\n  Bounds.prototype.getRectangle = function (rect) {\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      return Rectangle.EMPTY;\n    }\n    rect = rect || new Rectangle(0, 0, 1, 1);\n    rect.x = this.minX;\n    rect.y = this.minY;\n    rect.width = this.maxX - this.minX;\n    rect.height = this.maxY - this.minY;\n    return rect;\n  };\n  /**\n   * This function should be inlined when its possible.\n   *\n   * @param {PIXI.IPointData} point - The point to add.\n   */\n  Bounds.prototype.addPoint = function (point) {\n    this.minX = Math.min(this.minX, point.x);\n    this.maxX = Math.max(this.maxX, point.x);\n    this.minY = Math.min(this.minY, point.y);\n    this.maxY = Math.max(this.maxY, point.y);\n  };\n  /**\n   * Adds a quad, not transformed\n   *\n   * @param {Float32Array} vertices - The verts to add.\n   */\n  Bounds.prototype.addQuad = function (vertices) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    var x = vertices[0];\n    var y = vertices[1];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[2];\n    y = vertices[3];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[4];\n    y = vertices[5];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[6];\n    y = vertices[7];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  /**\n   * Adds sprite frame, transformed.\n   *\n   * @param {PIXI.Transform} transform - transform to apply\n   * @param {number} x0 - left X of frame\n   * @param {number} y0 - top Y of frame\n   * @param {number} x1 - right X of frame\n   * @param {number} y1 - bottom Y of frame\n   */\n  Bounds.prototype.addFrame = function (transform, x0, y0, x1, y1) {\n    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n  };\n  /**\n   * Adds sprite frame, multiplied by matrix\n   *\n   * @param {PIXI.Matrix} matrix - matrix to apply\n   * @param {number} x0 - left X of frame\n   * @param {number} y0 - top Y of frame\n   * @param {number} x1 - right X of frame\n   * @param {number} y1 - bottom Y of frame\n   */\n  Bounds.prototype.addFrameMatrix = function (matrix, x0, y0, x1, y1) {\n    var a = matrix.a;\n    var b = matrix.b;\n    var c = matrix.c;\n    var d = matrix.d;\n    var tx = matrix.tx;\n    var ty = matrix.ty;\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    var x = a * x0 + c * y0 + tx;\n    var y = b * x0 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  /**\n   * Adds screen vertices from array\n   *\n   * @param {Float32Array} vertexData - calculated vertices\n   * @param {number} beginOffset - begin offset\n   * @param {number} endOffset - end offset, excluded\n   */\n  Bounds.prototype.addVertexData = function (vertexData, beginOffset, endOffset) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    for (var i = beginOffset; i < endOffset; i += 2) {\n      var x = vertexData[i];\n      var y = vertexData[i + 1];\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  /**\n   * Add an array of mesh vertices\n   *\n   * @param {PIXI.Transform} transform - mesh transform\n   * @param {Float32Array} vertices - mesh coordinates in array\n   * @param {number} beginOffset - begin offset\n   * @param {number} endOffset - end offset, excluded\n   */\n  Bounds.prototype.addVertices = function (transform, vertices, beginOffset, endOffset) {\n    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n  };\n  /**\n   * Add an array of mesh vertices.\n   *\n   * @param {PIXI.Matrix} matrix - mesh matrix\n   * @param {Float32Array} vertices - mesh coordinates in array\n   * @param {number} beginOffset - begin offset\n   * @param {number} endOffset - end offset, excluded\n   * @param {number} [padX=0] - x padding\n   * @param {number} [padY=0] - y padding\n   */\n  Bounds.prototype.addVerticesMatrix = function (matrix, vertices, beginOffset, endOffset, padX, padY) {\n    if (padX === void 0) {\n      padX = 0;\n    }\n    if (padY === void 0) {\n      padY = padX;\n    }\n    var a = matrix.a;\n    var b = matrix.b;\n    var c = matrix.c;\n    var d = matrix.d;\n    var tx = matrix.tx;\n    var ty = matrix.ty;\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    for (var i = beginOffset; i < endOffset; i += 2) {\n      var rawX = vertices[i];\n      var rawY = vertices[i + 1];\n      var x = a * rawX + c * rawY + tx;\n      var y = d * rawY + b * rawX + ty;\n      minX = Math.min(minX, x - padX);\n      maxX = Math.max(maxX, x + padX);\n      minY = Math.min(minY, y - padY);\n      maxY = Math.max(maxY, y + padY);\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  /**\n   * Adds other Bounds.\n   *\n   * @param {PIXI.Bounds} bounds - The Bounds to be added\n   */\n  Bounds.prototype.addBounds = function (bounds) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    this.minX = bounds.minX < minX ? bounds.minX : minX;\n    this.minY = bounds.minY < minY ? bounds.minY : minY;\n    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n  };\n  /**\n   * Adds other Bounds, masked with Bounds.\n   *\n   * @param {PIXI.Bounds} bounds - The Bounds to be added.\n   * @param {PIXI.Bounds} mask - TODO\n   */\n  Bounds.prototype.addBoundsMask = function (bounds, mask) {\n    var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n    var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n    var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n    var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      var minX = this.minX;\n      var minY = this.minY;\n      var maxX = this.maxX;\n      var maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  };\n  /**\n   * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\n   *\n   * @param {PIXI.Bounds} bounds - other bounds\n   * @param {PIXI.Matrix} matrix - multiplicator\n   */\n  Bounds.prototype.addBoundsMatrix = function (bounds, matrix) {\n    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n  };\n  /**\n   * Adds other Bounds, masked with Rectangle.\n   *\n   * @param {PIXI.Bounds} bounds - TODO\n   * @param {PIXI.Rectangle} area - TODO\n   */\n  Bounds.prototype.addBoundsArea = function (bounds, area) {\n    var _minX = bounds.minX > area.x ? bounds.minX : area.x;\n    var _minY = bounds.minY > area.y ? bounds.minY : area.y;\n    var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;\n    var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      var minX = this.minX;\n      var minY = this.minY;\n      var maxX = this.maxX;\n      var maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  };\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   *\n   * @param {number} [paddingX=0] - The horizontal padding amount.\n   * @param {number} [paddingY=0] - The vertical padding amount.\n   */\n  Bounds.prototype.pad = function (paddingX, paddingY) {\n    if (paddingX === void 0) {\n      paddingX = 0;\n    }\n    if (paddingY === void 0) {\n      paddingY = paddingX;\n    }\n    if (!this.isEmpty()) {\n      this.minX -= paddingX;\n      this.maxX += paddingX;\n      this.minY -= paddingY;\n      this.maxY += paddingY;\n    }\n  };\n  /**\n   * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n   *\n   * @param {number} x0 - left X of frame\n   * @param {number} y0 - top Y of frame\n   * @param {number} x1 - right X of frame\n   * @param {number} y1 - bottom Y of frame\n   * @param {number} padX - padding X\n   * @param {number} padY - padding Y\n   */\n  Bounds.prototype.addFramePad = function (x0, y0, x1, y1, padX, padY) {\n    x0 -= padX;\n    y0 -= padY;\n    x1 += padX;\n    y1 += padY;\n    this.minX = this.minX < x0 ? this.minX : x0;\n    this.maxX = this.maxX > x1 ? this.maxX : x1;\n    this.minY = this.minY < y0 ? this.minY : y0;\n    this.maxY = this.maxY > y1 ? this.maxY : y1;\n  };\n  return Bounds;\n}();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and should not be used on its own; rather it should b e extended.\n *\n * @class\n * @extends PIXI.utils.EventEmitter\n * @memberof PIXI\n */\nvar DisplayObject = /** @class */function (_super) {\n  __extends(DisplayObject, _super);\n  function DisplayObject() {\n    var _this = _super.call(this) || this;\n    _this.tempDisplayObjectParent = null;\n    // TODO: need to create Transform from factory\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing.\n     *\n     * @member {PIXI.Transform}\n     */\n    _this.transform = new Transform();\n    /**\n     * The opacity of the object.\n     *\n     * @member {number}\n     */\n    _this.alpha = 1;\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n     *\n     * @member {boolean}\n     */\n    _this.visible = true;\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually.\n     *\n     * @member {boolean}\n     */\n    _this.renderable = true;\n    /**\n     * The display object container that contains this display object.\n     *\n     * @member {PIXI.Container}\n     */\n    _this.parent = null;\n    /**\n     * The multiplied alpha of the displayObject.\n     *\n     * @member {number}\n     * @readonly\n     */\n    _this.worldAlpha = 1;\n    /**\n     * Which index in the children array the display component was before the previous zIndex sort.\n     * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n     *\n     * @member {number}\n     * @protected\n     */\n    _this._lastSortedIndex = 0;\n    /**\n     * The zIndex of the displayObject.\n     * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n     *\n     * @member {number}\n     * @protected\n     */\n    _this._zIndex = 0;\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     *\n     * @member {?PIXI.Rectangle}\n     */\n    _this.filterArea = null;\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     *\n     * @member {?PIXI.Filter[]}\n     */\n    _this.filters = null;\n    /**\n     * Currently enabled filters\n     * @member {PIXI.Filter[]}\n     * @protected\n     */\n    _this._enabledFilters = null;\n    /**\n     * The bounds object, this is used to calculate and store the bounds of the displayObject.\n     *\n     * @member {PIXI.Bounds}\n     */\n    _this._bounds = new Bounds();\n    /**\n     * Local bounds object, swapped with `_bounds` when using `getLocalBounds()`.\n     *\n     * @member {PIXI.Bounds}\n     */\n    _this._localBounds = null;\n    /**\n     * Flags the cached bounds as dirty.\n     *\n     * @member {number}\n     * @protected\n     */\n    _this._boundsID = 0;\n    /**\n     * Cache of this display-object's bounds-rectangle.\n     *\n     * @member {PIXI.Bounds}\n     * @protected\n     */\n    _this._boundsRect = null;\n    /**\n     * Cache of this display-object's local-bounds rectangle.\n     *\n     * @member {PIXI.Bounds}\n     * @protected\n     */\n    _this._localBoundsRect = null;\n    /**\n     * The original, cached mask of the object.\n     *\n     * @member {PIXI.Container|PIXI.MaskData|null}\n     * @protected\n     */\n    _this._mask = null;\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     *\n     * @event PIXI.DisplayObject#added\n     * @param {PIXI.Container} container - The container added to.\n     */\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     *\n     * @event PIXI.DisplayObject#removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n    /**\n     * If the object has been destroyed via destroy(). If true, it should not be used.\n     *\n     * @member {boolean}\n     * @protected\n     */\n    _this._destroyed = false;\n    /**\n     * used to fast check if a sprite is.. a sprite!\n     * @member {boolean}\n     */\n    _this.isSprite = false;\n    /**\n     * Does any other displayObject use this object as a mask?\n     * @member {boolean}\n     */\n    _this.isMask = false;\n    return _this;\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to DisplayObject.\n   *\n   * @param {object} source - The source of properties and methods to mix in.\n   */\n  DisplayObject.mixin = function (source) {\n    // in ES8/ES2017, this would be really easy:\n    // Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n    // get all the enumerable property keys\n    var keys = Object.keys(source);\n    // loop through properties\n    for (var i = 0; i < keys.length; ++i) {\n      var propertyName = keys[i];\n      // Set the property using the property descriptor - this works for accessors and normal value properties\n      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));\n    }\n  };\n  /**\n   * Recursively updates transform of all objects from the root to this one\n   * internal function for toLocal()\n   */\n  DisplayObject.prototype._recursivePostUpdateTransform = function () {\n    if (this.parent) {\n      this.parent._recursivePostUpdateTransform();\n      this.transform.updateTransform(this.parent.transform);\n    } else {\n      this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }\n  };\n  /**\n   * Updates the object transform for rendering.\n   *\n   * TODO - Optimization pass!\n   */\n  DisplayObject.prototype.updateTransform = function () {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    // multiply the alphas..\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  };\n  /**\n   * Retrieves the bounds of the displayObject as a rectangle object.\n   *\n   * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n   * @return {PIXI.Rectangle} The rectangular bounding area.\n   */\n  DisplayObject.prototype.getBounds = function (skipUpdate, rect) {\n    if (!skipUpdate) {\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n      } else {\n        this._recursivePostUpdateTransform();\n        this.updateTransform();\n      }\n    }\n    if (this._bounds.updateID !== this._boundsID) {\n      this.calculateBounds();\n      this._bounds.updateID = this._boundsID;\n    }\n    if (!rect) {\n      if (!this._boundsRect) {\n        this._boundsRect = new Rectangle();\n      }\n      rect = this._boundsRect;\n    }\n    return this._bounds.getRectangle(rect);\n  };\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object.\n   *\n   * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n   * @return {PIXI.Rectangle} The rectangular bounding area.\n   */\n  DisplayObject.prototype.getLocalBounds = function (rect) {\n    if (!rect) {\n      if (!this._localBoundsRect) {\n        this._localBoundsRect = new Rectangle();\n      }\n      rect = this._localBoundsRect;\n    }\n    if (!this._localBounds) {\n      this._localBounds = new Bounds();\n    }\n    var transformRef = this.transform;\n    var parentRef = this.parent;\n    this.parent = null;\n    this.transform = this._tempDisplayObjectParent.transform;\n    var worldBounds = this._bounds;\n    var worldBoundsID = this._boundsID;\n    this._bounds = this._localBounds;\n    var bounds = this.getBounds(false, rect);\n    this.parent = parentRef;\n    this.transform = transformRef;\n    this._bounds = worldBounds;\n    this._bounds.updateID += this._boundsID - worldBoundsID; // reflect side-effects\n    return bounds;\n  };\n  /**\n   * Calculates the global position of the display object.\n   *\n   * @param {PIXI.IPointData} position - The world origin to calculate from.\n   * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param {boolean} [skipUpdate=false] - Should we skip the update transform.\n   * @return {PIXI.Point} A point object representing the position of this object.\n   */\n  DisplayObject.prototype.toGlobal = function (position, point, skipUpdate) {\n    if (skipUpdate === void 0) {\n      skipUpdate = false;\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    // don't need to update the lot\n    return this.worldTransform.apply(position, point);\n  };\n  /**\n   * Calculates the local position of the display object relative to another point.\n   *\n   * @param {PIXI.IPointData} position - The world origin to calculate from.\n   * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.\n   * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param {boolean} [skipUpdate=false] - Should we skip the update transform\n   * @return {PIXI.Point} A point object representing the position of this object\n   */\n  DisplayObject.prototype.toLocal = function (position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    // simply apply the matrix..\n    return this.worldTransform.applyInverse(position, point);\n  };\n  /**\n   * Set the parent Container of this DisplayObject.\n   *\n   * @param {PIXI.Container} container - The Container to add this DisplayObject to.\n   * @return {PIXI.Container} The Container that this DisplayObject was added to.\n   */\n  DisplayObject.prototype.setParent = function (container) {\n    if (!container || !container.addChild) {\n      throw new Error('setParent: Argument must be a Container');\n    }\n    container.addChild(this);\n    return container;\n  };\n  /**\n   * Convenience function to set the position, scale, skew and pivot at once.\n   *\n   * @param {number} [x=0] - The X position\n   * @param {number} [y=0] - The Y position\n   * @param {number} [scaleX=1] - The X scale value\n   * @param {number} [scaleY=1] - The Y scale value\n   * @param {number} [rotation=0] - The rotation\n   * @param {number} [skewX=0] - The X skew value\n   * @param {number} [skewY=0] - The Y skew value\n   * @param {number} [pivotX=0] - The X pivot value\n   * @param {number} [pivotY=0] - The Y pivot value\n   * @return {PIXI.DisplayObject} The DisplayObject instance\n   */\n  DisplayObject.prototype.setTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {\n    if (x === void 0) {\n      x = 0;\n    }\n    if (y === void 0) {\n      y = 0;\n    }\n    if (scaleX === void 0) {\n      scaleX = 1;\n    }\n    if (scaleY === void 0) {\n      scaleY = 1;\n    }\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n    if (skewX === void 0) {\n      skewX = 0;\n    }\n    if (skewY === void 0) {\n      skewY = 0;\n    }\n    if (pivotX === void 0) {\n      pivotX = 0;\n    }\n    if (pivotY === void 0) {\n      pivotY = 0;\n    }\n    this.position.x = x;\n    this.position.y = y;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation;\n    this.skew.x = skewX;\n    this.skew.y = skewY;\n    this.pivot.x = pivotX;\n    this.pivot.y = pivotY;\n    return this;\n  };\n  /**\n   * Base destroy method for generic display objects. This will automatically\n   * remove the display object from its parent Container as well as remove\n   * all current event listeners and internal references. Do not use a DisplayObject\n   * after calling `destroy()`.\n   *\n   */\n  DisplayObject.prototype.destroy = function (_options) {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this.removeAllListeners();\n    this.transform = null;\n    this.parent = null;\n    this._bounds = null;\n    this._mask = null;\n    this.filters = null;\n    this.filterArea = null;\n    this.hitArea = null;\n    this.interactive = false;\n    this.interactiveChildren = false;\n    this._destroyed = true;\n  };\n  Object.defineProperty(DisplayObject.prototype, \"_tempDisplayObjectParent\", {\n    /**\n     * @protected\n     * @member {PIXI.Container}\n     */\n    get: function () {\n      if (this.tempDisplayObjectParent === null) {\n        // eslint-disable-next-line no-use-before-define\n        this.tempDisplayObjectParent = new TemporaryDisplayObject();\n      }\n      return this.tempDisplayObjectParent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root\n   *\n   * ```\n   * const cacheParent = elem.enableTempParent();\n   * elem.updateTransform();\n   * elem.disableTempParent(cacheParent);\n   * ```\n   *\n   * @returns {PIXI.DisplayObject} current parent\n   */\n  DisplayObject.prototype.enableTempParent = function () {\n    var myParent = this.parent;\n    this.parent = this._tempDisplayObjectParent;\n    return myParent;\n  };\n  /**\n   * Pair method for `enableTempParent`\n   * @param {PIXI.DisplayObject} cacheParent actual parent of element\n   */\n  DisplayObject.prototype.disableTempParent = function (cacheParent) {\n    this.parent = cacheParent;\n  };\n  Object.defineProperty(DisplayObject.prototype, \"x\", {\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     *\n     * @member {number}\n     */\n    get: function () {\n      return this.position.x;\n    },\n    set: function (value) {\n      this.transform.position.x = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"y\", {\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     *\n     * @member {number}\n     */\n    get: function () {\n      return this.position.y;\n    },\n    set: function (value) {\n      this.transform.position.y = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"worldTransform\", {\n    /**\n     * Current transform of the object based on world (parent) factors.\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get: function () {\n      return this.transform.worldTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"localTransform\", {\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get: function () {\n      return this.transform.localTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"position\", {\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get: function () {\n      return this.transform.position;\n    },\n    set: function (value) {\n      this.transform.position.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"scale\", {\n    /**\n     * The scale factor of the object.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get: function () {\n      return this.transform.scale;\n    },\n    set: function (value) {\n      this.transform.scale.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"pivot\", {\n    /**\n     * The pivot point of the displayObject that it rotates around.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get: function () {\n      return this.transform.pivot;\n    },\n    set: function (value) {\n      this.transform.pivot.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"skew\", {\n    /**\n     * The skew factor for the object in radians.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get: function () {\n      return this.transform.skew;\n    },\n    set: function (value) {\n      this.transform.skew.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"rotation\", {\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     *\n     * @member {number}\n     */\n    get: function () {\n      return this.transform.rotation;\n    },\n    set: function (value) {\n      this.transform.rotation = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"angle\", {\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     *\n     * @member {number}\n     */\n    get: function () {\n      return this.transform.rotation * RAD_TO_DEG;\n    },\n    set: function (value) {\n      this.transform.rotation = value * DEG_TO_RAD;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"zIndex\", {\n    /**\n     * The zIndex of the displayObject.\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other displayObjects within the same container.\n     *\n     * @member {number}\n     */\n    get: function () {\n      return this._zIndex;\n    },\n    set: function (value) {\n      this._zIndex = value;\n      if (this.parent) {\n        this.parent.sortDirty = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"worldVisible\", {\n    /**\n     * Indicates if the object is globally visible.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    get: function () {\n      var item = this;\n      do {\n        if (!item.visible) {\n          return false;\n        }\n        item = item.parent;\n      } while (item);\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"mask\", {\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * const graphics = new PIXI.Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.mask = graphics;\n     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     *\n     * @member {PIXI.Container|PIXI.MaskData|null}\n     */\n    get: function () {\n      return this._mask;\n    },\n    set: function (value) {\n      if (this._mask) {\n        var maskObject = this._mask.maskObject || this._mask;\n        maskObject.renderable = true;\n        maskObject.isMask = false;\n      }\n      this._mask = value;\n      if (this._mask) {\n        var maskObject = this._mask.maskObject || this._mask;\n        maskObject.renderable = false;\n        maskObject.isMask = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return DisplayObject;\n}(EventEmitter);\nvar TemporaryDisplayObject = /** @class */function (_super) {\n  __extends(TemporaryDisplayObject, _super);\n  function TemporaryDisplayObject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.sortDirty = null;\n    return _this;\n  }\n  return TemporaryDisplayObject;\n}(DisplayObject);\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.DisplayObject#\n * @function displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\nfunction sortChildren(a, b) {\n  if (a.zIndex === b.zIndex) {\n    return a._lastSortedIndex - b._lastSortedIndex;\n  }\n  return a.zIndex - b.zIndex;\n}\n/**\n * A Container represents a collection of display objects.\n *\n * It is the base class of all display objects that act as a container for other objects (like Sprites).\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\nvar Container = /** @class */function (_super) {\n  __extends(Container, _super);\n  function Container() {\n    var _this = _super.call(this) || this;\n    /**\n     * The array of children of this container.\n     *\n     * @member {PIXI.DisplayObject[]}\n     * @readonly\n     */\n    _this.children = [];\n    /**\n     * If set to true, the container will sort its children by zIndex value\n     * when updateTransform() is called, or manually if sortChildren() is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as @link https://github.com/pixijs/pixi-display\n     *\n     * Also be aware of that this may not work nicely with the addChildAt() function,\n     * as the zIndex sorting may cause the child to automatically sorted to another position.\n     *\n     * @see PIXI.settings.SORTABLE_CHILDREN\n     *\n     * @member {boolean}\n     */\n    _this.sortableChildren = settings.SORTABLE_CHILDREN;\n    /**\n     * Should children be sorted by zIndex at the next updateTransform call.\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     *\n     * @member {boolean}\n     */\n    _this.sortDirty = false;\n    return _this;\n    /**\n     * Fired when a DisplayObject is added to this Container.\n     *\n     * @event PIXI.Container#childAdded\n     * @param {PIXI.DisplayObject} child - The child added to the Container.\n     * @param {PIXI.Container} container - The container that added the child.\n     * @param {number} index - The children's index of the added child.\n     */\n    /**\n     * Fired when a DisplayObject is removed from this Container.\n     *\n     * @event PIXI.DisplayObject#removedFrom\n     * @param {PIXI.DisplayObject} child - The child removed from the Container.\n     * @param {PIXI.Container} container - The container that removed removed the child.\n     * @param {number} index - The former children's index of the removed child\n     */\n  }\n  /**\n   * Overridable method that can be used by Container subclasses whenever the children array is modified\n   *\n   * @protected\n   */\n  Container.prototype.onChildrenChange = function (_length) {\n    /* empty */\n  };\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   *\n   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\n   * @return {PIXI.DisplayObject} The first child that was added.\n   */\n  Container.prototype.addChild = function () {\n    var arguments$1 = arguments;\n    var children = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      children[_i] = arguments$1[_i];\n    }\n    // if there is only one argument we can bypass looping through the them\n    if (children.length > 1) {\n      // loop through the array and add all children\n      for (var i = 0; i < children.length; i++) {\n        // eslint-disable-next-line prefer-rest-params\n        this.addChild(children[i]);\n      }\n    } else {\n      var child = children[0];\n      // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n      child.parent = this;\n      this.sortDirty = true;\n      // ensure child transform will be recalculated\n      child.transform._parentID = -1;\n      this.children.push(child);\n      // ensure bounds will be recalculated\n      this._boundsID++;\n      // TODO - lets either do all callbacks or all events.. not both!\n      this.onChildrenChange(this.children.length - 1);\n      this.emit('childAdded', child, this, this.children.length - 1);\n      child.emit('added', this);\n    }\n    return children[0];\n  };\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n   *\n   * @param {PIXI.DisplayObject} child - The child to add\n   * @param {number} index - The index to place the child in\n   * @return {PIXI.DisplayObject} The child that was added.\n   */\n  Container.prototype.addChildAt = function (child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(child + \"addChildAt: The index \" + index + \" supplied is out of bounds \" + this.children.length);\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    child.parent = this;\n    this.sortDirty = true;\n    // ensure child transform will be recalculated\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child);\n    // ensure bounds will be recalculated\n    this._boundsID++;\n    // TODO - lets either do all callbacks or all events.. not both!\n    this.onChildrenChange(index);\n    child.emit('added', this);\n    this.emit('childAdded', child, this, index);\n    return child;\n  };\n  /**\n   * Swaps the position of 2 Display Objects within this container.\n   *\n   * @param {PIXI.DisplayObject} child - First display object to swap\n   * @param {PIXI.DisplayObject} child2 - Second display object to swap\n   */\n  Container.prototype.swapChildren = function (child, child2) {\n    if (child === child2) {\n      return;\n    }\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  };\n  /**\n   * Returns the index position of a child DisplayObject instance\n   *\n   * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n   * @return {number} The index position of the child display object to identify\n   */\n  Container.prototype.getChildIndex = function (child) {\n    var index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n    return index;\n  };\n  /**\n   * Changes the position of an existing child in the display object container\n   *\n   * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n   * @param {number} index - The resulting index number for the child display object\n   */\n  Container.prototype.setChildIndex = function (child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(\"The index \" + index + \" supplied is out of bounds \" + this.children.length);\n    }\n    var currentIndex = this.getChildIndex(child);\n    removeItems(this.children, currentIndex, 1); // remove from old position\n    this.children.splice(index, 0, child); // add at new position\n    this.onChildrenChange(index);\n  };\n  /**\n   * Returns the child at the specified index\n   *\n   * @param {number} index - The index to get the child at\n   * @return {PIXI.DisplayObject} The child at the given index, if any.\n   */\n  Container.prototype.getChildAt = function (index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(\"getChildAt: Index (\" + index + \") does not exist.\");\n    }\n    return this.children[index];\n  };\n  /**\n   * Removes one or more children from the container.\n   *\n   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\n   * @return {PIXI.DisplayObject} The first child that was removed.\n   */\n  Container.prototype.removeChild = function () {\n    var arguments$1 = arguments;\n    var children = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      children[_i] = arguments$1[_i];\n    }\n    // if there is only one argument we can bypass looping through the them\n    if (children.length > 1) {\n      // loop through the arguments property and remove all children\n      for (var i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n    } else {\n      var child = children[0];\n      var index = this.children.indexOf(child);\n      if (index === -1) {\n        return null;\n      }\n      child.parent = null;\n      // ensure child transform will be recalculated\n      child.transform._parentID = -1;\n      removeItems(this.children, index, 1);\n      // ensure bounds will be recalculated\n      this._boundsID++;\n      // TODO - lets either do all callbacks or all events.. not both!\n      this.onChildrenChange(index);\n      child.emit('removed', this);\n      this.emit('childRemoved', child, this, index);\n    }\n    return children[0];\n  };\n  /**\n   * Removes a child from the specified index position.\n   *\n   * @param {number} index - The index to get the child from\n   * @return {PIXI.DisplayObject} The child that was removed.\n   */\n  Container.prototype.removeChildAt = function (index) {\n    var child = this.getChildAt(index);\n    // ensure child transform will be recalculated..\n    child.parent = null;\n    child.transform._parentID = -1;\n    removeItems(this.children, index, 1);\n    // ensure bounds will be recalculated\n    this._boundsID++;\n    // TODO - lets either do all callbacks or all events.. not both!\n    this.onChildrenChange(index);\n    child.emit('removed', this);\n    this.emit('childRemoved', child, this, index);\n    return child;\n  };\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   *\n   * @param {number} [beginIndex=0] - The beginning position.\n   * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n   * @returns {PIXI.DisplayObject[]} List of removed children\n   */\n  Container.prototype.removeChildren = function (beginIndex, endIndex) {\n    if (beginIndex === void 0) {\n      beginIndex = 0;\n    }\n    if (endIndex === void 0) {\n      endIndex = this.children.length;\n    }\n    var begin = beginIndex;\n    var end = endIndex;\n    var range = end - begin;\n    var removed;\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n      for (var i = 0; i < removed.length; ++i) {\n        removed[i].parent = null;\n        if (removed[i].transform) {\n          removed[i].transform._parentID = -1;\n        }\n      }\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n      for (var i = 0; i < removed.length; ++i) {\n        removed[i].emit('removed', this);\n        this.emit('childRemoved', removed[i], this, i);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n    throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n  };\n  /**\n   * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.\n   */\n  Container.prototype.sortChildren = function () {\n    var sortRequired = false;\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n      child._lastSortedIndex = i;\n      if (!sortRequired && child.zIndex !== 0) {\n        sortRequired = true;\n      }\n    }\n    if (sortRequired && this.children.length > 1) {\n      this.children.sort(sortChildren);\n    }\n    this.sortDirty = false;\n  };\n  /**\n   * Updates the transform on all children of this container for rendering\n   */\n  Container.prototype.updateTransform = function () {\n    if (this.sortableChildren && this.sortDirty) {\n      this.sortChildren();\n    }\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    // TODO: check render flags, how to process stuff here\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  };\n  /**\n   * Recalculates the bounds of the container.\n   *\n   */\n  Container.prototype.calculateBounds = function () {\n    this._bounds.clear();\n    this._calculateBounds();\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n      child.calculateBounds();\n      // TODO: filter+mask, need to mask both somehow\n      if (child._mask) {\n        var maskObject = child._mask.maskObject || child._mask;\n        maskObject.calculateBounds();\n        this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n    this._bounds.updateID = this._boundsID;\n  };\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object.\n   *\n   * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n   * @param {boolean} [skipChildrenUpdate=false] - Setting to `true` will stop re-calculation of children transforms,\n   *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\n   * @return {PIXI.Rectangle} The rectangular bounding area.\n   */\n  Container.prototype.getLocalBounds = function (rect, skipChildrenUpdate) {\n    if (skipChildrenUpdate === void 0) {\n      skipChildrenUpdate = false;\n    }\n    var result = _super.prototype.getLocalBounds.call(this, rect);\n    if (!skipChildrenUpdate) {\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        var child = this.children[i];\n        if (child.visible) {\n          child.updateTransform();\n        }\n      }\n    }\n    return result;\n  };\n  /**\n   * Recalculates the bounds of the object. Override this to\n   * calculate the bounds of the specific object (not including children).\n   *\n   * @protected\n   */\n  Container.prototype._calculateBounds = function () {\n    // FILL IN//\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  Container.prototype.render = function (renderer) {\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n    // do a quick check to see if this element has a mask or a filter.\n    if (this._mask || this.filters && this.filters.length) {\n      this.renderAdvanced(renderer);\n    } else {\n      this._render(renderer);\n      // simple render children!\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].render(renderer);\n      }\n    }\n  };\n  /**\n   * Render the object using the WebGL renderer and advanced features.\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  Container.prototype.renderAdvanced = function (renderer) {\n    renderer.batch.flush();\n    var filters = this.filters;\n    var mask = this._mask;\n    // push filter first as we need to ensure the stencil buffer is correct for any masking\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n      this._enabledFilters.length = 0;\n      for (var i = 0; i < filters.length; i++) {\n        if (filters[i].enabled) {\n          this._enabledFilters.push(filters[i]);\n        }\n      }\n      if (this._enabledFilters.length) {\n        renderer.filter.push(this, this._enabledFilters);\n      }\n    }\n    if (mask) {\n      renderer.mask.push(this, this._mask);\n    }\n    // add this object to the batch, only rendered if it has a texture.\n    this._render(renderer);\n    // now loop through the children and make sure they get rendered\n    for (var i = 0, j = this.children.length; i < j; i++) {\n      this.children[i].render(renderer);\n    }\n    renderer.batch.flush();\n    if (mask) {\n      renderer.mask.pop(this);\n    }\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filter.pop();\n    }\n  };\n  /**\n   * To be overridden by the subclasses.\n   *\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  Container.prototype._render = function (_renderer) {\n    // this is where content itself gets rendered...\n  };\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  Container.prototype.destroy = function (options) {\n    _super.prototype.destroy.call(this);\n    this.sortDirty = false;\n    var destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n    var oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (var i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  };\n  Object.defineProperty(Container.prototype, \"width\", {\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get: function () {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function (value) {\n      var width = this.getLocalBounds().width;\n      if (width !== 0) {\n        this.scale.x = value / width;\n      } else {\n        this.scale.x = 1;\n      }\n      this._width = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"height\", {\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get: function () {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function (value) {\n      var height = this.getLocalBounds().height;\n      if (height !== 0) {\n        this.scale.y = value / height;\n      } else {\n        this.scale.y = 1;\n      }\n      this._height = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Container;\n}(DisplayObject);\n/**\n * Container default updateTransform, does update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.Container#\n * @function containerUpdateTransform\n */\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\nexport { Bounds, Container, DisplayObject, TemporaryDisplayObject };","map":{"version":3,"names":["settings","SORTABLE_CHILDREN","Bounds","minX","Infinity","minY","maxX","maxY","rect","updateID","prototype","isEmpty","clear","getRectangle","Rectangle","EMPTY","x","y","width","height","addPoint","point","Math","min","max","addQuad","vertices","addFrame","transform","x0","y0","x1","y1","addFrameMatrix","worldTransform","matrix","a","b","c","d","tx","ty","addVertexData","vertexData","beginOffset","endOffset","i","addVertices","addVerticesMatrix","padX","padY","rawX","rawY","addBounds","bounds","addBoundsMask","mask","_minX","_minY","_maxX","_maxY","addBoundsMatrix","addBoundsArea","area","pad","paddingX","paddingY","addFramePad","extendStatics","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","create","DisplayObject","_super","_this","call","tempDisplayObjectParent","Transform","alpha","visible","renderable","parent","worldAlpha","_lastSortedIndex","_zIndex","filterArea","filters","_enabledFilters","_bounds","_localBounds","_boundsID","_boundsRect","_localBoundsRect","_mask","_destroyed","isSprite","isMask","mixin","source","keys","length","propertyName","defineProperty","getOwnPropertyDescriptor","_recursivePostUpdateTransform","updateTransform","_tempDisplayObjectParent","getBounds","skipUpdate","calculateBounds","getLocalBounds","transformRef","parentRef","worldBounds","worldBoundsID","toGlobal","position","displayObjectUpdateTransform","apply","toLocal","from","applyInverse","setParent","container","addChild","Error","setTransform","scaleX","scaleY","rotation","skewX","skewY","pivotX","pivotY","scale","skew","pivot","destroy","_options","removeChild","removeAllListeners","hitArea","interactive","interactiveChildren","get","TemporaryDisplayObject","enableTempParent","myParent","disableTempParent","cacheParent","set","value","localTransform","copyFrom","RAD_TO_DEG","DEG_TO_RAD","sortDirty","item","maskObject","EventEmitter","arguments","sortChildren","zIndex","Container","children","sortableChildren","onChildrenChange","_length","_i","arguments$1","child","_parentID","push","emit","addChildAt","index","splice","swapChildren","child2","index1","getChildIndex","index2","indexOf","setChildIndex","currentIndex","removeItems","getChildAt","removeChildAt","removeChildren","beginIndex","endIndex","begin","end","range","removed","RangeError","sortRequired","j","sort","_calculateBounds","skipChildrenUpdate","result","render","renderer","renderAdvanced","_render","batch","flush","enabled","filter","pop","_renderer","options","destroyChildren","oldChildren","_width","_height","containerUpdateTransform"],"sources":["/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/display/src/settings.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/display/src/Bounds.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/node_modules/tslib/tslib.es6.js","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/display/src/DisplayObject.ts","/Users/kareenarachel/Documents/Github/orbital-bombardment-simulator/orbital-bombardment-simulator/node_modules/@pixi/display/src/Container.ts"],"sourcesContent":["import { settings } from '@pixi/settings';\n\n/**\n * Sets the default value for the container property 'sortableChildren'.\n * If set to true, the container will sort its children by zIndex value\n * when updateTransform() is called, or manually if sortChildren() is called.\n *\n * This actually changes the order of elements in the array, so should be treated\n * as a basic solution that is not performant compared to other solutions,\n * such as @link https://github.com/pixijs/pixi-display\n *\n * Also be aware of that this may not work nicely with the addChildAt() function,\n * as the zIndex sorting may cause the child to automatically sorted to another position.\n *\n * @static\n * @constant\n * @name SORTABLE_CHILDREN\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */\nsettings.SORTABLE_CHILDREN = false;\n\nexport { settings };\n","import { Rectangle } from '@pixi/math';\n\nimport type { IPointData, Transform, Matrix } from '@pixi/math';\n\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n *\n * @class\n * @memberof PIXI\n */\nexport class Bounds\n{\n    public minX: number;\n    public minY: number;\n    public maxX: number;\n    public maxY: number;\n    public rect: Rectangle;\n    public updateID: number;\n\n    constructor()\n    {\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.minX = Infinity;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.minY = Infinity;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.maxX = -Infinity;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.maxY = -Infinity;\n\n        this.rect = null;\n\n        /**\n         * It is updated to _boundsID of corresponding object to keep bounds in sync with content.\n         * Updated from outside, thus public modifier.\n         *\n         * @member {number}\n         * @public\n         */\n        this.updateID = -1;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     *\n     * @return {boolean} True if empty.\n     */\n    isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /**\n     * Clears the bounds and resets.\n     *\n     */\n    clear(): void\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n    }\n\n    /**\n     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n     * It is not guaranteed that it will return tempRect\n     *\n     * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty\n     * @returns {PIXI.Rectangle} A rectangle of the bounds\n     */\n    getRectangle(rect?: Rectangle): Rectangle\n    {\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            return Rectangle.EMPTY;\n        }\n\n        rect = rect || new Rectangle(0, 0, 1, 1);\n\n        rect.x = this.minX;\n        rect.y = this.minY;\n        rect.width = this.maxX - this.minX;\n        rect.height = this.maxY - this.minY;\n\n        return rect;\n    }\n\n    /**\n     * This function should be inlined when its possible.\n     *\n     * @param {PIXI.IPointData} point - The point to add.\n     */\n    addPoint(point: IPointData): void\n    {\n        this.minX = Math.min(this.minX, point.x);\n        this.maxX = Math.max(this.maxX, point.x);\n        this.minY = Math.min(this.minY, point.y);\n        this.maxY = Math.max(this.maxY, point.y);\n    }\n\n    /**\n     * Adds a quad, not transformed\n     *\n     * @param {Float32Array} vertices - The verts to add.\n     */\n    addQuad(vertices: Float32Array): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = vertices[0];\n        let y = vertices[1];\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[2];\n        y = vertices[3];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[4];\n        y = vertices[5];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[6];\n        y = vertices[7];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds sprite frame, transformed.\n     *\n     * @param {PIXI.Transform} transform - transform to apply\n     * @param {number} x0 - left X of frame\n     * @param {number} y0 - top Y of frame\n     * @param {number} x1 - right X of frame\n     * @param {number} y1 - bottom Y of frame\n     */\n    addFrame(transform: Transform, x0: number, y0: number, x1: number, y1: number): void\n    {\n        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n    }\n\n    /**\n     * Adds sprite frame, multiplied by matrix\n     *\n     * @param {PIXI.Matrix} matrix - matrix to apply\n     * @param {number} x0 - left X of frame\n     * @param {number} y0 - top Y of frame\n     * @param {number} x1 - right X of frame\n     * @param {number} y1 - bottom Y of frame\n     */\n    addFrameMatrix(matrix: Matrix, x0: number, y0: number, x1: number, y1: number): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds screen vertices from array\n     *\n     * @param {Float32Array} vertexData - calculated vertices\n     * @param {number} beginOffset - begin offset\n     * @param {number} endOffset - end offset, excluded\n     */\n    addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const x = vertexData[i];\n            const y = vertexData[i + 1];\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Add an array of mesh vertices\n     *\n     * @param {PIXI.Transform} transform - mesh transform\n     * @param {Float32Array} vertices - mesh coordinates in array\n     * @param {number} beginOffset - begin offset\n     * @param {number} endOffset - end offset, excluded\n     */\n    addVertices(transform: Transform, vertices: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n    }\n\n    /**\n     * Add an array of mesh vertices.\n     *\n     * @param {PIXI.Matrix} matrix - mesh matrix\n     * @param {Float32Array} vertices - mesh coordinates in array\n     * @param {number} beginOffset - begin offset\n     * @param {number} endOffset - end offset, excluded\n     * @param {number} [padX=0] - x padding\n     * @param {number} [padY=0] - y padding\n     */\n    addVerticesMatrix(matrix: Matrix, vertices: Float32Array, beginOffset: number,\n        endOffset: number, padX = 0, padY = padX): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const rawX = vertices[i];\n            const rawY = vertices[i + 1];\n            const x = (a * rawX) + (c * rawY) + tx;\n            const y = (d * rawY) + (b * rawX) + ty;\n\n            minX = Math.min(minX, x - padX);\n            maxX = Math.max(maxX, x + padX);\n            minY = Math.min(minY, y - padY);\n            maxY = Math.max(maxY, y + padY);\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds other Bounds.\n     *\n     * @param {PIXI.Bounds} bounds - The Bounds to be added\n     */\n    addBounds(bounds: Bounds): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        this.minX = bounds.minX < minX ? bounds.minX : minX;\n        this.minY = bounds.minY < minY ? bounds.minY : minY;\n        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     *\n     * @param {PIXI.Bounds} bounds - The Bounds to be added.\n     * @param {PIXI.Bounds} mask - TODO\n     */\n    addBoundsMask(bounds: Bounds, mask: Bounds): void\n    {\n        const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n        const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n        const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n        const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\n     *\n     * @param {PIXI.Bounds} bounds - other bounds\n     * @param {PIXI.Matrix} matrix - multiplicator\n     */\n    addBoundsMatrix(bounds: Bounds, matrix: Matrix): void\n    {\n        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n    }\n\n    /**\n     * Adds other Bounds, masked with Rectangle.\n     *\n     * @param {PIXI.Bounds} bounds - TODO\n     * @param {PIXI.Rectangle} area - TODO\n     */\n    addBoundsArea(bounds: Bounds, area: Rectangle): void\n    {\n        const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n        const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n        const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);\n        const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     *\n     * @param {number} [paddingX=0] - The horizontal padding amount.\n     * @param {number} [paddingY=0] - The vertical padding amount.\n     */\n    pad(paddingX = 0, paddingY = paddingX): void\n    {\n        if (!this.isEmpty())\n        {\n            this.minX -= paddingX;\n            this.maxX += paddingX;\n            this.minY -= paddingY;\n            this.maxY += paddingY;\n        }\n    }\n\n    /**\n     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n     *\n     * @param {number} x0 - left X of frame\n     * @param {number} y0 - top Y of frame\n     * @param {number} x1 - right X of frame\n     * @param {number} y1 - bottom Y of frame\n     * @param {number} padX - padding X\n     * @param {number} padY - padding Y\n     */\n    addFramePad(x0: number, y0: number, x1: number, y1: number, padX: number, padY: number): void\n    {\n        x0 -= padX;\n        y0 -= padY;\n        x1 += padX;\n        y1 += padY;\n\n        this.minX = this.minX < x0 ? this.minX : x0;\n        this.maxX = this.maxX > x1 ? this.maxX : x1;\n        this.minY = this.minY < y0 ? this.minY : y0;\n        this.maxY = this.maxY > y1 ? this.maxY : y1;\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { DEG_TO_RAD, Matrix, Point, RAD_TO_DEG, Rectangle, Transform } from '@pixi/math';\nimport { EventEmitter } from '@pixi/utils';\nimport { Container } from './Container';\nimport { Bounds } from './Bounds';\n\nimport type { Filter, MaskData, Renderer } from '@pixi/core';\nimport type { IPointData, ObservablePoint } from '@pixi/math';\nimport type { Dict } from '@pixi/utils';\n\nexport interface IDestroyOptions {\n    children?: boolean;\n    texture?: boolean;\n    baseTexture?: boolean;\n}\n\nexport interface DisplayObject extends GlobalMixins.DisplayObject, EventEmitter {}\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and should not be used on its own; rather it should b e extended.\n *\n * @class\n * @extends PIXI.utils.EventEmitter\n * @memberof PIXI\n */\nexport abstract class DisplayObject extends EventEmitter\n{\n    abstract sortDirty: boolean;\n\n    public parent: DisplayObject;\n    public worldAlpha: number;\n    public transform: Transform;\n    public alpha: number;\n    public visible: boolean;\n    public renderable: boolean;\n    public filterArea: Rectangle;\n    public filters: Filter[];\n    public isSprite: boolean;\n    public isMask: boolean;\n    public _lastSortedIndex: number;\n    public _mask: Container|MaskData;\n    public _bounds: Bounds;\n    public _localBounds: Bounds;\n\n    protected _zIndex: number;\n    protected _enabledFilters: Filter[];\n    protected _boundsID: number;\n    protected _boundsRect: Rectangle;\n    protected _localBoundsRect: Rectangle;\n    protected _destroyed: boolean;\n\n    private tempDisplayObjectParent: TemporaryDisplayObject;\n    public displayObjectUpdateTransform: () => void;\n\n    /**\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\n     *\n     * @param {object} source - The source of properties and methods to mix in.\n     */\n    static mixin(source: Dict<any>): void\n    {\n        // in ES8/ES2017, this would be really easy:\n        // Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n\n        // get all the enumerable property keys\n        const keys = Object.keys(source);\n\n        // loop through properties\n        for (let i = 0; i < keys.length; ++i)\n        {\n            const propertyName = keys[i];\n\n            // Set the property using the property descriptor - this works for accessors and normal value properties\n            Object.defineProperty(\n                DisplayObject.prototype,\n                propertyName,\n                Object.getOwnPropertyDescriptor(source, propertyName)\n            );\n        }\n    }\n\n    constructor()\n    {\n        super();\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        /**\n         * World transform and local transform of this object.\n         * This will become read-only later, please do not assign anything there unless you know what are you doing.\n         *\n         * @member {PIXI.Transform}\n         */\n        this.transform = new Transform();\n\n        /**\n         * The opacity of the object.\n         *\n         * @member {number}\n         */\n        this.alpha = 1;\n\n        /**\n         * The visibility of the object. If false the object will not be drawn, and\n         * the updateTransform function will not be called.\n         *\n         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n         *\n         * @member {boolean}\n         */\n        this.visible = true;\n\n        /**\n         * Can this object be rendered, if false the object will not be drawn but the updateTransform\n         * methods will still be called.\n         *\n         * Only affects recursive calls from parent. You can ask for bounds manually.\n         *\n         * @member {boolean}\n         */\n        this.renderable = true;\n\n        /**\n         * The display object container that contains this display object.\n         *\n         * @member {PIXI.Container}\n         */\n        this.parent = null;\n\n        /**\n         * The multiplied alpha of the displayObject.\n         *\n         * @member {number}\n         * @readonly\n         */\n        this.worldAlpha = 1;\n\n        /**\n         * Which index in the children array the display component was before the previous zIndex sort.\n         * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n         *\n         * @member {number}\n         * @protected\n         */\n        this._lastSortedIndex = 0;\n\n        /**\n         * The zIndex of the displayObject.\n         * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n         *\n         * @member {number}\n         * @protected\n         */\n        this._zIndex = 0;\n\n        /**\n         * The area the filter is applied to. This is used as more of an optimization\n         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n         *\n         * Also works as an interaction mask.\n         *\n         * @member {?PIXI.Rectangle}\n         */\n        this.filterArea = null;\n\n        /**\n         * Sets the filters for the displayObject.\n         * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n         * To remove filters simply set this property to `'null'`.\n         *\n         * @member {?PIXI.Filter[]}\n         */\n        this.filters = null;\n\n        /**\n         * Currently enabled filters\n         * @member {PIXI.Filter[]}\n         * @protected\n         */\n        this._enabledFilters = null;\n\n        /**\n         * The bounds object, this is used to calculate and store the bounds of the displayObject.\n         *\n         * @member {PIXI.Bounds}\n         */\n        this._bounds = new Bounds();\n\n        /**\n         * Local bounds object, swapped with `_bounds` when using `getLocalBounds()`.\n         *\n         * @member {PIXI.Bounds}\n         */\n        this._localBounds = null;\n\n        /**\n         * Flags the cached bounds as dirty.\n         *\n         * @member {number}\n         * @protected\n         */\n        this._boundsID = 0;\n\n        /**\n         * Cache of this display-object's bounds-rectangle.\n         *\n         * @member {PIXI.Bounds}\n         * @protected\n         */\n        this._boundsRect = null;\n\n        /**\n         * Cache of this display-object's local-bounds rectangle.\n         *\n         * @member {PIXI.Bounds}\n         * @protected\n         */\n        this._localBoundsRect = null;\n\n        /**\n         * The original, cached mask of the object.\n         *\n         * @member {PIXI.Container|PIXI.MaskData|null}\n         * @protected\n         */\n        this._mask = null;\n\n        /**\n         * Fired when this DisplayObject is added to a Container.\n         *\n         * @event PIXI.DisplayObject#added\n         * @param {PIXI.Container} container - The container added to.\n         */\n\n        /**\n         * Fired when this DisplayObject is removed from a Container.\n         *\n         * @event PIXI.DisplayObject#removed\n         * @param {PIXI.Container} container - The container removed from.\n         */\n\n        /**\n         * If the object has been destroyed via destroy(). If true, it should not be used.\n         *\n         * @member {boolean}\n         * @protected\n         */\n        this._destroyed = false;\n\n        /**\n         * used to fast check if a sprite is.. a sprite!\n         * @member {boolean}\n         */\n        this.isSprite = false;\n\n        /**\n         * Does any other displayObject use this object as a mask?\n         * @member {boolean}\n         */\n        this.isMask = false;\n    }\n\n    /**\n     * Recalculates the bounds of the display object.\n     */\n    abstract calculateBounds(): void;\n\n    abstract removeChild(child: DisplayObject): void;\n\n    /**\n     * Renders the object using the WebGL renderer.\n     *\n     * @param {PIXI.Renderer} renderer - The renderer.\n     */\n    abstract render(renderer: Renderer): void;\n\n    /**\n     * Recursively updates transform of all objects from the root to this one\n     * internal function for toLocal()\n     */\n    protected _recursivePostUpdateTransform(): void\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     *\n     * TODO - Optimization pass!\n     */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }\n\n    /**\n     * Retrieves the bounds of the displayObject as a rectangle object.\n     *\n     * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n     * @return {PIXI.Rectangle} The rectangular bounding area.\n     */\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._bounds.updateID !== this._boundsID)\n        {\n            this.calculateBounds();\n            this._bounds.updateID = this._boundsID;\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n     * @return {PIXI.Rectangle} The rectangular bounding area.\n     */\n    getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        if (!this._localBounds)\n        {\n            this._localBounds = new Bounds();\n        }\n\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        const worldBounds = this._bounds;\n        const worldBoundsID = this._boundsID;\n\n        this._bounds = this._localBounds;\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        this._bounds = worldBounds;\n        this._bounds.updateID += this._boundsID - worldBoundsID;// reflect side-effects\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object.\n     *\n     * @param {PIXI.IPointData} position - The world origin to calculate from.\n     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.\n     * @return {PIXI.Point} A point object representing the position of this object.\n     */\n    toGlobal<P extends IPointData = Point>(position: IPointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply<P>(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point.\n     *\n     * @param {PIXI.IPointData} position - The world origin to calculate from.\n     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.\n     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param {boolean} [skipUpdate=false] - Should we skip the update transform\n     * @return {PIXI.Point} A point object representing the position of this object\n     */\n    toLocal<P extends IPointData = Point>(position: IPointData, from: DisplayObject, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject.\n     *\n     * @param {PIXI.Container} container - The Container to add this DisplayObject to.\n     * @return {PIXI.Container} The Container that this DisplayObject was added to.\n     */\n    setParent(container: Container): Container\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     *\n     * @param {number} [x=0] - The X position\n     * @param {number} [y=0] - The Y position\n     * @param {number} [scaleX=1] - The X scale value\n     * @param {number} [scaleY=1] - The Y scale value\n     * @param {number} [rotation=0] - The rotation\n     * @param {number} [skewX=0] - The X skew value\n     * @param {number} [skewY=0] - The Y skew value\n     * @param {number} [pivotX=0] - The X pivot value\n     * @param {number} [pivotY=0] - The Y pivot value\n     * @return {PIXI.DisplayObject} The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0): this\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy()`.\n     *\n     */\n    destroy(_options?: IDestroyOptions|boolean): void\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.removeAllListeners();\n        this.transform = null;\n\n        this.parent = null;\n        this._bounds = null;\n        this._mask = null;\n\n        this.filters = null;\n        this.filterArea = null;\n        this.hitArea = null;\n\n        this.interactive = false;\n        this.interactiveChildren = false;\n\n        this._destroyed = true;\n    }\n\n    /**\n     * @protected\n     * @member {PIXI.Container}\n     */\n    get _tempDisplayObjectParent(): TemporaryDisplayObject\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            // eslint-disable-next-line no-use-before-define\n            this.tempDisplayObjectParent = new TemporaryDisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root\n     *\n     * ```\n     * const cacheParent = elem.enableTempParent();\n     * elem.updateTransform();\n     * elem.disableTempParent(cacheParent);\n     * ```\n     *\n     * @returns {PIXI.DisplayObject} current parent\n     */\n    enableTempParent(): DisplayObject\n    {\n        const myParent = this.parent;\n\n        this.parent = this._tempDisplayObjectParent;\n\n        return myParent;\n    }\n\n    /**\n     * Pair method for `enableTempParent`\n     * @param {PIXI.DisplayObject} cacheParent actual parent of element\n     */\n    disableTempParent(cacheParent: DisplayObject): void\n    {\n        this.parent = cacheParent;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     *\n     * @member {number}\n     */\n    get x(): number\n    {\n        return this.position.x;\n    }\n\n    set x(value: number)\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     *\n     * @member {number}\n     */\n    get y(): number\n    {\n        return this.position.y;\n    }\n\n    set y(value: number)\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get worldTransform(): Matrix\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get localTransform(): Matrix\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get position(): ObservablePoint\n    {\n        return this.transform.position;\n    }\n\n    set position(value: ObservablePoint)\n    {\n        this.transform.position.copyFrom(value);\n    }\n\n    /**\n     * The scale factor of the object.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get scale(): ObservablePoint\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value: ObservablePoint)\n    {\n        this.transform.scale.copyFrom(value);\n    }\n\n    /**\n     * The pivot point of the displayObject that it rotates around.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get pivot(): ObservablePoint\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value: ObservablePoint)\n    {\n        this.transform.pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get skew(): ObservablePoint\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value: ObservablePoint)\n    {\n        this.transform.skew.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     *\n     * @member {number}\n     */\n    get rotation(): number\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value: number)\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     *\n     * @member {number}\n     */\n    get angle(): number\n    {\n        return this.transform.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.transform.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The zIndex of the displayObject.\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other displayObjects within the same container.\n     *\n     * @member {number}\n     */\n    get zIndex(): number\n    {\n        return this._zIndex;\n    }\n\n    set zIndex(value: number)\n    {\n        this._zIndex = value;\n        if (this.parent)\n        {\n            this.parent.sortDirty = true;\n        }\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    get worldVisible(): boolean\n    {\n        let item = this as DisplayObject;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * const graphics = new PIXI.Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.mask = graphics;\n     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     *\n     * @member {PIXI.Container|PIXI.MaskData|null}\n     */\n    get mask(): Container|MaskData|null\n    {\n        return this._mask;\n    }\n\n    set mask(value: Container|MaskData|null)\n    {\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).maskObject || this._mask) as Container;\n\n            maskObject.renderable = true;\n            maskObject.isMask = false;\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).maskObject || this._mask) as Container;\n\n            maskObject.renderable = false;\n            maskObject.isMask = true;\n        }\n    }\n}\n\nexport class TemporaryDisplayObject extends DisplayObject\n{\n    calculateBounds: () => null;\n    removeChild: (child: DisplayObject) => null;\n    render: (renderer: Renderer) => null;\n    sortDirty: boolean = null;\n}\n\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.DisplayObject#\n * @function displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n","import { settings } from '@pixi/settings';\nimport { removeItems } from '@pixi/utils';\nimport { DisplayObject } from './DisplayObject';\nimport { Rectangle } from '@pixi/math';\n\nimport type { MaskData, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from './DisplayObject';\n\nfunction sortChildren(a: DisplayObject, b: DisplayObject): number\n{\n    if (a.zIndex === b.zIndex)\n    {\n        return a._lastSortedIndex - b._lastSortedIndex;\n    }\n\n    return a.zIndex - b.zIndex;\n}\n\nexport interface Container extends GlobalMixins.Container, DisplayObject {}\n\n/**\n * A Container represents a collection of display objects.\n *\n * It is the base class of all display objects that act as a container for other objects (like Sprites).\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\nexport class Container extends DisplayObject\n{\n    public readonly children: DisplayObject[];\n    public sortableChildren: boolean;\n    public sortDirty: boolean;\n    public containerUpdateTransform: () => void;\n\n    protected _width: number;\n    protected _height: number;\n\n    constructor()\n    {\n        super();\n\n        /**\n         * The array of children of this container.\n         *\n         * @member {PIXI.DisplayObject[]}\n         * @readonly\n         */\n        this.children = [];\n\n        /**\n         * If set to true, the container will sort its children by zIndex value\n         * when updateTransform() is called, or manually if sortChildren() is called.\n         *\n         * This actually changes the order of elements in the array, so should be treated\n         * as a basic solution that is not performant compared to other solutions,\n         * such as @link https://github.com/pixijs/pixi-display\n         *\n         * Also be aware of that this may not work nicely with the addChildAt() function,\n         * as the zIndex sorting may cause the child to automatically sorted to another position.\n         *\n         * @see PIXI.settings.SORTABLE_CHILDREN\n         *\n         * @member {boolean}\n         */\n        this.sortableChildren = settings.SORTABLE_CHILDREN;\n\n        /**\n         * Should children be sorted by zIndex at the next updateTransform call.\n         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n         *\n         * @member {boolean}\n         */\n        this.sortDirty = false;\n\n        /**\n         * Fired when a DisplayObject is added to this Container.\n         *\n         * @event PIXI.Container#childAdded\n         * @param {PIXI.DisplayObject} child - The child added to the Container.\n         * @param {PIXI.Container} container - The container that added the child.\n         * @param {number} index - The children's index of the added child.\n         */\n\n        /**\n         * Fired when a DisplayObject is removed from this Container.\n         *\n         * @event PIXI.DisplayObject#removedFrom\n         * @param {PIXI.DisplayObject} child - The child removed from the Container.\n         * @param {PIXI.Container} container - The container that removed removed the child.\n         * @param {number} index - The former children's index of the removed child\n         */\n    }\n\n    /**\n     * Overridable method that can be used by Container subclasses whenever the children array is modified\n     *\n     * @protected\n     */\n    protected onChildrenChange(_length: number): void\n    {\n        /* empty */\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     *\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\n     * @return {PIXI.DisplayObject} The first child that was added.\n     */\n    addChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                // eslint-disable-next-line prefer-rest-params\n                this.addChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0];\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            this.sortDirty = true;\n\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            this.children.push(child);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(this.children.length - 1);\n            this.emit('childAdded', child, this, this.children.length - 1);\n            child.emit('added', this);\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n     *\n     * @param {PIXI.DisplayObject} child - The child to add\n     * @param {number} index - The index to place the child in\n     * @return {PIXI.DisplayObject} The child that was added.\n     */\n    addChildAt<T extends DisplayObject>(child: T, index: number): T\n    {\n        if (index < 0 || index > this.children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        this.children.splice(index, 0, child);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n        this.emit('childAdded', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Swaps the position of 2 Display Objects within this container.\n     *\n     * @param {PIXI.DisplayObject} child - First display object to swap\n     * @param {PIXI.DisplayObject} child2 - Second display object to swap\n     */\n    swapChildren(child: DisplayObject, child2: DisplayObject): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n\n    /**\n     * Returns the index position of a child DisplayObject instance\n     *\n     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n     * @return {number} The index position of the child display object to identify\n     */\n    getChildIndex(child: DisplayObject): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    /**\n     * Changes the position of an existing child in the display object container\n     *\n     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n     * @param {number} index - The resulting index number for the child display object\n     */\n    setChildIndex(child: DisplayObject, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        const currentIndex = this.getChildIndex(child);\n\n        removeItems(this.children, currentIndex, 1); // remove from old position\n        this.children.splice(index, 0, child); // add at new position\n\n        this.onChildrenChange(index);\n    }\n\n    /**\n     * Returns the child at the specified index\n     *\n     * @param {number} index - The index to get the child at\n     * @return {PIXI.DisplayObject} The child at the given index, if any.\n     */\n    getChildAt(index: number): DisplayObject\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index];\n    }\n\n    /**\n     * Removes one or more children from the container.\n     *\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\n     * @return {PIXI.DisplayObject} The first child that was removed.\n     */\n    removeChild<T extends DisplayObject[]>(...children: T): T[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0];\n            const index = this.children.indexOf(child);\n\n            if (index === -1) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n            removeItems(this.children, index, 1);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(index);\n            child.emit('removed', this);\n            this.emit('childRemoved', child, this, index);\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Removes a child from the specified index position.\n     *\n     * @param {number} index - The index to get the child from\n     * @return {PIXI.DisplayObject} The child that was removed.\n     */\n    removeChildAt(index: number): DisplayObject\n    {\n        const child = this.getChildAt(index);\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        removeItems(this.children, index, 1);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n        this.emit('childRemoved', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     *\n     * @param {number} [beginIndex=0] - The beginning position.\n     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n     * @returns {PIXI.DisplayObject[]} List of removed children\n     */\n    removeChildren(beginIndex = 0, endIndex = this.children.length): DisplayObject[]\n    {\n        const begin = beginIndex;\n        const end = endIndex;\n        const range = end - begin;\n        let removed;\n\n        if (range > 0 && range <= end)\n        {\n            removed = this.children.splice(begin, range);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n                this.emit('childRemoved', removed[i], this, i);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /**\n     * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.\n     */\n    sortChildren(): void\n    {\n        let sortRequired = false;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            child._lastSortedIndex = i;\n\n            if (!sortRequired && child.zIndex !== 0)\n            {\n                sortRequired = true;\n            }\n        }\n\n        if (sortRequired && this.children.length > 1)\n        {\n            this.children.sort(sortChildren);\n        }\n\n        this.sortDirty = false;\n    }\n\n    /**\n     * Updates the transform on all children of this container for rendering\n     */\n    updateTransform(): void\n    {\n        if (this.sortableChildren && this.sortDirty)\n        {\n            this.sortChildren();\n        }\n\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     *\n     */\n    calculateBounds(): void\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                const maskObject = ((child._mask as MaskData).maskObject || child._mask) as Container;\n\n                maskObject.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._bounds.updateID = this._boundsID;\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.\n     * @param {boolean} [skipChildrenUpdate=false] - Setting to `true` will stop re-calculation of children transforms,\n     *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\n     * @return {PIXI.Rectangle} The rectangular bounding area.\n     */\n    public getLocalBounds(rect?: Rectangle, skipChildrenUpdate = false): Rectangle\n    {\n        const result = super.getLocalBounds(rect);\n\n        if (!skipChildrenUpdate)\n        {\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                const child = this.children[i];\n\n                if (child.visible)\n                {\n                    child.updateTransform();\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Recalculates the bounds of the object. Override this to\n     * calculate the bounds of the specific object (not including children).\n     *\n     * @protected\n     */\n    protected _calculateBounds(): void\n    {\n        // FILL IN//\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    render(renderer: Renderer): void\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvanced(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            // simple render children!\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].render(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features.\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected renderAdvanced(renderer: Renderer): void\n    {\n        renderer.batch.flush();\n\n        const filters = this.filters;\n        const mask = this._mask;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n\n            if (this._enabledFilters.length)\n            {\n                renderer.filter.push(this, this._enabledFilters);\n            }\n        }\n\n        if (mask)\n        {\n            renderer.mask.push(this, this._mask);\n        }\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._render(renderer);\n\n        // now loop through the children and make sure they get rendered\n        for (let i = 0, j = this.children.length; i < j; i++)\n        {\n            this.children[i].render(renderer);\n        }\n\n        renderer.batch.flush();\n\n        if (mask)\n        {\n            renderer.mask.pop(this);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.pop();\n        }\n    }\n\n    /**\n     * To be overridden by the subclasses.\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _render(_renderer: Renderer): void // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options?: IDestroyOptions|boolean): void\n    {\n        super.destroy();\n\n        this.sortDirty = false;\n\n        const destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width(): number\n    {\n        return this.scale.x * this.getLocalBounds().width;\n    }\n\n    set width(value: number)\n    {\n        const width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height(): number\n    {\n        return this.scale.y * this.getLocalBounds().height;\n    }\n\n    set height(value: number)\n    {\n        const height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n}\n\n/**\n * Container default updateTransform, does update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.Container#\n * @function containerUpdateTransform\n */\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}